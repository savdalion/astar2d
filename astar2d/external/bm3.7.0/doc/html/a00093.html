<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BitMagic: bmfunc.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>bmfunc.h File Reference</h1><code>#include &lt;memory.h&gt;</code><br/>
<code>#include &quot;<a class="el" href="a00092_source.html">bmdef.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="a00102_source.html">bmutil.h</a>&quot;</code><br/>
<div class="dynheader">
Include dependency graph for bmfunc.h:</div>
<div class="dynsection">
<div class="center"><img src="a00139.png" border="0" usemap="#bmfunc_8h_map" alt=""/></div>
<map name="bmfunc_8h_map" id="bmfunc_8h">
<area shape="rect" href="a00092.html" title="bmdef.h" alt="" coords="89,160,156,189"/><area shape="rect" href="a00102.html" title="bmutil.h" alt="" coords="160,83,227,112"/><area shape="rect" href="a00091.html" title="bmconst.h" alt="" coords="180,160,263,189"/></map>
</div>
<div class="dynheader">
This graph shows which files directly or indirectly include this file:</div>
<div class="dynsection">
<div class="center"><img src="a00140.png" border="0" usemap="#bmfunc_8hdep_map" alt=""/></div>
<map name="bmfunc_8hdep_map" id="bmfunc_8hdep">
<area shape="rect" href="a00087.html" title="bm.h" alt="" coords="535,83,585,112"/><area shape="rect" href="a00088.html" title="bmalgo.h" alt="" coords="5,160,80,189"/><area shape="rect" href="a00096.html" title="bmserial.h" alt="" coords="1093,160,1173,189"/><area shape="rect" href="a00095.html" title="bmrandom.h" alt="" coords="104,160,197,189"/><area shape="rect" href="a00114.html" title="sample9.cpp" alt="" coords="91,237,187,267"/><area shape="rect" href="a00109.html" title="sample4.cpp" alt="" coords="1047,237,1143,267"/><area shape="rect" href="a00106.html" title="sample10.cpp" alt="" coords="403,237,504,267"/><area shape="rect" href="a00105.html" title="sample1.cpp" alt="" coords="512,160,608,189"/><area shape="rect" href="a00107.html" title="sample2.cpp" alt="" coords="683,160,779,189"/><area shape="rect" href="a00108.html" title="sample3.cpp" alt="" coords="803,160,899,189"/><area shape="rect" href="a00110.html" title="sample5.cpp" alt="" coords="923,160,1019,189"/><area shape="rect" href="a00111.html" title="sample6.cpp" alt="" coords="272,160,368,189"/><area shape="rect" href="a00113.html" title="sample8.cpp" alt="" coords="392,160,488,189"/></map>
</div>

<p><a href="a00093_source.html">Go to the source code of this file.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Data Structures</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00042.html">bm::bv_statistics</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Structure with statistical information about bitset's memory allocation details.  <a href="a00042.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00066.html">bm::gap_len_table&lt; T &gt;</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Default GAP lengths table.  <a href="a00066.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00067.html">bm::gap_len_table_min&lt; T &gt;</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Alternative GAP lengths table. Good for for memory saver mode and very sparse bitsets.  <a href="a00067.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00040.html">bm::block_set_table&lt; T &gt;</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Structure keeps all-left/right ON bits masks.  <a href="a00040.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00011.html">bm::all_set&lt; T &gt;</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Structure carries pointer on bit block with all bits 1.  <a href="a00011.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00012.html">bm::all_set&lt; T &gt;::all_set_block</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00010.html">bm::_copyright&lt; T &gt;</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Internal structure.  <a href="a00010.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00069.html">bm::globals&lt; T &gt;</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Internal structure.  <a href="a00069.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00041.html">bm::globals&lt; T &gt;::bo</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00049.html">bm::d_copy_func&lt; T &gt;</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">d-Gap copy functor  <a href="a00049.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00046.html">bm::copy_to_array_functor&lt; B &gt;</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adaptor to copy 1 bits to array.  <a href="a00046.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00047.html">bm::copy_to_array_functor_inc&lt; B &gt;</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adaptor to copy 1 bits to array with base increment.  <a href="a00047.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00035.html">bm::bitblock_get_adapter</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Bit-block get adapter, takes bitblock and represents it as a <a class="el" href="a00035.html#a5fd937c34bcb5e5a2f6aa25333480db2">get_32()</a> accessor function /internal.  <a href="a00035.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00036.html">bm::bitblock_store_adapter</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Bit-block store adapter, takes bitblock and saves results into it /internal.  <a href="a00036.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00037.html">bm::bitblock_sum_adapter</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Bit-block sum adapter, takes values and sums it /internal.  <a href="a00037.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00056.html">bm::decoder_range_adapter&lt; DEC &gt;</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adapter to get words from a range stream (see range serialized bit-block).  <a href="a00056.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00013.html">bm::bit_AND&lt; W &gt;</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Bit AND functor.  <a href="a00013.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00029.html">bm::bit_OR&lt; W &gt;</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Bit OR functor.  <a href="a00029.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00031.html">bm::bit_SUB&lt; W &gt;</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Bit SUB functor.  <a href="a00031.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00033.html">bm::bit_XOR&lt; W &gt;</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Bit XOR functor.  <a href="a00033.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00014.html">bm::bit_ASSIGN&lt; W &gt;</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Bit ASSIGN functor.  <a href="a00014.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00015.html">bm::bit_COUNT&lt; W &gt;</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Bit COUNT functor.  <a href="a00015.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00017.html">bm::bit_COUNT_AND&lt; W &gt;</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Bit COUNT AND functor.  <a href="a00017.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00023.html">bm::bit_COUNT_XOR&lt; W &gt;</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Bit COUNT XOR functor.  <a href="a00023.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00019.html">bm::bit_COUNT_OR&lt; W &gt;</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Bit COUNT OR functor.  <a href="a00019.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00020.html">bm::bit_COUNT_SUB_AB&lt; W &gt;</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Bit COUNT SUB AB functor.  <a href="a00020.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00021.html">bm::bit_COUNT_SUB_BA&lt; W &gt;</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Bit SUB BA functor.  <a href="a00021.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00016.html">bm::bit_COUNT_A&lt; W &gt;</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Bit COUNT A functor.  <a href="a00016.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00018.html">bm::bit_COUNT_B&lt; W &gt;</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Bit COUNT B functor.  <a href="a00018.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00076.html">bm::operation_functions&lt; T &gt;</a></td></tr>
<tr><td colspan="2"><h2>Namespaces</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00115.html">bm</a></td></tr>
<tr><td colspan="2"><h2>Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef void(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00115.html#a18a8f03b151ca3a6d5e39e7709fb6c7c">bm::gap_operation_to_bitset_func_type</a> )(unsigned *, const gap_word_t *)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef gap_word_t *(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00115.html#a8402de852093e5b23b5825f1974b9c12">bm::gap_operation_func_type</a> )(const gap_word_t *BMRESTRICT, const gap_word_t *BMRESTRICT, gap_word_t *BMRESTRICT, unsigned &amp;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="a00115.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a>(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00115.html#ad93f96a77f223240b8c6b8f81c5db840">bm::bit_operation_count_func_type</a> )(const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *BMRESTRICT, const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *BMRESTRICT, const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *BMRESTRICT)</td></tr>
<tr><td colspan="2"><h2>Enumerations</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00115.html#a76b70d2b9182a6dcac151d1bd9ec6109">bm::set_operation</a> { <br/>
&nbsp;&nbsp;<a class="el" href="a00115.html#a76b70d2b9182a6dcac151d1bd9ec6109a949fba4d9b152e1cbba9a450e05e21a3">bm::set_AND</a> =  0, 
<a class="el" href="a00115.html#a76b70d2b9182a6dcac151d1bd9ec6109a05d88a2639cbd3d2ac63436df3ed6780">bm::set_OR</a> =  1, 
<a class="el" href="a00115.html#a76b70d2b9182a6dcac151d1bd9ec6109a348f23af148237ac49194815b222b769">bm::set_SUB</a> =  2, 
<a class="el" href="a00115.html#a76b70d2b9182a6dcac151d1bd9ec6109ab823123a0d630167532a96be004e6304">bm::set_XOR</a> =  3, 
<br/>
&nbsp;&nbsp;<a class="el" href="a00115.html#a76b70d2b9182a6dcac151d1bd9ec6109a34150dd6a8ac2e70b887565bd1c3f788">bm::set_ASSIGN</a> =  4, 
<a class="el" href="a00115.html#a76b70d2b9182a6dcac151d1bd9ec6109a3f165b7944e33214e8721aaf2eb8378e">bm::set_COUNT</a> =  5, 
<a class="el" href="a00115.html#a76b70d2b9182a6dcac151d1bd9ec6109a378be4b14cee6a341e859fd3157ab959">bm::set_COUNT_AND</a> =  6, 
<a class="el" href="a00115.html#a76b70d2b9182a6dcac151d1bd9ec6109a1373054e4f243dffb762a55b8a8bfe4c">bm::set_COUNT_XOR</a> =  7, 
<br/>
&nbsp;&nbsp;<a class="el" href="a00115.html#a76b70d2b9182a6dcac151d1bd9ec6109a27e34c148d06e3d8a405482d820cd7fb">bm::set_COUNT_OR</a> =  8, 
<a class="el" href="a00115.html#a76b70d2b9182a6dcac151d1bd9ec6109a0028cc7084b37fe66ce5ae459b93b7f1">bm::set_COUNT_SUB_AB</a> =  9, 
<a class="el" href="a00115.html#a76b70d2b9182a6dcac151d1bd9ec6109a2f7b894c11c058598d02722a7eeef03b">bm::set_COUNT_SUB_BA</a> =  10, 
<a class="el" href="a00115.html#a76b70d2b9182a6dcac151d1bd9ec6109abafe8a971864164aeec7f43d1205ed29">bm::set_COUNT_A</a> =  11, 
<br/>
&nbsp;&nbsp;<a class="el" href="a00115.html#a76b70d2b9182a6dcac151d1bd9ec6109a2ac4eb7f41d00f8387d5dd3ffb9d0617">bm::set_COUNT_B</a> =  12, 
<a class="el" href="a00115.html#a76b70d2b9182a6dcac151d1bd9ec6109ad894d257a23664720dbf4155153a1e5c">bm::set_END</a>
<br/>
 }</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>Nomenclature of set operations. </p>
 <a href="a00115.html#a76b70d2b9182a6dcac151d1bd9ec6109">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00115.html#a42405343976ec931388381cea4092bf1">bm::operation</a> { <a class="el" href="a00115.html#a42405343976ec931388381cea4092bf1a546fdf33b301e5b9bee0591522ed9250">bm::BM_AND</a> =  set_AND, 
<a class="el" href="a00115.html#a42405343976ec931388381cea4092bf1a0c8cf0197857d0bd73a63037e2f2c5c5">bm::BM_OR</a> =  set_OR, 
<a class="el" href="a00115.html#a42405343976ec931388381cea4092bf1a1df0f4de7126bb2f7ce69d7a005affb5">bm::BM_SUB</a> =  set_SUB, 
<a class="el" href="a00115.html#a42405343976ec931388381cea4092bf1a45c2fe36efb72dc03f03a842d253f64c">bm::BM_XOR</a> =  set_XOR
 }</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>Bit operations enumeration. </p>
 <a href="a00115.html#a42405343976ec931388381cea4092bf1">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00115.html#a577905b348676c2bc556b51793350dbb">bm::ByteOrder</a> { <a class="el" href="a00115.html#a577905b348676c2bc556b51793350dbbac959b97503c42581f3dd81fd3b93fff2">bm::BigEndian</a> =  0, 
<a class="el" href="a00115.html#a577905b348676c2bc556b51793350dbba5ebe266b6d18ee74483c2bbf624e2cc2">bm::LittleEndian</a> =  1
 }</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>Byte orders recognized by the library. </p>
 <a href="a00115.html#a577905b348676c2bc556b51793350dbb">More...</a><br/></td></tr>
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">BMFORCEINLINE <a class="el" href="a00115.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00120.html#gaef40342b0c318391df3db2b891acf7c1">bm::word_bitcount</a> (<a class="el" href="a00115.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a> w)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00115.html#a30cec2c137813460f4b4c65c5879a4c3">bm::parallel_popcnt_32</a> (unsigned int n)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00115.html#a3deb310cdf11bca948817f94adfec160">bm::is_const_set_operation</a> (set_operation op)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns true if set operation is constant (bitcount).  <a href="#a3deb310cdf11bca948817f94adfec160"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00115.html#a42405343976ec931388381cea4092bf1">bm::operation</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00115.html#a7c192b64adb0590a09b5c2dad77c4b76">bm::setop2op</a> (<a class="el" href="a00115.html#a76b70d2b9182a6dcac151d1bd9ec6109">bm::set_operation</a> op)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convert set operation to operation.  <a href="#a7c192b64adb0590a09b5c2dad77c4b76"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename W &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00115.html#afb2c1acc56270abb381741a709a2b17c">bm::xor_swap</a> (W &amp;x, W &amp;y)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">XOR swap two scalar variables.  <a href="#afb2c1acc56270abb381741a709a2b17c"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">int&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00120.html#gafee2e8361c2e90a67dbaf9c7559d50e4">bm::wordcmp0</a> (T w1, T w2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Lexicographical comparison of two words as bit strings. Auxiliary implementation for testing and reference purposes.  <a href="a00120.html#gafee2e8361c2e90a67dbaf9c7559d50e4"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">int&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00120.html#ga5847533a73b7a5125fe5c2888ec827bd">bm::wordcmp</a> (T a, T b)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Lexicographical comparison of two words as bit strings. Auxiliary implementation for testing and reference purposes.  <a href="a00120.html#ga5847533a73b7a5125fe5c2888ec827bd"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">unsigned&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00115.html#acebed8b533c2c9e17167617501477693">bm::gap_bfind</a> (const T *buf, unsigned pos, unsigned *is_set)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">unsigned&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00119.html#ga866352ef5986a7d2b709795d127b666b">bm::gap_test</a> (const T *buf, unsigned pos)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Tests if bit = pos is true.  <a href="a00119.html#ga866352ef5986a7d2b709795d127b666b"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T , class F &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00115.html#a46953a43cfc3da7192d883b6dd822d99">bm::for_each_nzblock</a> (T ***root, unsigned size1, F &amp;f)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T , class F &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00115.html#ac6f5529fcc26412fc796b85770aa3a26">bm::for_each_nzblock2</a> (T ***root, unsigned size1, F &amp;f)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T , class F &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00115.html#a5b4e99c8ed7b929be87bd5a1ad76fd37">bm::for_each_nzblock_if</a> (T ***root, unsigned size1, F &amp;f)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T , class F &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00115.html#a8abecc773e9aaee744215278d1e6924e">bm::for_each_block</a> (T ***root, unsigned size1, F &amp;f)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T , class F &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">F&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00115.html#abf587377ca70f11b8eb75f95494830b5">bm::bmfor_each</a> (T first, T last, F f)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">T&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00115.html#ac8f3443ba8fcd1b28face4b09dfd21bf">bm::sum_arr</a> (T *first, T *last)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">unsigned&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00119.html#ga570a6f573ffb9ac9e41a688d2bdc6004">bm::gap_bit_count</a> (const T *buf, unsigned dsize=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Calculates number of bits ON in GAP buffer.  <a href="a00119.html#ga570a6f573ffb9ac9e41a688d2bdc6004"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">unsigned&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00115.html#a7324ebded429e15361f62117a2ff18d1">bm::gap_bit_count_range</a> (const T *buf, T left, T right)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Counts 1 bits in GAP buffer in the closed [left, right] diapason.  <a href="#a7324ebded429e15361f62117a2ff18d1"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T , class Func &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00115.html#a6a7bfe8af49ed785f0e96c7ca37a2155">bm::for_each_dgap</a> (const T *gap_buf, Func &amp;func)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">T *&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00115.html#afa6ea0cce0cdd88738a01fad393376b3">bm::gap_2_dgap</a> (const T *gap_buf, T *dgap_buf, bool copy_head=true)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convert GAP buffer into D-GAP buffer.  <a href="#afa6ea0cce0cdd88738a01fad393376b3"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00115.html#a528894002dcd8edda28c8fb2b0aa8c64">bm::dgap_2_gap</a> (const T *dgap_buf, T *gap_buf, T gap_header=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convert D-GAP buffer into GAP buffer.  <a href="#a528894002dcd8edda28c8fb2b0aa8c64"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">int&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00119.html#ga406952734f1b05962941b32e37b3eb96">bm::gapcmp</a> (const T *buf1, const T *buf2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Lexicographical comparison of GAP buffers.  <a href="a00119.html#ga406952734f1b05962941b32e37b3eb96"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T , class F &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00115.html#aac0daaac2b5a7c88e6be726c77f52c68">bm::gap_buff_op</a> (T *BMRESTRICT dest, const T *BMRESTRICT vect1, unsigned vect1_mask, const T *BMRESTRICT vect2, unsigned vect2_mask, F &amp;f, unsigned &amp;dlen)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Abstract operation for GAP buffers. Receives functor F as a template argument.  <a href="#aac0daaac2b5a7c88e6be726c77f52c68"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T , class F &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">unsigned&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00119.html#ga5e3123c3c9d3587f470abdbe6c8c3ad3">bm::gap_buff_any_op</a> (const T *BMRESTRICT vect1, unsigned vect1_mask, const T *BMRESTRICT vect2, unsigned vect2_mask, F f)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Abstract distance test operation for GAP buffers. Receives functor F as a template argument.  <a href="a00119.html#ga5e3123c3c9d3587f470abdbe6c8c3ad3"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T , class F &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">unsigned&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00119.html#ga9a5ff7782f3de0d1c699eb72d432f255">bm::gap_buff_count_op</a> (const T *vect1, const T *vect2, F f)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Abstract distance(similarity) operation for GAP buffers. Receives functor F as a template argument.  <a href="a00119.html#ga9a5ff7782f3de0d1c699eb72d432f255"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">unsigned&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00119.html#ga69186bd13bda27e04b3e33683ff884c2">bm::gap_set_value</a> (unsigned val, T *BMRESTRICT buf, unsigned pos, unsigned *BMRESTRICT is_set)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets or clears bit in the GAP buffer.  <a href="a00119.html#ga69186bd13bda27e04b3e33683ff884c2"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">unsigned&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00119.html#gadae4001e2834125b9c08b154a8a874a7">bm::gap_add_value</a> (T *buf, T pos)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add new value to the end of GAP buffer.  <a href="a00119.html#gadae4001e2834125b9c08b154a8a874a7"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">unsigned&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00119.html#ga550394048c163d41a135fb9068f2251b">bm::gap_set_array</a> (T *buf, const T *arr, unsigned len)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convert array to GAP buffer.  <a href="a00119.html#ga550394048c163d41a135fb9068f2251b"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">unsigned&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00119.html#ga68e53a96e93a31e8a323d10c7a2f21f5">bm::bit_array_compute_gaps</a> (const T *arr, unsigned len)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute number of GAPs in bit-array.  <a href="a00119.html#ga68e53a96e93a31e8a323d10c7a2f21f5"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">int&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00119.html#gaa7df7193094353ea24b8519debf745be">bm::gap_find_in_block</a> (const T *buf, unsigned nbit, <a class="el" href="a00115.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a> *prev)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Searches for the next 1 bit in the GAP block.  <a href="a00119.html#gaa7df7193094353ea24b8519debf745be"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">BMFORCEINLINE void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00120.html#ga2becf9a16ec20ab124ca8938e34b4aa8">bm::set_bit</a> (unsigned *dest, unsigned bitpos)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set 1 bit in a block.  <a href="a00120.html#ga2becf9a16ec20ab124ca8938e34b4aa8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">BMFORCEINLINE unsigned&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00120.html#ga9bccc586aa791f98f1bec284b799102c">bm::test_bit</a> (const unsigned *block, unsigned bitpos)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Test 1 bit in a block.  <a href="a00120.html#ga9bccc586aa791f98f1bec284b799102c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00120.html#gad698b5242f5b629aa28e7338b7150497">bm::or_bit_block</a> (unsigned *dest, unsigned bitpos, unsigned bitcount)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets bits to 1 in the bitblock.  <a href="a00120.html#gad698b5242f5b629aa28e7338b7150497"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00120.html#gaceaa54aa59b16299f5a87b925715e5e8">bm::sub_bit_block</a> (unsigned *dest, unsigned bitpos, unsigned bitcount)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">SUB (AND NOT) bit interval to 1 in the bitblock.  <a href="a00120.html#gaceaa54aa59b16299f5a87b925715e5e8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00120.html#ga6191abb017003b633fab24e0c6357521">bm::xor_bit_block</a> (unsigned *dest, unsigned bitpos, unsigned bitcount)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">XOR bit interval to 1 in the bitblock.  <a href="a00120.html#ga6191abb017003b633fab24e0c6357521"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00119.html#gabcedad4aea1a503c30f10e6d09b523f2">bm::gap_sub_to_bitset</a> (unsigned *BMRESTRICT dest, const T *BMRESTRICT buf)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">SUB (AND NOT) GAP block to bitblock.  <a href="a00119.html#gabcedad4aea1a503c30f10e6d09b523f2"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00119.html#ga63c33428c2f5eac9f69d663203cd2172">bm::gap_xor_to_bitset</a> (unsigned *BMRESTRICT dest, const T *BMRESTRICT buf)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">XOR GAP block to bitblock.  <a href="a00119.html#ga63c33428c2f5eac9f69d663203cd2172"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00119.html#ga78510a39b6e8c6b8904ecbffb6ab215b">bm::gap_add_to_bitset_l</a> (unsigned *dest, const T *buf, unsigned buf_len)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds(OR) GAP block to bitblock.  <a href="a00119.html#ga78510a39b6e8c6b8904ecbffb6ab215b"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00119.html#ga12615cd62f2e5367e1bc688d00a2188f">bm::gap_add_to_bitset</a> (unsigned *dest, const T *buf)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds(OR) GAP block to bitblock.  <a href="a00119.html#ga12615cd62f2e5367e1bc688d00a2188f"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00119.html#gafe6f72a009618290eeab3cddee869543">bm::gap_and_to_bitset</a> (unsigned *dest, const T *buf)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">ANDs GAP block to bitblock.  <a href="a00119.html#gafe6f72a009618290eeab3cddee869543"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00115.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00120.html#gab87384cbf46a04d86c008ab2463d02cc">bm::gap_bitset_and_count</a> (const unsigned *block, const T *buf)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute bitcount of bit block AND masked by GAP block.  <a href="a00120.html#gab87384cbf46a04d86c008ab2463d02cc"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00115.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00120.html#gad6e40898b8836ae1923b06a3d028fcaa">bm::gap_bitset_and_any</a> (const unsigned *block, const T *buf)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Bitcount test of bit block AND masked by GAP block.  <a href="a00120.html#gad6e40898b8836ae1923b06a3d028fcaa"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00115.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00120.html#ga15a780da58d5aeb67ffc51c84fa6152e">bm::gap_bitset_sub_count</a> (const unsigned *block, const T *buf)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute bitcount of bit block SUB masked by GAP block.  <a href="a00120.html#ga15a780da58d5aeb67ffc51c84fa6152e"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00115.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00120.html#gaab7c711122e8f189555dffd83a21111c">bm::gap_bitset_sub_any</a> (const unsigned *block, const T *buf)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute bitcount test of bit block SUB masked by GAP block.  <a href="a00120.html#gaab7c711122e8f189555dffd83a21111c"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00115.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00120.html#ga803fbc7c790f07b14175303e524bd2d8">bm::gap_bitset_xor_count</a> (const unsigned *block, const T *buf)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute bitcount of bit block XOR masked by GAP block.  <a href="a00120.html#ga803fbc7c790f07b14175303e524bd2d8"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00115.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00120.html#gad0f7ee00f84ea357d55e6a2f507c8918">bm::gap_bitset_xor_any</a> (const unsigned *block, const T *buf)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute bitcount test of bit block XOR masked by GAP block.  <a href="a00120.html#gad0f7ee00f84ea357d55e6a2f507c8918"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00115.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00120.html#ga23733890861063a59f787e26763a734a">bm::gap_bitset_or_count</a> (const unsigned *block, const T *buf)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute bitcount of bit block OR masked by GAP block.  <a href="a00120.html#ga23733890861063a59f787e26763a734a"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00115.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00120.html#gad15f1b92c70752cd3b97fa9e0c585f00">bm::gap_bitset_or_any</a> (const unsigned *block, const T *buf)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute bitcount test of bit block OR masked by GAP block.  <a href="a00120.html#gad15f1b92c70752cd3b97fa9e0c585f00"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00120.html#gaada8b13c35acd8df90129b45edcfc5de">bm::bit_block_set</a> (<a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *BMRESTRICT dst, <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> value)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Bitblock memset operation.  <a href="a00120.html#gaada8b13c35acd8df90129b45edcfc5de"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00119.html#ga4862f4dcdcb7c0575e2e2db9e5f2a849">bm::gap_convert_to_bitset</a> (unsigned *dest, const T *buf)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">GAP block to bitblock conversion.  <a href="a00119.html#ga4862f4dcdcb7c0575e2e2db9e5f2a849"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00119.html#ga1dd58e3576239c49010b62a3add42417">bm::gap_convert_to_bitset_l</a> (unsigned *dest, const T *buf, unsigned buf_len)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">GAP block to bitblock conversion.  <a href="a00119.html#ga1dd58e3576239c49010b62a3add42417"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00119.html#ga9bb80c42ee0ecf8f2af8250d7f5d327b">bm::gap_convert_to_bitset</a> (unsigned *dest, const T *buf, unsigned dest_len)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">GAP block to bitblock conversion.  <a href="a00119.html#ga9bb80c42ee0ecf8f2af8250d7f5d327b"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">unsigned *&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00119.html#ga3f01bb7c1ae7983aa8c4ba82e1e3f54c">bm::gap_convert_to_bitset_smart</a> (unsigned *dest, const T *buf, id_t set_max)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Smart GAP block to bitblock conversion.  <a href="a00119.html#ga3f01bb7c1ae7983aa8c4ba82e1e3f54c"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">unsigned&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00119.html#ga14d29338ffd1387758810b3f9e3a72c6">bm::gap_control_sum</a> (const T *buf)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Calculates sum of all words in GAP block. (For debugging purposes).  <a href="a00119.html#ga14d29338ffd1387758810b3f9e3a72c6"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00119.html#gaef53b2877ff369badd7bb25b26bb9029">bm::gap_set_all</a> (T *buf, unsigned set_max, unsigned value)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets all bits to 0 or 1 (GAP).  <a href="a00119.html#gaef53b2877ff369badd7bb25b26bb9029"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00119.html#ga510ab7feb60c19f7d7811cc304fdf649">bm::gap_init_range_block</a> (T *buf, T from, T to, T value, unsigned set_max)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Init gap block so it has block in it (can be whole block).  <a href="a00119.html#ga510ab7feb60c19f7d7811cc304fdf649"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00119.html#ga3f22bfde5dfe06d6d77dc2598b8c0845">bm::gap_invert</a> (T *buf)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Inverts all bits in the GAP buffer.  <a href="a00119.html#ga3f22bfde5dfe06d6d77dc2598b8c0845"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00119.html#ga690ff7c8b16e1821a77663b7194267e7">bm::gap_is_all_zero</a> (const T *buf, unsigned set_max)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Temporary inverts all bits in the GAP buffer.  <a href="a00119.html#ga690ff7c8b16e1821a77663b7194267e7"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00119.html#ga1427d43e91872f981c6311fa76ab5633">bm::gap_is_all_one</a> (const T *buf, unsigned set_max)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Checks if GAP block is all-one.  <a href="a00119.html#ga1427d43e91872f981c6311fa76ab5633"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">T&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00119.html#ga02541ec6c2930c292eda4313b78e874c">bm::gap_length</a> (const T *buf)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returs GAP block length.  <a href="a00119.html#ga02541ec6c2930c292eda4313b78e874c"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">unsigned&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00119.html#ga0419ed06e2f0b7891e7d721546f5fb45">bm::gap_capacity</a> (const T *buf, const T *glevel_len)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returs GAP block capacity.  <a href="a00119.html#ga0419ed06e2f0b7891e7d721546f5fb45"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">unsigned&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00119.html#ga94a5371b5dc6a1560d95d7c2dde88815">bm::gap_limit</a> (const T *buf, const T *glevel_len)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returs GAP block capacity limit.  <a href="a00119.html#ga94a5371b5dc6a1560d95d7c2dde88815"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">unsigned&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00119.html#ga1defe73aa4227a0e7204363ac6bb1ac1">bm::gap_level</a> (const T *buf)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returs GAP blocks capacity level.  <a href="a00119.html#ga1defe73aa4227a0e7204363ac6bb1ac1"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00119.html#ga501aa9bf029e7f9ea9518e7003fe5549">bm::set_gap_level</a> (T *buf, unsigned level)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets GAP block capacity level.  <a href="a00119.html#ga501aa9bf029e7f9ea9518e7003fe5549"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">int&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00119.html#ga3bfaebeeb4b2d479c5a9ac9d57607165">bm::gap_calc_level</a> (int len, const T *glevel_len)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Calculates GAP block capacity level.  <a href="a00119.html#ga3bfaebeeb4b2d479c5a9ac9d57607165"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">unsigned&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00119.html#gafd76869eb44fac688da5e26e0e74f41f">bm::gap_free_elements</a> (const T *buf, const T *glevel_len)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns number of free elements in GAP block array. Difference between GAP block capacity on this level and actual GAP length.  <a href="a00119.html#gafd76869eb44fac688da5e26e0e74f41f"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">int&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00120.html#ga91fe9566575d9d66e1bb9d030b3d29a0">bm::bitcmp</a> (const T *buf1, const T *buf2, unsigned len)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Lexicographical comparison of BIT buffers.  <a href="a00120.html#ga91fe9566575d9d66e1bb9d030b3d29a0"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">unsigned&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00119.html#ga80d09bb6ab244e68ab0c1fdccc17b95b">bm::bit_convert_to_gap</a> (T *BMRESTRICT dest, const unsigned *BMRESTRICT src, <a class="el" href="a00115.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a> bits, unsigned dest_len)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Converts bit block to GAP.  <a href="a00119.html#ga80d09bb6ab244e68ab0c1fdccc17b95b"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T , class F &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00119.html#ga11bc26da8533752bb23756632fd30a00">bm::for_each_gap_dbit</a> (const T *buf, F &amp;func)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Iterate gap block as delta-bits with a functor.  <a href="a00119.html#ga11bc26da8533752bb23756632fd30a00"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename D , typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">D&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00119.html#ga5cd7e0cfee401da1b8f702151c083b27">bm::gap_convert_to_arr</a> (D *BMRESTRICT dest, const T *BMRESTRICT buf, unsigned dest_len, bool invert=false)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convert gap block into array of ints corresponding to 1 bits.  <a href="a00119.html#ga5cd7e0cfee401da1b8f702151c083b27"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00115.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00120.html#gab30df14a61f036d690c091878feaff1c">bm::bit_block_calc_count</a> (const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *block, const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *block_end)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Bitcount for bit string.  <a href="a00120.html#gab30df14a61f036d690c091878feaff1c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00115.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00120.html#gaafc87c4764bb30d95ba4088064a404e3">bm::bit_count_change</a> (<a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> w)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00115.html#ae2222be6fd45b4bab5100ce70e3b4f88">bm::bit_count_change32</a> (const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *block, const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *block_end, unsigned *bit_count, unsigned *gap_count)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00115.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00120.html#gaca91016aeb08ae1b610d6d407aae0e4c">bm::bit_block_calc_count_change</a> (const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *block, const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *block_end, unsigned *bit_count)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00115.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00120.html#ga2485f707b2629c5ce7681cf9fe385b91">bm::bit_block_calc_count_range</a> (const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *block, <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> left, <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> right)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00115.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00120.html#ga503e0f3e79f819d9b58e4b0e905be116">bm::bit_block_any_range</a> (const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *block, <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> left, <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> right)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00120.html#ga95854f9969985254a0f58b928da0eec6">bm::bit_invert</a> (T *start, T *end)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00120.html#ga97b1075250d4bf10f596ff2fbc334ceb">bm::is_bits_one</a> (const <a class="el" href="a00115.html#a7176bf7817550ca24cb6612bd8d7957d">bm::wordop_t</a> *start, const <a class="el" href="a00115.html#a7176bf7817550ca24cb6612bd8d7957d">bm::wordop_t</a> *end)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns "true" if all bits in the block are 1.  <a href="a00120.html#ga97b1075250d4bf10f596ff2fbc334ceb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00120.html#gac6cfb9f92e4df6bb4c76f6efb2382860">bm::bit_is_all_zero</a> (const <a class="el" href="a00115.html#a7176bf7817550ca24cb6612bd8d7957d">bm::wordop_t</a> *start, const <a class="el" href="a00115.html#a7176bf7817550ca24cb6612bd8d7957d">bm::wordop_t</a> *end)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns "true" if all bits in the block are 0.  <a href="a00120.html#gac6cfb9f92e4df6bb4c76f6efb2382860"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">BMFORCEINLINE unsigned&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00115.html#a8d943cf66c4592e2baddf5bc0667adbd">bm::and_op</a> (unsigned v1, unsigned v2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">GAP and functor.  <a href="#a8d943cf66c4592e2baddf5bc0667adbd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">BMFORCEINLINE unsigned&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00115.html#a6e7085de3103a42f81c0d3d82903cd5f">bm::xor_op</a> (unsigned v1, unsigned v2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">GAP xor functor.  <a href="#a6e7085de3103a42f81c0d3d82903cd5f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">BMFORCEINLINE unsigned&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00115.html#ac330d13a0846ca89ff6fc6927e675a93">bm::or_op</a> (unsigned v1, unsigned v2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">GAP or functor.  <a href="#ac330d13a0846ca89ff6fc6927e675a93"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">BMFORCEINLINE unsigned&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00115.html#a35c5866395bfb88b68913b32539a2b96">bm::sub_op</a> (unsigned v1, unsigned v2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">GAP or functor.  <a href="#a35c5866395bfb88b68913b32539a2b96"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">BMFORCEINLINE gap_word_t *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00119.html#gac18d7da0492983802511999a4ad0764a">bm::gap_operation_and</a> (const gap_word_t *BMRESTRICT vect1, const gap_word_t *BMRESTRICT vect2, gap_word_t *BMRESTRICT tmp_buf, unsigned &amp;dsize)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">GAP AND operation.  <a href="a00119.html#gac18d7da0492983802511999a4ad0764a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">BMFORCEINLINE unsigned&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00119.html#ga58e0312d3ab0551e883176b170c0a3e8">bm::gap_operation_any_and</a> (const gap_word_t *BMRESTRICT vect1, const gap_word_t *BMRESTRICT vect2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">GAP AND operation test.  <a href="a00119.html#ga58e0312d3ab0551e883176b170c0a3e8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">BMFORCEINLINE unsigned&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00119.html#gafd92d013b0c377604831f401ef6917b8">bm::gap_count_and</a> (const gap_word_t *BMRESTRICT vect1, const gap_word_t *BMRESTRICT vect2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">GAP bitcount AND operation test.  <a href="a00119.html#gafd92d013b0c377604831f401ef6917b8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">BMFORCEINLINE gap_word_t *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00119.html#ga72d2d3933b4410413eeb02e9ee0a910d">bm::gap_operation_xor</a> (const gap_word_t *BMRESTRICT vect1, const gap_word_t *BMRESTRICT vect2, gap_word_t *BMRESTRICT tmp_buf, unsigned &amp;dsize)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">GAP XOR operation.  <a href="a00119.html#ga72d2d3933b4410413eeb02e9ee0a910d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">BMFORCEINLINE unsigned&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00119.html#gab8800dff60eb05404a83159035e8e72f">bm::gap_operation_any_xor</a> (const gap_word_t *BMRESTRICT vect1, const gap_word_t *BMRESTRICT vect2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">GAP XOR operation test.  <a href="a00119.html#gab8800dff60eb05404a83159035e8e72f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">BMFORCEINLINE unsigned&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00119.html#gae38d6a3296f0562be512f47b4edfb1ad">bm::gap_count_xor</a> (const gap_word_t *BMRESTRICT vect1, const gap_word_t *BMRESTRICT vect2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">GAP bitcount XOR operation test.  <a href="a00119.html#gae38d6a3296f0562be512f47b4edfb1ad"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">gap_word_t *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00119.html#gacda280af8910ae5fde37731a3a7a1226">bm::gap_operation_or</a> (const gap_word_t *BMRESTRICT vect1, const gap_word_t *BMRESTRICT vect2, gap_word_t *BMRESTRICT tmp_buf, unsigned &amp;dsize)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">GAP OR operation.  <a href="a00119.html#gacda280af8910ae5fde37731a3a7a1226"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">BMFORCEINLINE unsigned&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00119.html#ga125fc8dc68245a11a171e7793c6588a2">bm::gap_count_or</a> (const gap_word_t *BMRESTRICT vect1, const gap_word_t *BMRESTRICT vect2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">GAP bitcount OR operation test.  <a href="a00119.html#ga125fc8dc68245a11a171e7793c6588a2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">gap_word_t *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00119.html#gabe4c83e5e162c38e297116dd1cd05ac4">bm::gap_operation_sub</a> (const gap_word_t *BMRESTRICT vect1, const gap_word_t *BMRESTRICT vect2, gap_word_t *BMRESTRICT tmp_buf, unsigned &amp;dsize)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">GAP SUB (AND NOT) operation.  <a href="a00119.html#gabe4c83e5e162c38e297116dd1cd05ac4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">BMFORCEINLINE unsigned&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00119.html#ga1c9b33d00f74206ad655dc2cef52428b">bm::gap_operation_any_sub</a> (const gap_word_t *BMRESTRICT vect1, const gap_word_t *BMRESTRICT vect2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">GAP SUB operation test.  <a href="a00119.html#ga1c9b33d00f74206ad655dc2cef52428b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">BMFORCEINLINE unsigned&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00119.html#gacacf55c60da82a1c384f3ac3a51229d4">bm::gap_count_sub</a> (const gap_word_t *BMRESTRICT vect1, const gap_word_t *BMRESTRICT vect2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">GAP bitcount SUB (AND NOT) operation test.  <a href="a00119.html#gacacf55c60da82a1c384f3ac3a51229d4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00120.html#ga9090de87d53e7f25eff96c8259b3485c">bm::bit_block_copy</a> (<a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *BMRESTRICT dst, const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *BMRESTRICT src)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Bitblock copy operation.  <a href="a00120.html#ga9090de87d53e7f25eff96c8259b3485c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00120.html#ga882f79df0a0175ad4ddf483c5f1eeb0e">bm::bit_block_and</a> (<a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *BMRESTRICT dst, const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *BMRESTRICT src)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Plain bitblock AND operation. Function does not analyse availability of source and destination blocks.  <a href="a00120.html#ga882f79df0a0175ad4ddf483c5f1eeb0e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00120.html#ga0070984bb1d332610150a9106ab8eb0a">bm::bit_block_and_count</a> (const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *src1, const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *src1_end, const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *src2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Function ANDs two bitblocks and computes the bitcount. Function does not analyse availability of source blocks.  <a href="a00120.html#ga0070984bb1d332610150a9106ab8eb0a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00120.html#ga9fe2d12ddac5293fe53038c687c732f3">bm::bit_block_and_any</a> (const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *src1, const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *src1_end, const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *src2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Function ANDs two bitblocks and tests for any bit. Function does not analyse availability of source blocks.  <a href="a00120.html#ga9fe2d12ddac5293fe53038c687c732f3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00120.html#gaf8af8cfe8b49407be1af7398da28c939">bm::bit_block_xor_count</a> (const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *BMRESTRICT src1, const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *BMRESTRICT src1_end, const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *BMRESTRICT src2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Function XORs two bitblocks and computes the bitcount. Function does not analyse availability of source blocks.  <a href="a00120.html#gaf8af8cfe8b49407be1af7398da28c939"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00120.html#gafbc3ffafc859a503fdd2fc96e7fb60ce">bm::bit_block_xor_any</a> (const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *BMRESTRICT src1, const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *BMRESTRICT src1_end, const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *BMRESTRICT src2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Function XORs two bitblocks and and tests for any bit. Function does not analyse availability of source blocks.  <a href="a00120.html#gafbc3ffafc859a503fdd2fc96e7fb60ce"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00120.html#gad34175255e9860a572fcf2e664a6de8e">bm::bit_block_sub_count</a> (const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *BMRESTRICT src1, const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *BMRESTRICT src1_end, const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *BMRESTRICT src2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Function SUBs two bitblocks and computes the bitcount. Function does not analyse availability of source blocks.  <a href="a00120.html#gad34175255e9860a572fcf2e664a6de8e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00120.html#ga3f51735d2ca08e5a9fae2c9c49138c5c">bm::bit_block_sub_any</a> (const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *BMRESTRICT src1, const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *BMRESTRICT src1_end, const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *BMRESTRICT src2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Function SUBs two bitblocks and and tests for any bit. Function does not analyse availability of source blocks.  <a href="a00120.html#ga3f51735d2ca08e5a9fae2c9c49138c5c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00120.html#gacf4f8ab164277278448a541863c07517">bm::bit_block_or_count</a> (const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *src1, const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *src1_end, const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *src2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Function ORs two bitblocks and computes the bitcount. Function does not analyse availability of source blocks.  <a href="a00120.html#gacf4f8ab164277278448a541863c07517"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00120.html#gab2047495f7844d3014ff697503669d24">bm::bit_block_or_any</a> (const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *BMRESTRICT src1, const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *BMRESTRICT src1_end, const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *BMRESTRICT src2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Function ORs two bitblocks and and tests for any bit. Function does not analyse availability of source blocks.  <a href="a00120.html#gab2047495f7844d3014ff697503669d24"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00120.html#ga869fce5348076d4c7b92adcc2f1a49ab">bm::bit_operation_and</a> (<a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *BMRESTRICT dst, const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *BMRESTRICT src)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">bitblock AND operation.  <a href="a00120.html#ga869fce5348076d4c7b92adcc2f1a49ab"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00115.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00120.html#ga9765914087df2fc22ec18db8128f2a12">bm::bit_operation_and_count</a> (const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *BMRESTRICT src1, const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *BMRESTRICT src1_end, const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *BMRESTRICT src2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs bitblock AND operation and calculates bitcount of the result.  <a href="a00120.html#ga9765914087df2fc22ec18db8128f2a12"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00115.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00120.html#ga0e7995f7d6c791f6ff27a8dd21d324e5">bm::bit_operation_and_any</a> (const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *BMRESTRICT src1, const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *BMRESTRICT src1_end, const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *BMRESTRICT src2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs bitblock AND operation test.  <a href="a00120.html#ga0e7995f7d6c791f6ff27a8dd21d324e5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00115.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00120.html#gaabb39bf01bf973cb7bf3648873921ab7">bm::bit_operation_sub_count</a> (const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *BMRESTRICT src1, const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *BMRESTRICT src1_end, const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *BMRESTRICT src2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs bitblock SUB operation and calculates bitcount of the result.  <a href="a00120.html#gaabb39bf01bf973cb7bf3648873921ab7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00115.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00120.html#ga53867faf377db72324b858a37063c0b8">bm::bit_operation_sub_count_inv</a> (const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *BMRESTRICT src1, const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *BMRESTRICT src1_end, const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *BMRESTRICT src2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs inverted bitblock SUB operation and calculates bitcount of the result.  <a href="a00120.html#ga53867faf377db72324b858a37063c0b8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00115.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00120.html#ga847d5a84673b284be984f0db583e2723">bm::bit_operation_sub_any</a> (const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *BMRESTRICT src1, const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *BMRESTRICT src1_end, const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *BMRESTRICT src2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs bitblock test of SUB operation.  <a href="a00120.html#ga847d5a84673b284be984f0db583e2723"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00115.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00120.html#ga5a267aff3b56cc6dadf5a3a338e00a1d">bm::bit_operation_or_count</a> (const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *BMRESTRICT src1, const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *BMRESTRICT src1_end, const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *BMRESTRICT src2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs bitblock OR operation and calculates bitcount of the result.  <a href="a00120.html#ga5a267aff3b56cc6dadf5a3a338e00a1d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00115.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00120.html#ga6d26742bdc373074474a6932eab4f388">bm::bit_operation_or_any</a> (const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *BMRESTRICT src1, const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *BMRESTRICT src1_end, const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *BMRESTRICT src2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs bitblock OR operation test.  <a href="a00120.html#ga6d26742bdc373074474a6932eab4f388"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00120.html#ga3515d8eb5da7f9d41d63dc90ad9523a4">bm::bit_block_or</a> (<a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *BMRESTRICT dst, const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *BMRESTRICT src)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Plain bitblock OR operation. Function does not analyse availability of source and destination blocks.  <a href="a00120.html#ga3515d8eb5da7f9d41d63dc90ad9523a4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00120.html#ga0e945a9eaae699ad40f63b3f0632e6f9">bm::bit_operation_or</a> (<a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *BMRESTRICT dst, const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *BMRESTRICT src)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Block OR operation. Makes analysis if block is 0 or FULL.  <a href="a00120.html#ga0e945a9eaae699ad40f63b3f0632e6f9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00120.html#gafed81435f74c0542857842d4461686e4">bm::bit_block_sub</a> (<a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *BMRESTRICT dst, const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *BMRESTRICT src)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Plain bitblock SUB (AND NOT) operation. Function does not analyse availability of source and destination blocks.  <a href="a00120.html#gafed81435f74c0542857842d4461686e4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00120.html#gad7afa9bce28a376360ca4826960d669f">bm::bit_operation_sub</a> (<a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *BMRESTRICT dst, const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *BMRESTRICT src)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">bitblock SUB operation.  <a href="a00120.html#gad7afa9bce28a376360ca4826960d669f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00120.html#gae6a46c5e671ea1c9312219ceb41025ef">bm::bit_block_xor</a> (<a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *BMRESTRICT dst, const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *BMRESTRICT src)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Plain bitblock XOR operation. Function does not analyse availability of source and destination blocks.  <a href="a00120.html#gae6a46c5e671ea1c9312219ceb41025ef"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00120.html#ga179de722e87ccf8189d975ca6beed025">bm::bit_operation_xor</a> (<a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *BMRESTRICT dst, const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *BMRESTRICT src)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">bitblock XOR operation.  <a href="a00120.html#ga179de722e87ccf8189d975ca6beed025"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00115.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00120.html#gace08ab77feefb638daee164ee83118bc">bm::bit_operation_xor_count</a> (const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *BMRESTRICT src1, const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *BMRESTRICT src1_end, const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *BMRESTRICT src2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs bitblock XOR operation and calculates bitcount of the result.  <a href="a00120.html#gace08ab77feefb638daee164ee83118bc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00115.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00120.html#gaa86561b6d11c3f01dd772563c692f732">bm::bit_operation_xor_any</a> (const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *BMRESTRICT src1, const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *BMRESTRICT src1_end, const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *BMRESTRICT src2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs bitblock XOR operation test.  <a href="a00120.html#gaa86561b6d11c3f01dd772563c692f732"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">unsigned&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00120.html#ga0ff158706f2e194be67fb8267641c30a">bm::bit_count_nonzero_size</a> (const T *blk, unsigned data_size)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Inspects block for full zero words.  <a href="a00120.html#ga0ff158706f2e194be67fb8267641c30a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00120.html#gad6a7c549a625df7aa7d68d43a57238c7">bm::bit_find_in_block</a> (const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *data, unsigned nbit, <a class="el" href="a00115.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a> *prev)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Searches for the next 1 bit in the BIT block.  <a href="a00120.html#gad6a7c549a625df7aa7d68d43a57238c7"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T , typename F &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00120.html#gab9f80b3c898323ce77beb915e4c861f3">bm::bit_for_each_4</a> (T w, F &amp;func)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Templated algorithm to unpacks octet based word into list of ON bit indexes.  <a href="a00120.html#gab9f80b3c898323ce77beb915e4c861f3"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T , typename F &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00120.html#ga24be2ad5d8c2a8f18fdad142452aaae8">bm::bit_for_each</a> (T w, F &amp;func)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Templated algorithm to unpacks word into list of ON bit indexes.  <a href="a00120.html#ga24be2ad5d8c2a8f18fdad142452aaae8"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T , typename B &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">unsigned&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00120.html#ga3c81f6bff8866ec3ed0a94903eee96b7">bm::bit_list_4</a> (T w, B *bits)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unpacks word into list of ON bit indexes (quad-bit based).  <a href="a00120.html#ga3c81f6bff8866ec3ed0a94903eee96b7"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T , typename B &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">unsigned&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00120.html#gaae3ae537760044543f842363e4614e82">bm::bit_list</a> (T w, B *bits)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unpacks word into list of ON bit indexes.  <a href="a00120.html#gaae3ae537760044543f842363e4614e82"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00115.html#a593916a103395805070a3200720c6416">bm::set_representation</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00120.html#ga20610fae6b0de84957b74ed17429667f">bm::best_representation</a> (unsigned bit_count, unsigned total_possible_bitcount, unsigned gap_count, unsigned block_size)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Choose best representation for a bit-block.  <a href="a00120.html#ga20610fae6b0de84957b74ed17429667f"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">T&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00120.html#gaf24d85761f60877c2260f8160593f732">bm::bit_convert_to_arr</a> (T *BMRESTRICT dest, const unsigned *BMRESTRICT src, <a class="el" href="a00115.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a> bits, unsigned dest_len, unsigned mask=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convert bit block into an array of ints corresponding to 1 bits.  <a href="a00120.html#gaf24d85761f60877c2260f8160593f732"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">unsigned&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00119.html#gacc578010f3700940829c600c812d23b1">bm::gap_overhead</a> (const T *length, const T *length_end, const T *glevel_len)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convert bit block into an array of ints corresponding to 1 bits.  <a href="a00119.html#gacc578010f3700940829c600c812d23b1"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00119.html#ga2daff3a0ceda6fef87d3b0e892da5813">bm::improve_gap_levels</a> (const T *length, const T *length_end, T *glevel_len)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Finds optimal gap blocks lengths.  <a href="a00119.html#ga2daff3a0ceda6fef87d3b0e892da5813"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class It1 , class It2 , class BinaryOp , class Encoder &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00115.html#a503fecc0ee281059897412d68f489e1e">bm::bit_recomb</a> (It1 &amp;it1, It2 &amp;it2, BinaryOp &amp;op, Encoder &amp;enc, unsigned block_size=<a class="el" href="a00115.html#a91319dbc0d0e1bf3a3efc4d92bac7972">bm::set_block_size</a>)</td></tr>
</table>
</div>
<hr size="1"/><address style="text-align: right;"><small>Generated on Sun Apr 25 09:37:31 2010 for BitMagic by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
