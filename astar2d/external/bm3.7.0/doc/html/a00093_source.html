<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BitMagic: bmfunc.h Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
<h1>bmfunc.h</h1><a href="a00093.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="preprocessor">#ifndef BMFUNC__H__INCLUDED__</span>
<a name="l00002"></a>00002 <span class="preprocessor"></span><span class="preprocessor">#define BMFUNC__H__INCLUDED__</span>
<a name="l00003"></a>00003 <span class="preprocessor"></span><span class="comment">/*</span>
<a name="l00004"></a>00004 <span class="comment">Copyright(c) 2002-2010 Anatoliy Kuznetsov(anatoliy_kuznetsov at yahoo.com)</span>
<a name="l00005"></a>00005 <span class="comment"></span>
<a name="l00006"></a>00006 <span class="comment">Permission is hereby granted, free of charge, to any person </span>
<a name="l00007"></a>00007 <span class="comment">obtaining a copy of this software and associated documentation </span>
<a name="l00008"></a>00008 <span class="comment">files (the &quot;Software&quot;), to deal in the Software without restriction, </span>
<a name="l00009"></a>00009 <span class="comment">including without limitation the rights to use, copy, modify, merge, </span>
<a name="l00010"></a>00010 <span class="comment">publish, distribute, sublicense, and/or sell copies of the Software, </span>
<a name="l00011"></a>00011 <span class="comment">and to permit persons to whom the Software is furnished to do so, </span>
<a name="l00012"></a>00012 <span class="comment">subject to the following conditions:</span>
<a name="l00013"></a>00013 <span class="comment"></span>
<a name="l00014"></a>00014 <span class="comment">The above copyright notice and this permission notice shall be included </span>
<a name="l00015"></a>00015 <span class="comment">in all copies or substantial portions of the Software.</span>
<a name="l00016"></a>00016 <span class="comment"></span>
<a name="l00017"></a>00017 <span class="comment">THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, </span>
<a name="l00018"></a>00018 <span class="comment">EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES </span>
<a name="l00019"></a>00019 <span class="comment">OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. </span>
<a name="l00020"></a>00020 <span class="comment">IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, </span>
<a name="l00021"></a>00021 <span class="comment">DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, </span>
<a name="l00022"></a>00022 <span class="comment">ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR </span>
<a name="l00023"></a>00023 <span class="comment">OTHER DEALINGS IN THE SOFTWARE.</span>
<a name="l00024"></a>00024 <span class="comment"></span>
<a name="l00025"></a>00025 <span class="comment">For more information please visit:  http://bmagic.sourceforge.net</span>
<a name="l00026"></a>00026 <span class="comment"></span>
<a name="l00027"></a>00027 <span class="comment">*/</span>
<a name="l00028"></a>00028 
<a name="l00029"></a>00029 <span class="preprocessor">#include &lt;memory.h&gt;</span>
<a name="l00030"></a>00030 
<a name="l00031"></a>00031 <span class="preprocessor">#include &quot;<a class="code" href="a00092.html">bmdef.h</a>&quot;</span>
<a name="l00032"></a>00032 <span class="preprocessor">#include &quot;<a class="code" href="a00102.html">bmutil.h</a>&quot;</span>
<a name="l00033"></a>00033 
<a name="l00034"></a>00034 
<a name="l00035"></a>00035 <span class="preprocessor">#ifdef _MSC_VER</span>
<a name="l00036"></a>00036 <span class="preprocessor"></span><span class="preprocessor"># pragma warning( disable: 4146 )</span>
<a name="l00037"></a>00037 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00038"></a>00038 <span class="preprocessor"></span>
<a name="l00039"></a>00039 <span class="keyword">namespace </span>bm
<a name="l00040"></a>00040 {
<a name="l00041"></a>00041 
<a name="l00042"></a>00042 <span class="comment"></span>
<a name="l00043"></a>00043 <span class="comment">/*!</span>
<a name="l00044"></a>00044 <span class="comment">    @brief Structure with statistical information about bitset&apos;s memory </span>
<a name="l00045"></a>00045 <span class="comment">            allocation details. </span>
<a name="l00046"></a>00046 <span class="comment">    @ingroup bvector</span>
<a name="l00047"></a>00047 <span class="comment">*/</span>
<a name="l00048"></a><a class="code" href="a00042.html">00048</a> <span class="keyword">struct </span><a class="code" href="a00042.html" title="Structure with statistical information about bitset&amp;#39;s memory allocation details...">bv_statistics</a>
<a name="l00049"></a>00049 {<span class="comment"></span>
<a name="l00050"></a>00050 <span class="comment">    /// Number of bit blocks.</span>
<a name="l00051"></a><a class="code" href="a00042.html#a4ec8ba190b4ba31c431c008402881c62">00051</a> <span class="comment"></span>    <span class="keywordtype">unsigned</span> <a class="code" href="a00042.html#a4ec8ba190b4ba31c431c008402881c62" title="Number of bit blocks.">bit_blocks</a>; <span class="comment"></span>
<a name="l00052"></a>00052 <span class="comment">    /// Number of GAP blocks.</span>
<a name="l00053"></a><a class="code" href="a00042.html#a4dcfd64e9ab0be5472e3c2b04e551f81">00053</a> <span class="comment"></span>    <span class="keywordtype">unsigned</span> <a class="code" href="a00042.html#a4dcfd64e9ab0be5472e3c2b04e551f81" title="Number of GAP blocks.">gap_blocks</a>;  <span class="comment"></span>
<a name="l00054"></a>00054 <span class="comment">    /// Estimated maximum of memory required for serialization.</span>
<a name="l00055"></a><a class="code" href="a00042.html#a92f800e8649a1455c17019c8ec882b4b">00055</a> <span class="comment"></span>    <span class="keywordtype">unsigned</span> <a class="code" href="a00042.html#a92f800e8649a1455c17019c8ec882b4b" title="Estimated maximum of memory required for serialization.">max_serialize_mem</a>;<span class="comment"></span>
<a name="l00056"></a>00056 <span class="comment">    /// Memory used by bitvector including temp and service blocks</span>
<a name="l00057"></a><a class="code" href="a00042.html#ad3b2190eb4afe24ecd56323cbc0a7666">00057</a> <span class="comment"></span>    <span class="keywordtype">unsigned</span>  <a class="code" href="a00042.html#ad3b2190eb4afe24ecd56323cbc0a7666" title="Memory used by bitvector including temp and service blocks.">memory_used</a>;<span class="comment"></span>
<a name="l00058"></a>00058 <span class="comment">    /// Array of all GAP block lengths in the bvector.</span>
<a name="l00059"></a><a class="code" href="a00042.html#a824dd18d515305d159c48a697696cbb6">00059</a> <span class="comment"></span>    <a class="code" href="a00115.html#ac654d6319039a86546d235a236fc7cf6">gap_word_t</a>   <a class="code" href="a00042.html#a824dd18d515305d159c48a697696cbb6" title="Array of all GAP block lengths in the bvector.">gap_length</a>[<a class="code" href="a00115.html#a505011007f54598794e0b9477c0b0b11">bm::set_total_blocks</a>];<span class="comment"></span>
<a name="l00060"></a>00060 <span class="comment">    /// GAP lengths used by bvector</span>
<a name="l00061"></a><a class="code" href="a00042.html#acc08d9637cc25d02d3a50c061ba221e1">00061</a> <span class="comment"></span>    <a class="code" href="a00115.html#ac654d6319039a86546d235a236fc7cf6">gap_word_t</a>  <a class="code" href="a00042.html#acc08d9637cc25d02d3a50c061ba221e1" title="GAP lengths used by bvector.">gap_levels</a>[<a class="code" href="a00115.html#a773e9f5341919d58000bd54d50038733">bm::gap_levels</a>];
<a name="l00062"></a>00062 
<a name="l00063"></a>00063 
<a name="l00064"></a>00064 <span class="comment"></span>
<a name="l00065"></a>00065 <span class="comment">    /// cound bit block</span>
<a name="l00066"></a><a class="code" href="a00042.html#a78e63355a6d8985da253ebaa594223ff">00066</a> <span class="comment"></span>    <span class="keywordtype">void</span> <a class="code" href="a00042.html#a78e63355a6d8985da253ebaa594223ff" title="cound bit block">add_bit_block</a>()
<a name="l00067"></a>00067     {
<a name="l00068"></a>00068         ++<a class="code" href="a00042.html#a4ec8ba190b4ba31c431c008402881c62" title="Number of bit blocks.">bit_blocks</a>;
<a name="l00069"></a>00069         <span class="keywordtype">unsigned</span> mem_used = <span class="keyword">sizeof</span>(<a class="code" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a>) * <a class="code" href="a00115.html#a91319dbc0d0e1bf3a3efc4d92bac7972">bm::set_block_size</a>;
<a name="l00070"></a>00070         <a class="code" href="a00042.html#ad3b2190eb4afe24ecd56323cbc0a7666" title="Memory used by bitvector including temp and service blocks.">memory_used</a> += mem_used;
<a name="l00071"></a>00071         <a class="code" href="a00042.html#a92f800e8649a1455c17019c8ec882b4b" title="Estimated maximum of memory required for serialization.">max_serialize_mem</a> += mem_used;
<a name="l00072"></a>00072     }
<a name="l00073"></a>00073 <span class="comment"></span>
<a name="l00074"></a>00074 <span class="comment">    /// count gap block</span>
<a name="l00075"></a><a class="code" href="a00042.html#a1bb9ac89eb4e09368373737d1da1a978">00075</a> <span class="comment"></span>    <span class="keywordtype">void</span> <a class="code" href="a00042.html#a1bb9ac89eb4e09368373737d1da1a978" title="count gap block">add_gap_block</a>(<span class="keywordtype">unsigned</span> capacity, <span class="keywordtype">unsigned</span> length)
<a name="l00076"></a>00076     {
<a name="l00077"></a>00077         ++<a class="code" href="a00042.html#a4dcfd64e9ab0be5472e3c2b04e551f81" title="Number of GAP blocks.">gap_blocks</a>;
<a name="l00078"></a>00078         <span class="keywordtype">unsigned</span> mem_used = capacity * <span class="keyword">sizeof</span>(<a class="code" href="a00115.html#ac654d6319039a86546d235a236fc7cf6">gap_word_t</a>);
<a name="l00079"></a>00079         <a class="code" href="a00042.html#ad3b2190eb4afe24ecd56323cbc0a7666" title="Memory used by bitvector including temp and service blocks.">memory_used</a> += mem_used;
<a name="l00080"></a>00080         <a class="code" href="a00042.html#a92f800e8649a1455c17019c8ec882b4b" title="Estimated maximum of memory required for serialization.">max_serialize_mem</a> += length * <span class="keyword">sizeof</span>(<a class="code" href="a00115.html#ac654d6319039a86546d235a236fc7cf6">gap_word_t</a>);
<a name="l00081"></a>00081     }
<a name="l00082"></a>00082 };
<a name="l00083"></a>00083 
<a name="l00084"></a>00084 <span class="comment"></span>
<a name="l00085"></a>00085 <span class="comment">/*! @defgroup gapfunc GAP functions</span>
<a name="l00086"></a>00086 <span class="comment"> *  GAP functions implement different opereations on GAP compressed blocks</span>
<a name="l00087"></a>00087 <span class="comment"> *  and serve as a minimal building blocks.</span>
<a name="l00088"></a>00088 <span class="comment"> *  @ingroup bmagic</span>
<a name="l00089"></a>00089 <span class="comment"> *</span>
<a name="l00090"></a>00090 <span class="comment"> */</span>
<a name="l00091"></a>00091 <span class="comment"></span>
<a name="l00092"></a>00092 <span class="comment">/*! @defgroup bitfunc BIT functions</span>
<a name="l00093"></a>00093 <span class="comment"> *  Bit functions implement different opereations on bit blocks</span>
<a name="l00094"></a>00094 <span class="comment"> *  and serve as a minimal building blocks.</span>
<a name="l00095"></a>00095 <span class="comment"> *  @ingroup bmagic</span>
<a name="l00096"></a>00096 <span class="comment"> */</span>
<a name="l00097"></a>00097 
<a name="l00098"></a>00098 <span class="comment"></span>
<a name="l00099"></a>00099 <span class="comment">/*! @brief Default GAP lengths table.</span>
<a name="l00100"></a>00100 <span class="comment">    @ingroup gapfunc</span>
<a name="l00101"></a>00101 <span class="comment">*/</span>
<a name="l00102"></a><a class="code" href="a00066.html">00102</a> <span class="keyword">template</span>&lt;<span class="keywordtype">bool</span> T&gt; <span class="keyword">struct </span><a class="code" href="a00066.html" title="Default GAP lengths table.">gap_len_table</a>
<a name="l00103"></a>00103 {
<a name="l00104"></a><a class="code" href="a00066.html#af9260645490e8cac0769ba84847d4512">00104</a>     <span class="keyword">static</span> <span class="keyword">const</span> <a class="code" href="a00115.html#ac654d6319039a86546d235a236fc7cf6">gap_word_t</a> <a class="code" href="a00066.html#af9260645490e8cac0769ba84847d4512">_len</a>[<a class="code" href="a00115.html#a773e9f5341919d58000bd54d50038733">bm::gap_levels</a>];
<a name="l00105"></a>00105 };
<a name="l00106"></a>00106 
<a name="l00107"></a>00107 <span class="keyword">template</span>&lt;<span class="keywordtype">bool</span> T&gt;
<a name="l00108"></a>00108 <span class="keyword">const</span> <a class="code" href="a00115.html#ac654d6319039a86546d235a236fc7cf6">gap_word_t</a> <a class="code" href="a00066.html" title="Default GAP lengths table.">gap_len_table&lt;T&gt;::_len</a>[<a class="code" href="a00115.html#a773e9f5341919d58000bd54d50038733">bm::gap_levels</a>] = 
<a name="l00109"></a>00109                 { 128, 256, 512, <a class="code" href="a00115.html#aa5e01dfb650d168f9be0525e042af647">bm::gap_max_buff_len</a> }; 
<a name="l00110"></a>00110 
<a name="l00111"></a>00111 <span class="comment"></span>
<a name="l00112"></a>00112 <span class="comment">/*! @brief Alternative GAP lengths table. </span>
<a name="l00113"></a>00113 <span class="comment">    Good for for memory saver mode and very sparse bitsets.</span>
<a name="l00114"></a>00114 <span class="comment"></span>
<a name="l00115"></a>00115 <span class="comment">    @ingroup gapfunc</span>
<a name="l00116"></a>00116 <span class="comment">*/</span>
<a name="l00117"></a><a class="code" href="a00067.html">00117</a> <span class="keyword">template</span>&lt;<span class="keywordtype">bool</span> T&gt; <span class="keyword">struct </span><a class="code" href="a00067.html" title="Alternative GAP lengths table. Good for for memory saver mode and very sparse bitsets...">gap_len_table_min</a>
<a name="l00118"></a>00118 {
<a name="l00119"></a><a class="code" href="a00067.html#a7049262dea6250b11522da8e8359eefc">00119</a>     <span class="keyword">static</span> <span class="keyword">const</span> <a class="code" href="a00115.html#ac654d6319039a86546d235a236fc7cf6">gap_word_t</a> <a class="code" href="a00067.html#a7049262dea6250b11522da8e8359eefc">_len</a>[<a class="code" href="a00115.html#a773e9f5341919d58000bd54d50038733">bm::gap_levels</a>];
<a name="l00120"></a>00120 };
<a name="l00121"></a>00121 
<a name="l00122"></a>00122 <span class="keyword">template</span>&lt;<span class="keywordtype">bool</span> T&gt;
<a name="l00123"></a>00123 <span class="keyword">const</span> <a class="code" href="a00115.html#ac654d6319039a86546d235a236fc7cf6">gap_word_t</a> <a class="code" href="a00067.html" title="Alternative GAP lengths table. Good for for memory saver mode and very sparse bitsets...">gap_len_table_min&lt;T&gt;::_len</a>[<a class="code" href="a00115.html#a773e9f5341919d58000bd54d50038733">bm::gap_levels</a>] = 
<a name="l00124"></a>00124                                 { 32, 96, 128, 512 }; 
<a name="l00125"></a>00125 
<a name="l00126"></a>00126 
<a name="l00127"></a>00127 
<a name="l00128"></a>00128 <span class="comment">//---------------------------------------------------------------------</span>
<a name="l00129"></a>00129 <span class="comment"></span>
<a name="l00130"></a>00130 <span class="comment">/** Structure keeps all-left/right ON bits masks. </span>
<a name="l00131"></a>00131 <span class="comment">    @ingroup bitfunc </span>
<a name="l00132"></a>00132 <span class="comment">*/</span>
<a name="l00133"></a><a class="code" href="a00040.html">00133</a> <span class="keyword">template</span>&lt;<span class="keywordtype">bool</span> T&gt; <span class="keyword">struct </span><a class="code" href="a00040.html" title="Structure keeps all-left/right ON bits masks.">block_set_table</a>
<a name="l00134"></a>00134 {
<a name="l00135"></a><a class="code" href="a00040.html#a1232d75261b0e191a7c1716bcb6b9986">00135</a>     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <a class="code" href="a00040.html#a1232d75261b0e191a7c1716bcb6b9986">_left</a>[32];
<a name="l00136"></a><a class="code" href="a00040.html#ab572931e24924b8632189403d6078b52">00136</a>     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <a class="code" href="a00040.html#ab572931e24924b8632189403d6078b52">_right</a>[32];
<a name="l00137"></a>00137 };
<a name="l00138"></a>00138 
<a name="l00139"></a>00139 <span class="keyword">template</span>&lt;<span class="keywordtype">bool</span> T&gt;
<a name="l00140"></a>00140 <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <a class="code" href="a00040.html" title="Structure keeps all-left/right ON bits masks.">block_set_table&lt;T&gt;::_left</a>[32] = {
<a name="l00141"></a>00141     0x1, 0x3, 0x7, 0xf, 0x1f, 0x3f, 0x7f, 0xff, 0x1ff, 0x3ff, 0x7ff,
<a name="l00142"></a>00142     0xfff, 0x1fff, 0x3fff, 0x7fff, 0xffff, 0x1ffff, 0x3ffff, 0x7ffff,
<a name="l00143"></a>00143     0xfffff, 0x1fffff, 0x3fffff, 0x7fffff, 0xffffff, 0x1ffffff, 0x3ffffff,
<a name="l00144"></a>00144     0x7ffffff, 0xfffffff, 0x1fffffff, 0x3fffffff, 0x7fffffff, 0xffffffff
<a name="l00145"></a>00145 };
<a name="l00146"></a>00146 
<a name="l00147"></a>00147 <span class="keyword">template</span>&lt;<span class="keywordtype">bool</span> T&gt;
<a name="l00148"></a>00148 <span class="keyword">const</span> <span class="keywordtype">unsigned</span> block_set_table&lt;T&gt;::_right[32] = {
<a name="l00149"></a>00149     0xffffffff, 0xfffffffe, 0xfffffffc, 0xfffffff8, 0xfffffff0,
<a name="l00150"></a>00150     0xffffffe0, 0xffffffc0, 0xffffff80, 0xffffff00, 0xfffffe00,
<a name="l00151"></a>00151     0xfffffc00, 0xfffff800, 0xfffff000, 0xffffe000, 0xffffc000,
<a name="l00152"></a>00152     0xffff8000, 0xffff0000, 0xfffe0000, 0xfffc0000, 0xfff80000,
<a name="l00153"></a>00153     0xfff00000, 0xffe00000, 0xffc00000, 0xff800000, 0xff000000,
<a name="l00154"></a>00154     0xfe000000, 0xfc000000, 0xf8000000, 0xf0000000, 0xe0000000,
<a name="l00155"></a>00155     0xc0000000, 0x80000000
<a name="l00156"></a>00156 };
<a name="l00157"></a>00157 
<a name="l00158"></a>00158 
<a name="l00159"></a>00159 <span class="comment"></span>
<a name="l00160"></a>00160 <span class="comment">/*!</span>
<a name="l00161"></a>00161 <span class="comment">    Returns bit count</span>
<a name="l00162"></a>00162 <span class="comment">    @ingroup bitfunc </span>
<a name="l00163"></a>00163 <span class="comment">*/</span>
<a name="l00164"></a>00164 <a class="code" href="a00092.html#a938734d014fb68dd8b2251fe8ec2b025">BMFORCEINLINE</a>
<a name="l00165"></a><a class="code" href="a00120.html#gaef40342b0c318391df3db2b891acf7c1">00165</a> <a class="code" href="a00115.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a> <a class="code" href="a00120.html#gaef40342b0c318391df3db2b891acf7c1">word_bitcount</a>(<a class="code" href="a00115.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a> w)
<a name="l00166"></a>00166 {
<a name="l00167"></a>00167 <span class="preprocessor">#ifdef BMSSE4OPT</span>
<a name="l00168"></a>00168 <span class="preprocessor"></span>    <span class="keywordflow">return</span> _mm_popcnt_u32(w);
<a name="l00169"></a>00169 <span class="preprocessor">#else</span>
<a name="l00170"></a>00170 <span class="preprocessor"></span>    <span class="keywordflow">return</span>
<a name="l00171"></a>00171     <a class="code" href="a00022.html" title="Structure to aid in counting bits table contains count of bits in 0-255 diapason...">bm::bit_count_table&lt;true&gt;::_count</a>[(<span class="keywordtype">unsigned</span> char)(w)] + 
<a name="l00172"></a>00172     <a class="code" href="a00022.html" title="Structure to aid in counting bits table contains count of bits in 0-255 diapason...">bm::bit_count_table&lt;true&gt;::_count</a>[(<span class="keywordtype">unsigned</span> char)((w) &gt;&gt; 8)] + 
<a name="l00173"></a>00173     <a class="code" href="a00022.html" title="Structure to aid in counting bits table contains count of bits in 0-255 diapason...">bm::bit_count_table&lt;true&gt;::_count</a>[(<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>)((w) &gt;&gt; 16)] + 
<a name="l00174"></a>00174     <a class="code" href="a00022.html" title="Structure to aid in counting bits table contains count of bits in 0-255 diapason...">bm::bit_count_table&lt;true&gt;::_count</a>[(<span class="keywordtype">unsigned</span> char)((w) &gt;&gt; 24)];
<a name="l00175"></a>00175 <span class="preprocessor">#endif</span>
<a name="l00176"></a>00176 <span class="preprocessor"></span>}
<a name="l00177"></a>00177 
<a name="l00178"></a>00178 <span class="keyword">inline</span>
<a name="l00179"></a><a class="code" href="a00115.html#a30cec2c137813460f4b4c65c5879a4c3">00179</a> <span class="keywordtype">int</span> <a class="code" href="a00115.html#a30cec2c137813460f4b4c65c5879a4c3">parallel_popcnt_32</a>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n) 
<a name="l00180"></a>00180 {
<a name="l00181"></a>00181    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> tmp;
<a name="l00182"></a>00182 
<a name="l00183"></a>00183    tmp = n - ((n &gt;&gt; 1) &amp; 033333333333)
<a name="l00184"></a>00184            - ((n &gt;&gt; 2) &amp; 011111111111);
<a name="l00185"></a>00185    <span class="keywordflow">return</span> ((tmp + (tmp &gt;&gt; 3)) &amp; 030707070707) % 63;
<a name="l00186"></a>00186 }
<a name="l00187"></a>00187 
<a name="l00188"></a>00188 <span class="preprocessor">#ifdef BM64OPT</span>
<a name="l00189"></a>00189 <span class="preprocessor"></span><span class="comment">/*! </span>
<a name="l00190"></a>00190 <span class="comment">    Function calculates number of 1 bits in 64-bit word.</span>
<a name="l00191"></a>00191 <span class="comment">    @ingroup bitfunc </span>
<a name="l00192"></a>00192 <span class="comment">*/</span>
<a name="l00193"></a>00193 
<a name="l00194"></a>00194 <span class="keyword">inline</span> 
<a name="l00195"></a>00195 <span class="keywordtype">int</span> word_bitcount64(<a class="code" href="a00115.html#a1f6a6dd108cd9e9f4fb284043ef518fe">bm::id64_t</a> x)
<a name="l00196"></a>00196 {
<a name="l00197"></a>00197     x = x - ((x &gt;&gt; 1) &amp; 0x5555555555555555);
<a name="l00198"></a>00198     x = (x &amp; 0x3333333333333333) + ((x &gt;&gt; 2) &amp; 0x3333333333333333);
<a name="l00199"></a>00199     x = (x + (x &gt;&gt; 4)) &amp; 0x0F0F0F0F0F0F0F0F;
<a name="l00200"></a>00200     x = x + (x &gt;&gt; 8);
<a name="l00201"></a>00201     x = x + (x &gt;&gt; 16);
<a name="l00202"></a>00202     x = x + (x &gt;&gt; 32); 
<a name="l00203"></a>00203     <span class="keywordflow">return</span> x &amp; 0xFF;
<a name="l00204"></a>00204 }
<a name="l00205"></a>00205 
<a name="l00206"></a>00206 <span class="keyword">inline</span> 
<a name="l00207"></a>00207 <span class="keywordtype">unsigned</span> bitcount64_4way(<a class="code" href="a00115.html#a1f6a6dd108cd9e9f4fb284043ef518fe">bm::id64_t</a> x, <a class="code" href="a00115.html#a1f6a6dd108cd9e9f4fb284043ef518fe">bm::id64_t</a> y, 
<a name="l00208"></a>00208                     <a class="code" href="a00115.html#a1f6a6dd108cd9e9f4fb284043ef518fe">bm::id64_t</a> u, <a class="code" href="a00115.html#a1f6a6dd108cd9e9f4fb284043ef518fe">bm::id64_t</a> v)
<a name="l00209"></a>00209 {
<a name="l00210"></a>00210     <span class="keyword">const</span> <a class="code" href="a00115.html#a1f6a6dd108cd9e9f4fb284043ef518fe">bm::id64_t</a> m1 = 0x5555555555555555;
<a name="l00211"></a>00211     <span class="keyword">const</span> <a class="code" href="a00115.html#a1f6a6dd108cd9e9f4fb284043ef518fe">bm::id64_t</a> m2 = 0x3333333333333333; 
<a name="l00212"></a>00212     <span class="keyword">const</span> <a class="code" href="a00115.html#a1f6a6dd108cd9e9f4fb284043ef518fe">bm::id64_t</a> m3 = 0x0F0F0F0F0F0F0F0F; 
<a name="l00213"></a>00213     <span class="keyword">const</span> <a class="code" href="a00115.html#a1f6a6dd108cd9e9f4fb284043ef518fe">bm::id64_t</a> m4 = 0x000000FF000000FF;
<a name="l00214"></a>00214 
<a name="l00215"></a>00215     x = x - ((x &gt;&gt; 1) &amp; m1);
<a name="l00216"></a>00216     y = y - ((y &gt;&gt; 1) &amp; m1);
<a name="l00217"></a>00217     u = u - ((u &gt;&gt; 1) &amp; m1);
<a name="l00218"></a>00218     v = v - ((v &gt;&gt; 1) &amp; m1);
<a name="l00219"></a>00219     x = (x &amp; m2) + ((x &gt;&gt; 2) &amp; m2);
<a name="l00220"></a>00220     y = (y &amp; m2) + ((y &gt;&gt; 2) &amp; m2);
<a name="l00221"></a>00221     u = (u &amp; m2) + ((u &gt;&gt; 2) &amp; m2);
<a name="l00222"></a>00222     v = (v &amp; m2) + ((v &gt;&gt; 2) &amp; m2);
<a name="l00223"></a>00223     x = x + y; 
<a name="l00224"></a>00224     u = u + v; 
<a name="l00225"></a>00225     x = (x &amp; m3) + ((x &gt;&gt; 4) &amp; m3);
<a name="l00226"></a>00226     u = (u &amp; m3) + ((u &gt;&gt; 4) &amp; m3);
<a name="l00227"></a>00227     x = x + u; 
<a name="l00228"></a>00228     x = x + (x &gt;&gt; 8);
<a name="l00229"></a>00229     x = x + (x &gt;&gt; 16);
<a name="l00230"></a>00230     x = x &amp; m4; 
<a name="l00231"></a>00231     x = x + (x &gt;&gt; 32);
<a name="l00232"></a>00232     <span class="keywordflow">return</span> x &amp; 0x000001FF;
<a name="l00233"></a>00233 }
<a name="l00234"></a>00234 
<a name="l00235"></a>00235 
<a name="l00236"></a>00236 <span class="preprocessor">#endif</span>
<a name="l00237"></a>00237 <span class="preprocessor"></span>
<a name="l00238"></a>00238 
<a name="l00239"></a>00239 
<a name="l00240"></a>00240 <span class="comment">//---------------------------------------------------------------------</span>
<a name="l00241"></a>00241 <span class="comment"></span>
<a name="l00242"></a>00242 <span class="comment">/**</span>
<a name="l00243"></a>00243 <span class="comment">    Nomenclature of set operations</span>
<a name="l00244"></a>00244 <span class="comment">*/</span>
<a name="l00245"></a><a class="code" href="a00115.html#a76b70d2b9182a6dcac151d1bd9ec6109">00245</a> <span class="keyword">enum</span> <a class="code" href="a00115.html#a76b70d2b9182a6dcac151d1bd9ec6109" title="Nomenclature of set operations.">set_operation</a>
<a name="l00246"></a>00246 {
<a name="l00247"></a><a class="code" href="a00115.html#a76b70d2b9182a6dcac151d1bd9ec6109a949fba4d9b152e1cbba9a450e05e21a3">00247</a>     <a class="code" href="a00115.html#a76b70d2b9182a6dcac151d1bd9ec6109a949fba4d9b152e1cbba9a450e05e21a3">set_AND</a>         = 0,
<a name="l00248"></a><a class="code" href="a00115.html#a76b70d2b9182a6dcac151d1bd9ec6109a05d88a2639cbd3d2ac63436df3ed6780">00248</a>     <a class="code" href="a00115.html#a76b70d2b9182a6dcac151d1bd9ec6109a05d88a2639cbd3d2ac63436df3ed6780">set_OR</a>          = 1,
<a name="l00249"></a><a class="code" href="a00115.html#a76b70d2b9182a6dcac151d1bd9ec6109a348f23af148237ac49194815b222b769">00249</a>     <a class="code" href="a00115.html#a76b70d2b9182a6dcac151d1bd9ec6109a348f23af148237ac49194815b222b769">set_SUB</a>         = 2,
<a name="l00250"></a><a class="code" href="a00115.html#a76b70d2b9182a6dcac151d1bd9ec6109ab823123a0d630167532a96be004e6304">00250</a>     <a class="code" href="a00115.html#a76b70d2b9182a6dcac151d1bd9ec6109ab823123a0d630167532a96be004e6304">set_XOR</a>         = 3,
<a name="l00251"></a><a class="code" href="a00115.html#a76b70d2b9182a6dcac151d1bd9ec6109a34150dd6a8ac2e70b887565bd1c3f788">00251</a>     <a class="code" href="a00115.html#a76b70d2b9182a6dcac151d1bd9ec6109a34150dd6a8ac2e70b887565bd1c3f788">set_ASSIGN</a>      = 4,
<a name="l00252"></a><a class="code" href="a00115.html#a76b70d2b9182a6dcac151d1bd9ec6109a3f165b7944e33214e8721aaf2eb8378e">00252</a>     <a class="code" href="a00115.html#a76b70d2b9182a6dcac151d1bd9ec6109a3f165b7944e33214e8721aaf2eb8378e">set_COUNT</a>       = 5,
<a name="l00253"></a><a class="code" href="a00115.html#a76b70d2b9182a6dcac151d1bd9ec6109a378be4b14cee6a341e859fd3157ab959">00253</a>     <a class="code" href="a00115.html#a76b70d2b9182a6dcac151d1bd9ec6109a378be4b14cee6a341e859fd3157ab959">set_COUNT_AND</a>   = 6,
<a name="l00254"></a><a class="code" href="a00115.html#a76b70d2b9182a6dcac151d1bd9ec6109a1373054e4f243dffb762a55b8a8bfe4c">00254</a>     <a class="code" href="a00115.html#a76b70d2b9182a6dcac151d1bd9ec6109a1373054e4f243dffb762a55b8a8bfe4c">set_COUNT_XOR</a>   = 7,
<a name="l00255"></a><a class="code" href="a00115.html#a76b70d2b9182a6dcac151d1bd9ec6109a27e34c148d06e3d8a405482d820cd7fb">00255</a>     <a class="code" href="a00115.html#a76b70d2b9182a6dcac151d1bd9ec6109a27e34c148d06e3d8a405482d820cd7fb">set_COUNT_OR</a>    = 8,
<a name="l00256"></a><a class="code" href="a00115.html#a76b70d2b9182a6dcac151d1bd9ec6109a0028cc7084b37fe66ce5ae459b93b7f1">00256</a>     <a class="code" href="a00115.html#a76b70d2b9182a6dcac151d1bd9ec6109a0028cc7084b37fe66ce5ae459b93b7f1">set_COUNT_SUB_AB</a>= 9,
<a name="l00257"></a><a class="code" href="a00115.html#a76b70d2b9182a6dcac151d1bd9ec6109a2f7b894c11c058598d02722a7eeef03b">00257</a>     <a class="code" href="a00115.html#a76b70d2b9182a6dcac151d1bd9ec6109a2f7b894c11c058598d02722a7eeef03b">set_COUNT_SUB_BA</a>= 10,
<a name="l00258"></a><a class="code" href="a00115.html#a76b70d2b9182a6dcac151d1bd9ec6109abafe8a971864164aeec7f43d1205ed29">00258</a>     <a class="code" href="a00115.html#a76b70d2b9182a6dcac151d1bd9ec6109abafe8a971864164aeec7f43d1205ed29">set_COUNT_A</a>     = 11,
<a name="l00259"></a><a class="code" href="a00115.html#a76b70d2b9182a6dcac151d1bd9ec6109a2ac4eb7f41d00f8387d5dd3ffb9d0617">00259</a>     <a class="code" href="a00115.html#a76b70d2b9182a6dcac151d1bd9ec6109a2ac4eb7f41d00f8387d5dd3ffb9d0617">set_COUNT_B</a>     = 12,
<a name="l00260"></a>00260 
<a name="l00261"></a><a class="code" href="a00115.html#a76b70d2b9182a6dcac151d1bd9ec6109ad894d257a23664720dbf4155153a1e5c">00261</a>     <a class="code" href="a00115.html#a76b70d2b9182a6dcac151d1bd9ec6109ad894d257a23664720dbf4155153a1e5c">set_END</a>
<a name="l00262"></a>00262 };
<a name="l00263"></a>00263 <span class="comment"></span>
<a name="l00264"></a>00264 <span class="comment">/// Returns true if set operation is constant (bitcount)</span>
<a name="l00265"></a>00265 <span class="comment"></span><span class="keyword">inline</span>
<a name="l00266"></a><a class="code" href="a00115.html#a3deb310cdf11bca948817f94adfec160">00266</a> <span class="keywordtype">bool</span> <a class="code" href="a00115.html#a3deb310cdf11bca948817f94adfec160" title="Returns true if set operation is constant (bitcount).">is_const_set_operation</a>(<a class="code" href="a00115.html#a76b70d2b9182a6dcac151d1bd9ec6109" title="Nomenclature of set operations.">set_operation</a> op)
<a name="l00267"></a>00267 {
<a name="l00268"></a>00268     <span class="keywordflow">return</span> (<span class="keywordtype">int</span>(op) &gt;= <span class="keywordtype">int</span>(<a class="code" href="a00115.html#a76b70d2b9182a6dcac151d1bd9ec6109a3f165b7944e33214e8721aaf2eb8378e">set_COUNT</a>));
<a name="l00269"></a>00269 }
<a name="l00270"></a>00270 <span class="comment"></span>
<a name="l00271"></a>00271 <span class="comment">/**</span>
<a name="l00272"></a>00272 <span class="comment">    Bit operations enumeration.</span>
<a name="l00273"></a>00273 <span class="comment">*/</span>
<a name="l00274"></a><a class="code" href="a00115.html#a42405343976ec931388381cea4092bf1">00274</a> <span class="keyword">enum</span> <a class="code" href="a00115.html#a42405343976ec931388381cea4092bf1" title="Bit operations enumeration.">operation</a>
<a name="l00275"></a>00275 {
<a name="l00276"></a><a class="code" href="a00115.html#a42405343976ec931388381cea4092bf1a546fdf33b301e5b9bee0591522ed9250">00276</a>     <a class="code" href="a00115.html#a42405343976ec931388381cea4092bf1a546fdf33b301e5b9bee0591522ed9250">BM_AND</a> = <a class="code" href="a00115.html#a76b70d2b9182a6dcac151d1bd9ec6109a949fba4d9b152e1cbba9a450e05e21a3">set_AND</a>,
<a name="l00277"></a><a class="code" href="a00115.html#a42405343976ec931388381cea4092bf1a0c8cf0197857d0bd73a63037e2f2c5c5">00277</a>     <a class="code" href="a00115.html#a42405343976ec931388381cea4092bf1a0c8cf0197857d0bd73a63037e2f2c5c5">BM_OR</a>  = <a class="code" href="a00115.html#a76b70d2b9182a6dcac151d1bd9ec6109a05d88a2639cbd3d2ac63436df3ed6780">set_OR</a>,
<a name="l00278"></a><a class="code" href="a00115.html#a42405343976ec931388381cea4092bf1a1df0f4de7126bb2f7ce69d7a005affb5">00278</a>     <a class="code" href="a00115.html#a42405343976ec931388381cea4092bf1a1df0f4de7126bb2f7ce69d7a005affb5">BM_SUB</a> = <a class="code" href="a00115.html#a76b70d2b9182a6dcac151d1bd9ec6109a348f23af148237ac49194815b222b769">set_SUB</a>,
<a name="l00279"></a><a class="code" href="a00115.html#a42405343976ec931388381cea4092bf1a45c2fe36efb72dc03f03a842d253f64c">00279</a>     <a class="code" href="a00115.html#a42405343976ec931388381cea4092bf1a45c2fe36efb72dc03f03a842d253f64c">BM_XOR</a> = <a class="code" href="a00115.html#a76b70d2b9182a6dcac151d1bd9ec6109ab823123a0d630167532a96be004e6304">set_XOR</a>
<a name="l00280"></a>00280 };
<a name="l00281"></a>00281 <span class="comment"></span>
<a name="l00282"></a>00282 <span class="comment">/**</span>
<a name="l00283"></a>00283 <span class="comment">    Convert set operation to operation</span>
<a name="l00284"></a>00284 <span class="comment">*/</span>
<a name="l00285"></a>00285 <span class="keyword">inline</span>
<a name="l00286"></a><a class="code" href="a00115.html#a7c192b64adb0590a09b5c2dad77c4b76">00286</a> <a class="code" href="a00115.html#a42405343976ec931388381cea4092bf1" title="Bit operations enumeration.">bm::operation</a> <a class="code" href="a00115.html#a7c192b64adb0590a09b5c2dad77c4b76" title="Convert set operation to operation.">setop2op</a>(<a class="code" href="a00115.html#a76b70d2b9182a6dcac151d1bd9ec6109" title="Nomenclature of set operations.">bm::set_operation</a> op)
<a name="l00287"></a>00287 {
<a name="l00288"></a>00288     <a class="code" href="a00092.html#aa44515fab0ace8928d1cb82009a95bf8">BM_ASSERT</a>(op == <a class="code" href="a00115.html#a76b70d2b9182a6dcac151d1bd9ec6109a949fba4d9b152e1cbba9a450e05e21a3">set_AND</a> || 
<a name="l00289"></a>00289               op == <a class="code" href="a00115.html#a76b70d2b9182a6dcac151d1bd9ec6109a05d88a2639cbd3d2ac63436df3ed6780">set_OR</a>  || 
<a name="l00290"></a>00290               op == <a class="code" href="a00115.html#a76b70d2b9182a6dcac151d1bd9ec6109a348f23af148237ac49194815b222b769">set_SUB</a> || 
<a name="l00291"></a>00291               op == <a class="code" href="a00115.html#a76b70d2b9182a6dcac151d1bd9ec6109ab823123a0d630167532a96be004e6304">set_XOR</a>);
<a name="l00292"></a>00292     <span class="keywordflow">return</span> (<a class="code" href="a00115.html#a42405343976ec931388381cea4092bf1" title="Bit operations enumeration.">bm::operation</a>) op;
<a name="l00293"></a>00293 }
<a name="l00294"></a>00294 
<a name="l00295"></a>00295 <span class="comment">//---------------------------------------------------------------------</span>
<a name="l00296"></a>00296 <span class="comment"></span>
<a name="l00297"></a>00297 <span class="comment">/** </span>
<a name="l00298"></a>00298 <span class="comment">    Structure carries pointer on bit block with all bits 1</span>
<a name="l00299"></a>00299 <span class="comment">    @ingroup bitfunc </span>
<a name="l00300"></a>00300 <span class="comment">*/</span>
<a name="l00301"></a><a class="code" href="a00011.html">00301</a> <span class="keyword">template</span>&lt;<span class="keywordtype">bool</span> T&gt; <span class="keyword">struct </span><a class="code" href="a00011.html" title="Structure carries pointer on bit block with all bits 1.">all_set</a>
<a name="l00302"></a>00302 {
<a name="l00303"></a><a class="code" href="a00012.html">00303</a>     <span class="keyword">struct </span>BM_ALIGN16 <a class="code" href="a00012.html">all_set_block</a>
<a name="l00304"></a>00304     {
<a name="l00305"></a><a class="code" href="a00012.html#a418d059a24369f2ec51621c96ac319ec">00305</a>         <a class="code" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> _p[<a class="code" href="a00115.html#a91319dbc0d0e1bf3a3efc4d92bac7972">bm::set_block_size</a>] <a class="code" href="a00092.html#a80f4b7d710fa287d77100d211738dd32">BM_ALIGN16ATTR</a>;
<a name="l00306"></a>00306 
<a name="l00307"></a><a class="code" href="a00012.html#ac6ded50eaae111db18cc2a8c3570d3ad">00307</a>         <a class="code" href="a00012.html">all_set_block</a>()
<a name="l00308"></a>00308         {
<a name="l00309"></a>00309             ::memset(_p, 0xFF, <span class="keyword">sizeof</span>(_p));
<a name="l00310"></a>00310         }
<a name="l00311"></a>00311     };
<a name="l00312"></a>00312 
<a name="l00313"></a><a class="code" href="a00011.html#a76b3fc3c84247ee6d0b8b0b062ece168">00313</a>     <span class="keyword">static</span> <a class="code" href="a00012.html">all_set_block</a>  <a class="code" href="a00011.html#a76b3fc3c84247ee6d0b8b0b062ece168">_block</a>;
<a name="l00314"></a>00314 };
<a name="l00315"></a>00315 
<a name="l00316"></a>00316 
<a name="l00317"></a>00317 <span class="keyword">template</span>&lt;<span class="keywordtype">bool</span> T&gt; <span class="keyword">typename</span> <a class="code" href="a00012.html">all_set&lt;T&gt;::all_set_block</a> <a class="code" href="a00011.html" title="Structure carries pointer on bit block with all bits 1.">all_set&lt;T&gt;::_block</a>;
<a name="l00318"></a>00318 <span class="comment"></span>
<a name="l00319"></a>00319 <span class="comment">/// XOR swap two scalar variables</span>
<a name="l00320"></a>00320 <span class="comment"></span><span class="keyword">template</span>&lt;<span class="keyword">typename</span> W&gt; 
<a name="l00321"></a><a class="code" href="a00115.html#afb2c1acc56270abb381741a709a2b17c">00321</a> <span class="keywordtype">void</span> <a class="code" href="a00115.html#afb2c1acc56270abb381741a709a2b17c" title="XOR swap two scalar variables.">xor_swap</a>(W&amp; x, W&amp; y) 
<a name="l00322"></a>00322 {
<a name="l00323"></a>00323     <a class="code" href="a00092.html#aa44515fab0ace8928d1cb82009a95bf8">BM_ASSERT</a>(&amp;x != &amp;y);
<a name="l00324"></a>00324     x ^= y;
<a name="l00325"></a>00325     y ^= x;
<a name="l00326"></a>00326     x ^= y;
<a name="l00327"></a>00327 }
<a name="l00328"></a>00328 
<a name="l00329"></a>00329 
<a name="l00330"></a>00330 <span class="comment">//---------------------------------------------------------------------</span>
<a name="l00331"></a>00331 <span class="comment"></span>
<a name="l00332"></a>00332 <span class="comment">/*! </span>
<a name="l00333"></a>00333 <span class="comment">   \brief Lexicographical comparison of two words as bit strings.</span>
<a name="l00334"></a>00334 <span class="comment">   Auxiliary implementation for testing and reference purposes.</span>
<a name="l00335"></a>00335 <span class="comment">   \param buf1 - First word.</span>
<a name="l00336"></a>00336 <span class="comment">   \param buf2 - Second word.</span>
<a name="l00337"></a>00337 <span class="comment">   \return  &lt;0 - less, =0 - equal,  &gt;0 - greater.</span>
<a name="l00338"></a>00338 <span class="comment"></span>
<a name="l00339"></a>00339 <span class="comment">   @ingroup bitfunc </span>
<a name="l00340"></a>00340 <span class="comment">*/</span>
<a name="l00341"></a><a class="code" href="a00120.html#gafee2e8361c2e90a67dbaf9c7559d50e4">00341</a> <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keywordtype">int</span> <a class="code" href="a00120.html#gafee2e8361c2e90a67dbaf9c7559d50e4" title="Lexicographical comparison of two words as bit strings. Auxiliary implementation...">wordcmp0</a>(T w1, T w2)
<a name="l00342"></a>00342 {
<a name="l00343"></a>00343     <span class="keywordflow">while</span> (w1 != w2)
<a name="l00344"></a>00344     {
<a name="l00345"></a>00345         <span class="keywordtype">int</span> res = (w1 &amp; 1) - (w2 &amp; 1);
<a name="l00346"></a>00346         <span class="keywordflow">if</span> (res != 0) <span class="keywordflow">return</span> res;
<a name="l00347"></a>00347         w1 &gt;&gt;= 1;
<a name="l00348"></a>00348         w2 &gt;&gt;= 1;
<a name="l00349"></a>00349     }
<a name="l00350"></a>00350     <span class="keywordflow">return</span> 0;
<a name="l00351"></a>00351 }
<a name="l00352"></a>00352 
<a name="l00353"></a>00353 <span class="comment"></span>
<a name="l00354"></a>00354 <span class="comment">/*! </span>
<a name="l00355"></a>00355 <span class="comment">   \brief Lexicographical comparison of two words as bit strings.</span>
<a name="l00356"></a>00356 <span class="comment">   Auxiliary implementation for testing and reference purposes.</span>
<a name="l00357"></a>00357 <span class="comment">   \param buf1 - First word.</span>
<a name="l00358"></a>00358 <span class="comment">   \param buf2 - Second word.</span>
<a name="l00359"></a>00359 <span class="comment">   \return  &lt;0 - less, =0 - equal,  &gt;0 - greater.</span>
<a name="l00360"></a>00360 <span class="comment"></span>
<a name="l00361"></a>00361 <span class="comment">   @ingroup bitfunc </span>
<a name="l00362"></a>00362 <span class="comment">*/</span>
<a name="l00363"></a>00363 <span class="comment">/*</span>
<a name="l00364"></a>00364 <span class="comment">template&lt;typename T&gt; int wordcmp(T w1, T w2)</span>
<a name="l00365"></a>00365 <span class="comment">{</span>
<a name="l00366"></a>00366 <span class="comment">    T diff = w1 ^ w2;</span>
<a name="l00367"></a>00367 <span class="comment">    return diff ? ((w1 &amp; diff &amp; (diff ^ (diff - 1)))? 1 : -1) : 0; </span>
<a name="l00368"></a>00368 <span class="comment">}</span>
<a name="l00369"></a>00369 <span class="comment">*/</span>
<a name="l00370"></a>00370 
<a name="l00371"></a><a class="code" href="a00120.html#ga5847533a73b7a5125fe5c2888ec827bd">00371</a> <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keywordtype">int</span> <a class="code" href="a00120.html#ga5847533a73b7a5125fe5c2888ec827bd" title="Lexicographical comparison of two words as bit strings. Auxiliary implementation...">wordcmp</a>(T a, T b)
<a name="l00372"></a>00372 {
<a name="l00373"></a>00373     T diff = a ^ b;
<a name="l00374"></a>00374     <span class="keywordflow">return</span> diff? ( (a &amp; diff &amp; -diff)? 1 : -1 ) : 0;
<a name="l00375"></a>00375 }
<a name="l00376"></a>00376 
<a name="l00377"></a>00377 
<a name="l00378"></a>00378 <span class="comment">// Low bit extraction</span>
<a name="l00379"></a>00379 <span class="comment">// x &amp; (x ^ (x-1))</span>
<a name="l00380"></a>00380 
<a name="l00381"></a>00381 <span class="comment"></span>
<a name="l00382"></a>00382 <span class="comment">/**</span>
<a name="l00383"></a>00383 <span class="comment">    Internal structure. Copyright information.</span>
<a name="l00384"></a>00384 <span class="comment">*/</span>
<a name="l00385"></a><a class="code" href="a00010.html">00385</a> <span class="keyword">template</span>&lt;<span class="keywordtype">bool</span> T&gt; <span class="keyword">struct </span><a class="code" href="a00010.html" title="Internal structure.">_copyright</a>
<a name="l00386"></a>00386 {
<a name="l00387"></a><a class="code" href="a00010.html#ae984547ed47f625743248a9f15654261">00387</a>     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span> <a class="code" href="a00010.html#ae984547ed47f625743248a9f15654261">_p</a>[];
<a name="l00388"></a>00388 };
<a name="l00389"></a>00389 
<a name="l00390"></a>00390 <span class="keyword">template</span>&lt;<span class="keywordtype">bool</span> T&gt; <span class="keyword">const</span> <span class="keywordtype">char</span> <a class="code" href="a00010.html" title="Internal structure.">_copyright&lt;T&gt;::_p</a>[] = 
<a name="l00391"></a>00391     <span class="stringliteral">&quot;BitMagic C++ Library. v.3.7.0 (c) 2002-2010 Anatoliy Kuznetsov.&quot;</span>;
<a name="l00392"></a>00392 
<a name="l00393"></a>00393 <span class="comment"></span>
<a name="l00394"></a>00394 <span class="comment">/*! </span>
<a name="l00395"></a>00395 <span class="comment">   \brief Byte orders recognized by the library.</span>
<a name="l00396"></a>00396 <span class="comment">*/</span>
<a name="l00397"></a><a class="code" href="a00115.html#a577905b348676c2bc556b51793350dbb">00397</a> <span class="keyword">enum</span> <a class="code" href="a00115.html#a577905b348676c2bc556b51793350dbb" title="Byte orders recognized by the library.">ByteOrder</a>
<a name="l00398"></a>00398 {
<a name="l00399"></a><a class="code" href="a00115.html#a577905b348676c2bc556b51793350dbbac959b97503c42581f3dd81fd3b93fff2">00399</a>     <a class="code" href="a00115.html#a577905b348676c2bc556b51793350dbbac959b97503c42581f3dd81fd3b93fff2">BigEndian</a>    = 0,
<a name="l00400"></a><a class="code" href="a00115.html#a577905b348676c2bc556b51793350dbba5ebe266b6d18ee74483c2bbf624e2cc2">00400</a>     <a class="code" href="a00115.html#a577905b348676c2bc556b51793350dbba5ebe266b6d18ee74483c2bbf624e2cc2">LittleEndian</a> = 1
<a name="l00401"></a>00401 };
<a name="l00402"></a>00402 
<a name="l00403"></a>00403 <span class="comment"></span>
<a name="l00404"></a>00404 <span class="comment">/**</span>
<a name="l00405"></a>00405 <span class="comment">    Internal structure. Different global settings.</span>
<a name="l00406"></a>00406 <span class="comment">*/</span>
<a name="l00407"></a><a class="code" href="a00069.html">00407</a> <span class="keyword">template</span>&lt;<span class="keywordtype">bool</span> T&gt; <span class="keyword">struct </span><a class="code" href="a00069.html" title="Internal structure.">globals</a>
<a name="l00408"></a>00408 {
<a name="l00409"></a><a class="code" href="a00041.html">00409</a>     <span class="keyword">struct </span><a class="code" href="a00041.html">bo</a>
<a name="l00410"></a>00410     {
<a name="l00411"></a><a class="code" href="a00041.html#a4504994d99344a3d0764398252c22b75">00411</a>         <a class="code" href="a00115.html#a577905b348676c2bc556b51793350dbb" title="Byte orders recognized by the library.">ByteOrder</a>  <a class="code" href="a00041.html#a4504994d99344a3d0764398252c22b75">_byte_order</a>;
<a name="l00412"></a>00412 
<a name="l00413"></a><a class="code" href="a00041.html#aa0baaeae4028ababdcc71cabd5432360">00413</a>         <a class="code" href="a00041.html#aa0baaeae4028ababdcc71cabd5432360">bo</a>()
<a name="l00414"></a>00414         {
<a name="l00415"></a>00415             <span class="keywordtype">unsigned</span> x;
<a name="l00416"></a>00416             <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *s = (<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *)&amp;x;
<a name="l00417"></a>00417             s[0] = 1;
<a name="l00418"></a>00418             s[1] = 2;
<a name="l00419"></a>00419             s[2] = 3;
<a name="l00420"></a>00420             s[3] = 4;
<a name="l00421"></a>00421 
<a name="l00422"></a>00422             <span class="keywordflow">if</span>(x == 0x04030201) 
<a name="l00423"></a>00423             {
<a name="l00424"></a>00424                 <a class="code" href="a00041.html#a4504994d99344a3d0764398252c22b75">_byte_order</a> = <a class="code" href="a00115.html#a577905b348676c2bc556b51793350dbba5ebe266b6d18ee74483c2bbf624e2cc2">LittleEndian</a>;
<a name="l00425"></a>00425                 <span class="keywordflow">return</span>;
<a name="l00426"></a>00426             }
<a name="l00427"></a>00427 
<a name="l00428"></a>00428             <span class="keywordflow">if</span>(x == 0x01020304) 
<a name="l00429"></a>00429             {
<a name="l00430"></a>00430                 <a class="code" href="a00041.html#a4504994d99344a3d0764398252c22b75">_byte_order</a> = <a class="code" href="a00115.html#a577905b348676c2bc556b51793350dbbac959b97503c42581f3dd81fd3b93fff2">BigEndian</a>;
<a name="l00431"></a>00431                 <span class="keywordflow">return</span>;
<a name="l00432"></a>00432             }
<a name="l00433"></a>00433 
<a name="l00434"></a>00434             <a class="code" href="a00092.html#aa44515fab0ace8928d1cb82009a95bf8">BM_ASSERT</a>(0); <span class="comment">// &quot;Invalid Byte Order\n&quot;</span>
<a name="l00435"></a>00435             <a class="code" href="a00041.html#a4504994d99344a3d0764398252c22b75">_byte_order</a> = <a class="code" href="a00115.html#a577905b348676c2bc556b51793350dbba5ebe266b6d18ee74483c2bbf624e2cc2">LittleEndian</a>;
<a name="l00436"></a>00436         }
<a name="l00437"></a>00437     };
<a name="l00438"></a>00438 
<a name="l00439"></a><a class="code" href="a00069.html#af40c2cad39a7b344ba7d62ff4594669d">00439</a>     <span class="keyword">static</span> <a class="code" href="a00041.html">bo</a>  <a class="code" href="a00069.html#af40c2cad39a7b344ba7d62ff4594669d">_bo</a>;
<a name="l00440"></a>00440 
<a name="l00441"></a><a class="code" href="a00069.html#a133786f6db9267b0760de9158bee0c36">00441</a>     <span class="keyword">static</span> <a class="code" href="a00115.html#a577905b348676c2bc556b51793350dbb" title="Byte orders recognized by the library.">ByteOrder</a> <a class="code" href="a00069.html#a133786f6db9267b0760de9158bee0c36">byte_order</a>() { <span class="keywordflow">return</span> <a class="code" href="a00069.html#af40c2cad39a7b344ba7d62ff4594669d">_bo</a>.<a class="code" href="a00041.html#a4504994d99344a3d0764398252c22b75">_byte_order</a>; }
<a name="l00442"></a>00442 
<a name="l00443"></a>00443 };
<a name="l00444"></a>00444 
<a name="l00445"></a>00445 <span class="keyword">template</span>&lt;<span class="keywordtype">bool</span> T&gt; <span class="keyword">typename</span> globals&lt;T&gt;::bo globals&lt;T&gt;::_bo;
<a name="l00446"></a>00446 
<a name="l00447"></a>00447 
<a name="l00448"></a>00448 
<a name="l00449"></a>00449 
<a name="l00450"></a>00450 
<a name="l00451"></a>00451 
<a name="l00452"></a>00452 <span class="comment">/*</span>
<a name="l00453"></a>00453 <span class="comment">   \brief Binary search for the block where bit = pos located.</span>
<a name="l00454"></a>00454 <span class="comment">   \param buf - GAP buffer pointer.</span>
<a name="l00455"></a>00455 <span class="comment">   \param pos - index of the element.</span>
<a name="l00456"></a>00456 <span class="comment">   \param is_set - output. GAP value (0 or 1). </span>
<a name="l00457"></a>00457 <span class="comment">   \return GAP index.</span>
<a name="l00458"></a>00458 <span class="comment">   @ingroup gapfunc</span>
<a name="l00459"></a>00459 <span class="comment">*/</span>
<a name="l00460"></a>00460 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; 
<a name="l00461"></a><a class="code" href="a00115.html#acebed8b533c2c9e17167617501477693">00461</a> <span class="keywordtype">unsigned</span> <a class="code" href="a00115.html#acebed8b533c2c9e17167617501477693">gap_bfind</a>(<span class="keyword">const</span> T* buf, <span class="keywordtype">unsigned</span> pos, <span class="keywordtype">unsigned</span>* is_set)
<a name="l00462"></a>00462 {
<a name="l00463"></a>00463     <a class="code" href="a00092.html#aa44515fab0ace8928d1cb82009a95bf8">BM_ASSERT</a>(pos &lt; <a class="code" href="a00115.html#ad0b8714080144ac70197840ff96752b7">bm::gap_max_bits</a>);
<a name="l00464"></a>00464     *is_set = (*buf) &amp; 1;
<a name="l00465"></a>00465 
<a name="l00466"></a>00466     <span class="keyword">register</span> <span class="keywordtype">unsigned</span> start = 1;
<a name="l00467"></a>00467     <span class="keyword">register</span> <span class="keywordtype">unsigned</span> end = 1 + ((*buf) &gt;&gt; 3);
<a name="l00468"></a>00468 
<a name="l00469"></a>00469     <span class="keywordflow">while</span> ( start != end )
<a name="l00470"></a>00470     {
<a name="l00471"></a>00471         <span class="keywordtype">unsigned</span> curr = (start + end) &gt;&gt; 1;
<a name="l00472"></a>00472         <span class="keywordflow">if</span> ( buf[curr] &lt; pos )
<a name="l00473"></a>00473             start = curr + 1;
<a name="l00474"></a>00474         <span class="keywordflow">else</span>
<a name="l00475"></a>00475             end = curr;
<a name="l00476"></a>00476     }
<a name="l00477"></a>00477     *is_set ^= ((start-1) &amp; 1);
<a name="l00478"></a>00478     <span class="keywordflow">return</span> start; 
<a name="l00479"></a>00479 }
<a name="l00480"></a>00480 
<a name="l00481"></a>00481 <span class="comment"></span>
<a name="l00482"></a>00482 <span class="comment">/*!</span>
<a name="l00483"></a>00483 <span class="comment">   \brief Tests if bit = pos is true.</span>
<a name="l00484"></a>00484 <span class="comment">   \param buf - GAP buffer pointer.</span>
<a name="l00485"></a>00485 <span class="comment">   \param pos - index of the element.</span>
<a name="l00486"></a>00486 <span class="comment">   \return true if position is in &quot;1&quot; gap</span>
<a name="l00487"></a>00487 <span class="comment">   @ingroup gapfunc</span>
<a name="l00488"></a>00488 <span class="comment">*/</span>
<a name="l00489"></a><a class="code" href="a00119.html#ga866352ef5986a7d2b709795d127b666b">00489</a> <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keywordtype">unsigned</span> <a class="code" href="a00119.html#ga866352ef5986a7d2b709795d127b666b" title="Tests if bit = pos is true.">gap_test</a>(<span class="keyword">const</span> T* buf, <span class="keywordtype">unsigned</span> pos)
<a name="l00490"></a>00490 {
<a name="l00491"></a>00491     <a class="code" href="a00092.html#aa44515fab0ace8928d1cb82009a95bf8">BM_ASSERT</a>(pos &lt; <a class="code" href="a00115.html#ad0b8714080144ac70197840ff96752b7">bm::gap_max_bits</a>);
<a name="l00492"></a>00492 
<a name="l00493"></a>00493     <span class="keywordtype">unsigned</span> start = 1;
<a name="l00494"></a>00494     <span class="keywordtype">unsigned</span> end = 1 + ((*buf) &gt;&gt; 3);
<a name="l00495"></a>00495 
<a name="l00496"></a>00496     <span class="keywordflow">if</span> (end - start &lt; 10)
<a name="l00497"></a>00497     {
<a name="l00498"></a>00498         <span class="keywordtype">unsigned</span> sv = *buf &amp; 1;
<a name="l00499"></a>00499         <span class="keywordtype">unsigned</span> sv1= sv ^ 1;
<a name="l00500"></a>00500         <span class="keywordflow">if</span> (buf[1] &gt;= pos) <span class="keywordflow">return</span> sv;
<a name="l00501"></a>00501         <span class="keywordflow">if</span> (buf[2] &gt;= pos) <span class="keywordflow">return</span> sv1;
<a name="l00502"></a>00502         <span class="keywordflow">if</span> (buf[3] &gt;= pos) <span class="keywordflow">return</span> sv;
<a name="l00503"></a>00503         <span class="keywordflow">if</span> (buf[4] &gt;= pos) <span class="keywordflow">return</span> sv1;
<a name="l00504"></a>00504         <span class="keywordflow">if</span> (buf[5] &gt;= pos) <span class="keywordflow">return</span> sv;
<a name="l00505"></a>00505         <span class="keywordflow">if</span> (buf[6] &gt;= pos) <span class="keywordflow">return</span> sv1;
<a name="l00506"></a>00506         <span class="keywordflow">if</span> (buf[7] &gt;= pos) <span class="keywordflow">return</span> sv;
<a name="l00507"></a>00507         <span class="keywordflow">if</span> (buf[8] &gt;= pos) <span class="keywordflow">return</span> sv1;
<a name="l00508"></a>00508         <span class="keywordflow">if</span> (buf[9] &gt;= pos) <span class="keywordflow">return</span> sv;
<a name="l00509"></a>00509         <a class="code" href="a00092.html#aa44515fab0ace8928d1cb82009a95bf8">BM_ASSERT</a>(0);
<a name="l00510"></a>00510     }
<a name="l00511"></a>00511     <span class="keywordflow">else</span>
<a name="l00512"></a>00512     <span class="keywordflow">while</span> ( start != end )
<a name="l00513"></a>00513     {
<a name="l00514"></a>00514         <span class="keywordtype">unsigned</span> curr = (start + end) &gt;&gt; 1;
<a name="l00515"></a>00515         <span class="keywordflow">if</span> ( buf[curr] &lt; pos )
<a name="l00516"></a>00516             start = curr + 1;
<a name="l00517"></a>00517         <span class="keywordflow">else</span>
<a name="l00518"></a>00518             end = curr;
<a name="l00519"></a>00519     }
<a name="l00520"></a>00520     <span class="keywordflow">return</span> ((*buf) &amp; 1) ^ ((--start) &amp; 1); 
<a name="l00521"></a>00521 }
<a name="l00522"></a>00522 
<a name="l00523"></a>00523 
<a name="l00524"></a>00524 <span class="comment"></span>
<a name="l00525"></a>00525 <span class="comment">/*! For each non-zero block executes supplied function.</span>
<a name="l00526"></a>00526 <span class="comment">*/</span>
<a name="l00527"></a>00527 <span class="keyword">template</span>&lt;<span class="keyword">class</span> T, <span class="keyword">class</span> F&gt; 
<a name="l00528"></a><a class="code" href="a00115.html#a46953a43cfc3da7192d883b6dd822d99">00528</a> <span class="keywordtype">void</span> <a class="code" href="a00115.html#a46953a43cfc3da7192d883b6dd822d99">for_each_nzblock</a>(T*** root, <span class="keywordtype">unsigned</span> size1, <span class="comment">//unsigned size2, </span>
<a name="l00529"></a>00529                       F&amp; f)
<a name="l00530"></a>00530 {
<a name="l00531"></a>00531     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i = 0; i &lt; size1; ++i)
<a name="l00532"></a>00532     {
<a name="l00533"></a>00533         T** blk_blk = root[i];
<a name="l00534"></a>00534         <span class="keywordflow">if</span> (!blk_blk) 
<a name="l00535"></a>00535         {
<a name="l00536"></a>00536             f.on_empty_top(i);
<a name="l00537"></a>00537             <span class="keywordflow">continue</span>;
<a name="l00538"></a>00538         }
<a name="l00539"></a>00539 
<a name="l00540"></a>00540         <span class="keywordtype">unsigned</span> non_empty_top = 0;
<a name="l00541"></a>00541         <span class="keywordtype">unsigned</span> r = i * <a class="code" href="a00115.html#a40ad34d6c46a2fb20ba2baa7f95d80b4">bm::set_array_size</a>;
<a name="l00542"></a>00542         <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> j = 0;j &lt; bm::set_array_size; ++j)
<a name="l00543"></a>00543         {
<a name="l00544"></a>00544             <span class="keywordflow">if</span> (blk_blk[j]) 
<a name="l00545"></a>00545             {
<a name="l00546"></a>00546                 f(blk_blk[j], r + j);
<a name="l00547"></a>00547                 non_empty_top += (blk_blk[j] != 0);<span class="comment">// re-check for mutation</span>
<a name="l00548"></a>00548             }
<a name="l00549"></a>00549             <span class="keywordflow">else</span>
<a name="l00550"></a>00550             {
<a name="l00551"></a>00551                 f.on_empty_block(r + j);
<a name="l00552"></a>00552             }
<a name="l00553"></a>00553         } <span class="comment">// for j</span>
<a name="l00554"></a>00554         <span class="keywordflow">if</span> (non_empty_top == 0)
<a name="l00555"></a>00555         {
<a name="l00556"></a>00556             f.on_empty_top(i);
<a name="l00557"></a>00557         }
<a name="l00558"></a>00558     }  <span class="comment">// for i</span>
<a name="l00559"></a>00559 }
<a name="l00560"></a>00560 <span class="comment"></span>
<a name="l00561"></a>00561 <span class="comment">/*! For each non-zero block executes supplied function.</span>
<a name="l00562"></a>00562 <span class="comment">*/</span>
<a name="l00563"></a>00563 <span class="keyword">template</span>&lt;<span class="keyword">class</span> T, <span class="keyword">class</span> F&gt; 
<a name="l00564"></a><a class="code" href="a00115.html#ac6f5529fcc26412fc796b85770aa3a26">00564</a> <span class="keywordtype">void</span> <a class="code" href="a00115.html#ac6f5529fcc26412fc796b85770aa3a26">for_each_nzblock2</a>(T*** root, <span class="keywordtype">unsigned</span> size1, F&amp; f)
<a name="l00565"></a>00565 {
<a name="l00566"></a>00566     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i = 0; i &lt; size1; ++i)
<a name="l00567"></a>00567     {
<a name="l00568"></a>00568         T** blk_blk;
<a name="l00569"></a>00569         <span class="keywordflow">if</span> ((blk_blk = root[i])!=0) 
<a name="l00570"></a>00570         {            
<a name="l00571"></a>00571             <span class="keywordtype">unsigned</span> j = 0;
<a name="l00572"></a>00572             <span class="keywordflow">do</span>
<a name="l00573"></a>00573             {                
<a name="l00574"></a>00574                 <span class="keywordflow">if</span> (blk_blk[j]) 
<a name="l00575"></a>00575                     f(blk_blk[j]);
<a name="l00576"></a>00576                 <span class="keywordflow">if</span> (blk_blk[j+1]) 
<a name="l00577"></a>00577                     f(blk_blk[j+1]);
<a name="l00578"></a>00578                 <span class="keywordflow">if</span> (blk_blk[j+2]) 
<a name="l00579"></a>00579                     f(blk_blk[j+2]);
<a name="l00580"></a>00580                 <span class="keywordflow">if</span> (blk_blk[j+3]) 
<a name="l00581"></a>00581                     f(blk_blk[j+3]);
<a name="l00582"></a>00582                 j += 4;
<a name="l00583"></a>00583             } <span class="keywordflow">while</span> (j &lt; <a class="code" href="a00115.html#a40ad34d6c46a2fb20ba2baa7f95d80b4">bm::set_array_size</a>);
<a name="l00584"></a>00584         }
<a name="l00585"></a>00585     }  <span class="comment">// for i</span>
<a name="l00586"></a>00586 }
<a name="l00587"></a>00587 
<a name="l00588"></a>00588 <span class="comment"></span>
<a name="l00589"></a>00589 <span class="comment">/*! For each non-zero block executes supplied function-predicate.</span>
<a name="l00590"></a>00590 <span class="comment">    Function returns if function-predicate returns true</span>
<a name="l00591"></a>00591 <span class="comment">*/</span>
<a name="l00592"></a>00592 <span class="keyword">template</span>&lt;<span class="keyword">class</span> T, <span class="keyword">class</span> F&gt; 
<a name="l00593"></a><a class="code" href="a00115.html#a5b4e99c8ed7b929be87bd5a1ad76fd37">00593</a> <span class="keywordtype">bool</span> <a class="code" href="a00115.html#a5b4e99c8ed7b929be87bd5a1ad76fd37">for_each_nzblock_if</a>(T*** root, <span class="keywordtype">unsigned</span> size1, F&amp; f)
<a name="l00594"></a>00594 {
<a name="l00595"></a>00595     <span class="keywordtype">unsigned</span> block_idx = 0;
<a name="l00596"></a>00596     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i = 0; i &lt; size1; ++i)
<a name="l00597"></a>00597     {
<a name="l00598"></a>00598         T** blk_blk = root[i];
<a name="l00599"></a>00599         <span class="keywordflow">if</span> (!blk_blk) 
<a name="l00600"></a>00600         {
<a name="l00601"></a>00601             block_idx += <a class="code" href="a00115.html#a40ad34d6c46a2fb20ba2baa7f95d80b4">bm::set_array_size</a>;
<a name="l00602"></a>00602             <span class="keywordflow">continue</span>;
<a name="l00603"></a>00603         }
<a name="l00604"></a>00604 
<a name="l00605"></a>00605         <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> j = 0;j &lt; <a class="code" href="a00115.html#a40ad34d6c46a2fb20ba2baa7f95d80b4">bm::set_array_size</a>; ++j, ++block_idx)
<a name="l00606"></a>00606         {
<a name="l00607"></a>00607             <span class="keywordflow">if</span> (blk_blk[j]) 
<a name="l00608"></a>00608                 <span class="keywordflow">if</span> (f(blk_blk[j], block_idx)) <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00609"></a>00609         }
<a name="l00610"></a>00610     }
<a name="l00611"></a>00611     <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00612"></a>00612 }
<a name="l00613"></a>00613 <span class="comment"></span>
<a name="l00614"></a>00614 <span class="comment">/*! For each block executes supplied function.</span>
<a name="l00615"></a>00615 <span class="comment">*/</span>
<a name="l00616"></a>00616 <span class="keyword">template</span>&lt;<span class="keyword">class</span> T, <span class="keyword">class</span> F&gt; 
<a name="l00617"></a><a class="code" href="a00115.html#a8abecc773e9aaee744215278d1e6924e">00617</a> <span class="keywordtype">void</span> <a class="code" href="a00115.html#a8abecc773e9aaee744215278d1e6924e">for_each_block</a>(T*** root, <span class="keywordtype">unsigned</span> size1, F&amp; f)
<a name="l00618"></a>00618 {
<a name="l00619"></a>00619     <span class="keywordtype">unsigned</span> block_idx = 0;
<a name="l00620"></a>00620 
<a name="l00621"></a>00621     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i = 0; i &lt; size1; ++i)
<a name="l00622"></a>00622     {
<a name="l00623"></a>00623         T** blk_blk = root[i];
<a name="l00624"></a>00624 
<a name="l00625"></a>00625         <span class="keywordflow">if</span> (blk_blk)
<a name="l00626"></a>00626         {
<a name="l00627"></a>00627             <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> j = 0;j &lt; <a class="code" href="a00115.html#a40ad34d6c46a2fb20ba2baa7f95d80b4">bm::set_array_size</a>; ++j, ++block_idx)
<a name="l00628"></a>00628             {
<a name="l00629"></a>00629                 f(blk_blk[j], block_idx);
<a name="l00630"></a>00630             }
<a name="l00631"></a>00631         }
<a name="l00632"></a>00632         <span class="keywordflow">else</span>
<a name="l00633"></a>00633         {
<a name="l00634"></a>00634             <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> j = 0;j &lt; <a class="code" href="a00115.html#a40ad34d6c46a2fb20ba2baa7f95d80b4">bm::set_array_size</a>; ++j, ++block_idx)
<a name="l00635"></a>00635             {
<a name="l00636"></a>00636                 f(0, block_idx);
<a name="l00637"></a>00637             }
<a name="l00638"></a>00638         }
<a name="l00639"></a>00639     }  
<a name="l00640"></a>00640 }
<a name="l00641"></a>00641 
<a name="l00642"></a>00642 
<a name="l00643"></a>00643 <span class="comment"></span>
<a name="l00644"></a>00644 <span class="comment">/*! Special BM optimized analog of STL for_each</span>
<a name="l00645"></a>00645 <span class="comment">*/</span>
<a name="l00646"></a><a class="code" href="a00115.html#abf587377ca70f11b8eb75f95494830b5">00646</a> <span class="keyword">template</span>&lt;<span class="keyword">class</span> T, <span class="keyword">class</span> F&gt; F <a class="code" href="a00115.html#abf587377ca70f11b8eb75f95494830b5">bmfor_each</a>(T first, T last, F f)
<a name="l00647"></a>00647 {
<a name="l00648"></a>00648     <span class="keywordflow">do</span>
<a name="l00649"></a>00649     {
<a name="l00650"></a>00650         f(*first);
<a name="l00651"></a>00651         ++first;
<a name="l00652"></a>00652     } <span class="keywordflow">while</span> (first &lt; last);
<a name="l00653"></a>00653     <span class="keywordflow">return</span> f;
<a name="l00654"></a>00654 }
<a name="l00655"></a>00655 <span class="comment"></span>
<a name="l00656"></a>00656 <span class="comment">/*! Computes SUM of all elements of the sequence</span>
<a name="l00657"></a>00657 <span class="comment">*/</span>
<a name="l00658"></a><a class="code" href="a00115.html#ac8f3443ba8fcd1b28face4b09dfd21bf">00658</a> <span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt; T <a class="code" href="a00115.html#ac8f3443ba8fcd1b28face4b09dfd21bf">sum_arr</a>(T* first, T* last)
<a name="l00659"></a>00659 {
<a name="l00660"></a>00660     T sum = 0;
<a name="l00661"></a>00661     <span class="keywordflow">while</span> (first &lt; last)
<a name="l00662"></a>00662     {
<a name="l00663"></a>00663         sum += *first;
<a name="l00664"></a>00664         ++first;
<a name="l00665"></a>00665     }
<a name="l00666"></a>00666     <span class="keywordflow">return</span> sum;
<a name="l00667"></a>00667 }
<a name="l00668"></a>00668 
<a name="l00669"></a>00669 
<a name="l00670"></a>00670 <span class="comment"></span>
<a name="l00671"></a>00671 <span class="comment">/*! </span>
<a name="l00672"></a>00672 <span class="comment">   \brief Calculates number of bits ON in GAP buffer.</span>
<a name="l00673"></a>00673 <span class="comment">   \param buf - GAP buffer pointer.</span>
<a name="l00674"></a>00674 <span class="comment">   \param dsize - buffer size</span>
<a name="l00675"></a>00675 <span class="comment">   \return Number of non-zero bits.</span>
<a name="l00676"></a>00676 <span class="comment">   @ingroup gapfunc</span>
<a name="l00677"></a>00677 <span class="comment">*/</span>
<a name="l00678"></a><a class="code" href="a00119.html#ga570a6f573ffb9ac9e41a688d2bdc6004">00678</a> <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keywordtype">unsigned</span> <a class="code" href="a00119.html#ga570a6f573ffb9ac9e41a688d2bdc6004" title="Calculates number of bits ON in GAP buffer.">gap_bit_count</a>(<span class="keyword">const</span> T* buf, <span class="keywordtype">unsigned</span> dsize=0) 
<a name="l00679"></a>00679 {
<a name="l00680"></a>00680     <span class="keyword">register</span> <span class="keyword">const</span> T* pcurr = buf;
<a name="l00681"></a>00681     <span class="keywordflow">if</span> (dsize == 0)
<a name="l00682"></a>00682         dsize = (*pcurr &gt;&gt; 3);
<a name="l00683"></a>00683 
<a name="l00684"></a>00684     <span class="keyword">register</span> <span class="keyword">const</span> T* pend = pcurr + dsize;
<a name="l00685"></a>00685 
<a name="l00686"></a>00686     <span class="keyword">register</span> <span class="keywordtype">unsigned</span> bits_counter = 0;
<a name="l00687"></a>00687     ++pcurr;
<a name="l00688"></a>00688 
<a name="l00689"></a>00689     <span class="keywordflow">if</span> (*buf &amp; 1)
<a name="l00690"></a>00690     {
<a name="l00691"></a>00691         bits_counter += *pcurr + 1;
<a name="l00692"></a>00692         ++pcurr;
<a name="l00693"></a>00693     }
<a name="l00694"></a>00694     ++pcurr;  <span class="comment">// set GAP to 1</span>
<a name="l00695"></a>00695 
<a name="l00696"></a>00696     <span class="keywordflow">while</span> (pcurr &lt;= pend)
<a name="l00697"></a>00697     {
<a name="l00698"></a>00698         bits_counter += *pcurr - *(pcurr-1);
<a name="l00699"></a>00699         pcurr += 2; <span class="comment">// jump to the next positive GAP</span>
<a name="l00700"></a>00700     } 
<a name="l00701"></a>00701 
<a name="l00702"></a>00702     <span class="keywordflow">return</span> bits_counter;
<a name="l00703"></a>00703 }
<a name="l00704"></a>00704 
<a name="l00705"></a>00705 <span class="comment"></span>
<a name="l00706"></a>00706 <span class="comment">/*!</span>
<a name="l00707"></a>00707 <span class="comment">   \brief Counts 1 bits in GAP buffer in the closed [left, right] diapason.</span>
<a name="l00708"></a>00708 <span class="comment">   \param buf - GAP buffer pointer.</span>
<a name="l00709"></a>00709 <span class="comment">   \param left - leftmost bit index to start from</span>
<a name="l00710"></a>00710 <span class="comment">   \param right- rightmost bit index</span>
<a name="l00711"></a>00711 <span class="comment">   \return Number of non-zero bits.</span>
<a name="l00712"></a>00712 <span class="comment">*/</span>
<a name="l00713"></a>00713 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;
<a name="l00714"></a><a class="code" href="a00115.html#a7324ebded429e15361f62117a2ff18d1">00714</a> <span class="keywordtype">unsigned</span> <a class="code" href="a00115.html#a7324ebded429e15361f62117a2ff18d1" title="Counts 1 bits in GAP buffer in the closed [left, right] diapason.">gap_bit_count_range</a>(<span class="keyword">const</span> T* buf, T left, T right)
<a name="l00715"></a>00715 {
<a name="l00716"></a>00716     <a class="code" href="a00092.html#aa44515fab0ace8928d1cb82009a95bf8">BM_ASSERT</a>(left &lt;= right);
<a name="l00717"></a>00717     
<a name="l00718"></a>00718     <span class="keyword">const</span> T* pcurr = buf;
<a name="l00719"></a>00719     <span class="keyword">const</span> T* pend = pcurr + (*pcurr &gt;&gt; 3);
<a name="l00720"></a>00720     
<a name="l00721"></a>00721     <span class="keywordtype">unsigned</span> bits_counter = 0;
<a name="l00722"></a>00722     <span class="keywordtype">unsigned</span> is_set;
<a name="l00723"></a>00723     <span class="keywordtype">unsigned</span> start_pos = <a class="code" href="a00115.html#acebed8b533c2c9e17167617501477693">gap_bfind</a>(buf, left, &amp;is_set);
<a name="l00724"></a>00724 
<a name="l00725"></a>00725     pcurr = buf + start_pos;
<a name="l00726"></a>00726     <span class="keywordflow">if</span> (right &lt;= *pcurr) <span class="comment">// we are in the target block right now</span>
<a name="l00727"></a>00727     {
<a name="l00728"></a>00728         <span class="keywordflow">if</span> (is_set)
<a name="l00729"></a>00729             bits_counter = (right - left + 1);
<a name="l00730"></a>00730         <span class="keywordflow">return</span> bits_counter;
<a name="l00731"></a>00731     }
<a name="l00732"></a>00732     <span class="keywordflow">if</span> (is_set)
<a name="l00733"></a>00733         bits_counter += *pcurr - left + 1;
<a name="l00734"></a>00734 
<a name="l00735"></a>00735     <span class="keywordtype">unsigned</span> prev_gap = *pcurr++;
<a name="l00736"></a>00736     is_set ^= 1;
<a name="l00737"></a>00737     <span class="keywordflow">while</span> (right &gt; *pcurr)
<a name="l00738"></a>00738     {
<a name="l00739"></a>00739         <span class="keywordflow">if</span> (is_set)
<a name="l00740"></a>00740             bits_counter += *pcurr - prev_gap;
<a name="l00741"></a>00741         <span class="keywordflow">if</span> (pcurr == pend) 
<a name="l00742"></a>00742             <span class="keywordflow">return</span> bits_counter;
<a name="l00743"></a>00743         prev_gap = *pcurr++;
<a name="l00744"></a>00744         is_set ^= 1;
<a name="l00745"></a>00745     }
<a name="l00746"></a>00746     <span class="keywordflow">if</span> (is_set)
<a name="l00747"></a>00747         bits_counter += right - prev_gap;
<a name="l00748"></a>00748 
<a name="l00749"></a>00749     <span class="keywordflow">return</span> bits_counter;
<a name="l00750"></a>00750 }
<a name="l00751"></a>00751 <span class="comment"></span>
<a name="l00752"></a>00752 <span class="comment">/*! </span>
<a name="l00753"></a>00753 <span class="comment">    D-GAP block for_each algorithm</span>
<a name="l00754"></a>00754 <span class="comment">    </span>
<a name="l00755"></a>00755 <span class="comment">    D-Gap Functor is called for each element but last one.</span>
<a name="l00756"></a>00756 <span class="comment">    </span>
<a name="l00757"></a>00757 <span class="comment">   \param gap_buf - GAP buffer </span>
<a name="l00758"></a>00758 <span class="comment">    </span>
<a name="l00759"></a>00759 <span class="comment">*/</span>
<a name="l00760"></a>00760 <span class="keyword">template</span>&lt;<span class="keyword">class</span> T, <span class="keyword">class</span> Func&gt; 
<a name="l00761"></a><a class="code" href="a00115.html#a6a7bfe8af49ed785f0e96c7ca37a2155">00761</a> <span class="keywordtype">void</span> <a class="code" href="a00115.html#a6a7bfe8af49ed785f0e96c7ca37a2155">for_each_dgap</a>(<span class="keyword">const</span> T* gap_buf, Func&amp; func)
<a name="l00762"></a>00762 {
<a name="l00763"></a>00763     <span class="keyword">const</span> T* pcurr = gap_buf;
<a name="l00764"></a>00764     <span class="keyword">const</span> T* pend = pcurr + (*pcurr &gt;&gt; 3);
<a name="l00765"></a>00765     ++pcurr;
<a name="l00766"></a>00766     
<a name="l00767"></a>00767     T prev = *pcurr;
<a name="l00768"></a>00768     func(prev + 1); <span class="comment">// first element incremented to avoid 0</span>
<a name="l00769"></a>00769     ++pcurr;
<a name="l00770"></a>00770     <span class="keywordflow">do</span>
<a name="l00771"></a>00771     {
<a name="l00772"></a>00772         func(*pcurr - prev); <span class="comment">// all others are [N] - [N-1]</span>
<a name="l00773"></a>00773         prev = *pcurr;
<a name="l00774"></a>00774     } <span class="keywordflow">while</span> (++pcurr &lt; pend);
<a name="l00775"></a>00775 }
<a name="l00776"></a>00776 <span class="comment"></span>
<a name="l00777"></a>00777 <span class="comment">/** d-Gap copy functor</span>
<a name="l00778"></a>00778 <span class="comment">    @internal</span>
<a name="l00779"></a>00779 <span class="comment">*/</span>
<a name="l00780"></a><a class="code" href="a00049.html">00780</a> <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">struct </span><a class="code" href="a00049.html" title="d-Gap copy functor">d_copy_func</a>
<a name="l00781"></a>00781 {
<a name="l00782"></a><a class="code" href="a00049.html#a07d1323a66a8e3c2cc0e515c379466c2">00782</a>     <a class="code" href="a00049.html#a07d1323a66a8e3c2cc0e515c379466c2">d_copy_func</a>(T* dg_buf) : <a class="code" href="a00049.html#aef953bbffa1f6ef09a9d4321a3c69bc7">dgap_buf_</a>(dg_buf) {}
<a name="l00783"></a><a class="code" href="a00049.html#a1afd038e81a03293793a28d026fca1c5">00783</a>     <span class="keywordtype">void</span> <a class="code" href="a00049.html#a1afd038e81a03293793a28d026fca1c5">operator()</a>(T dgap) { *<a class="code" href="a00049.html#aef953bbffa1f6ef09a9d4321a3c69bc7">dgap_buf_</a>++ = dgap; }
<a name="l00784"></a>00784 
<a name="l00785"></a><a class="code" href="a00049.html#aef953bbffa1f6ef09a9d4321a3c69bc7">00785</a>     T* <a class="code" href="a00049.html#aef953bbffa1f6ef09a9d4321a3c69bc7">dgap_buf_</a>;
<a name="l00786"></a>00786 };
<a name="l00787"></a>00787 <span class="comment"></span>
<a name="l00788"></a>00788 <span class="comment">/*! </span>
<a name="l00789"></a>00789 <span class="comment">   \brief Convert GAP buffer into D-GAP buffer</span>
<a name="l00790"></a>00790 <span class="comment">   </span>
<a name="l00791"></a>00791 <span class="comment">   Delta GAP representation is DGAP[N] = GAP[N] - GAP[N-1]    </span>
<a name="l00792"></a>00792 <span class="comment">   </span>
<a name="l00793"></a>00793 <span class="comment">   \param gap_buf - GAP buffer </span>
<a name="l00794"></a>00794 <span class="comment">   \param dgap_buf - Delta-GAP buffer</span>
<a name="l00795"></a>00795 <span class="comment">   \param copy_head - flag to copy GAP header</span>
<a name="l00796"></a>00796 <span class="comment">   </span>
<a name="l00797"></a>00797 <span class="comment">   \internal</span>
<a name="l00798"></a>00798 <span class="comment">   </span>
<a name="l00799"></a>00799 <span class="comment">   @ingroup gapfunc</span>
<a name="l00800"></a>00800 <span class="comment">*/</span>
<a name="l00801"></a>00801 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;
<a name="l00802"></a><a class="code" href="a00115.html#afa6ea0cce0cdd88738a01fad393376b3">00802</a> T* <a class="code" href="a00115.html#afa6ea0cce0cdd88738a01fad393376b3" title="Convert GAP buffer into D-GAP buffer.">gap_2_dgap</a>(<span class="keyword">const</span> T* gap_buf, T* dgap_buf, <span class="keywordtype">bool</span> copy_head=<span class="keyword">true</span>)
<a name="l00803"></a>00803 {
<a name="l00804"></a>00804     <span class="keywordflow">if</span> (copy_head) <span class="comment">// copy GAP header</span>
<a name="l00805"></a>00805     {
<a name="l00806"></a>00806         *dgap_buf++ = *gap_buf;
<a name="l00807"></a>00807     }
<a name="l00808"></a>00808 
<a name="l00809"></a>00809     <a class="code" href="a00049.html" title="d-Gap copy functor">d_copy_func&lt;T&gt;</a> copy_func(dgap_buf);
<a name="l00810"></a>00810     for_each_dgap&lt;T, d_copy_func&lt;T&gt; &gt;(gap_buf, copy_func);
<a name="l00811"></a>00811     <span class="keywordflow">return</span> copy_func.<a class="code" href="a00049.html#aef953bbffa1f6ef09a9d4321a3c69bc7">dgap_buf_</a>;
<a name="l00812"></a>00812 }
<a name="l00813"></a>00813 <span class="comment"></span>
<a name="l00814"></a>00814 <span class="comment">/*! </span>
<a name="l00815"></a>00815 <span class="comment">   \brief Convert D-GAP buffer into GAP buffer</span>
<a name="l00816"></a>00816 <span class="comment">   </span>
<a name="l00817"></a>00817 <span class="comment">   GAP representation is GAP[N] = DGAP[N] + DGAP[N-1]    </span>
<a name="l00818"></a>00818 <span class="comment">   </span>
<a name="l00819"></a>00819 <span class="comment">   \param dgap_buf - Delta-GAP buffer</span>
<a name="l00820"></a>00820 <span class="comment">   \param gap_buf  - GAP buffer</span>
<a name="l00821"></a>00821 <span class="comment"></span>
<a name="l00822"></a>00822 <span class="comment">   \internal</span>
<a name="l00823"></a>00823 <span class="comment">   @ingroup gapfunc</span>
<a name="l00824"></a>00824 <span class="comment">*/</span>
<a name="l00825"></a>00825 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;
<a name="l00826"></a><a class="code" href="a00115.html#a528894002dcd8edda28c8fb2b0aa8c64">00826</a> <span class="keywordtype">void</span> <a class="code" href="a00115.html#a528894002dcd8edda28c8fb2b0aa8c64" title="Convert D-GAP buffer into GAP buffer.">dgap_2_gap</a>(<span class="keyword">const</span> T* dgap_buf, T* gap_buf, T gap_header=0)
<a name="l00827"></a>00827 {
<a name="l00828"></a>00828     <span class="keyword">const</span> T* pcurr = dgap_buf;
<a name="l00829"></a>00829     <span class="keywordtype">unsigned</span> len;    
<a name="l00830"></a>00830     <span class="keywordflow">if</span> (!gap_header) <span class="comment">// GAP header is already part of the stream</span>
<a name="l00831"></a>00831     {
<a name="l00832"></a>00832         len = *pcurr &gt;&gt; 3;
<a name="l00833"></a>00833         *gap_buf++ = *pcurr++; <span class="comment">// copy GAP header</span>
<a name="l00834"></a>00834     }
<a name="l00835"></a>00835     <span class="keywordflow">else</span> <span class="comment">// GAP header passed as a parameter</span>
<a name="l00836"></a>00836     {
<a name="l00837"></a>00837         len = gap_header &gt;&gt; 3;
<a name="l00838"></a>00838         *gap_buf++ = gap_header; <span class="comment">// assign GAP header</span>
<a name="l00839"></a>00839     }    
<a name="l00840"></a>00840     --len; <span class="comment">// last element is actually not encoded</span>
<a name="l00841"></a>00841     <span class="keyword">register</span> <span class="keyword">const</span> T* pend = pcurr + len;
<a name="l00842"></a>00842 
<a name="l00843"></a>00843     *gap_buf = *pcurr++; <span class="comment">// copy first element</span>
<a name="l00844"></a>00844     <span class="keywordflow">if</span> (*gap_buf == 0) 
<a name="l00845"></a>00845         *gap_buf = 65535; <span class="comment">// fix +1 overflow</span>
<a name="l00846"></a>00846     <span class="keywordflow">else</span>
<a name="l00847"></a>00847         *gap_buf = *gap_buf - 1;
<a name="l00848"></a>00848     
<a name="l00849"></a>00849     <span class="keywordflow">for</span> (++gap_buf; pcurr &lt; pend; ++pcurr)
<a name="l00850"></a>00850     {
<a name="l00851"></a>00851         T prev = *(gap_buf-1); <span class="comment">// don&apos;t remove temp(undef expression!)           </span>
<a name="l00852"></a>00852         *gap_buf++ = *pcurr + prev;
<a name="l00853"></a>00853     }
<a name="l00854"></a>00854     *gap_buf = 65535; <span class="comment">// add missing last element  </span>
<a name="l00855"></a>00855 }
<a name="l00856"></a>00856 
<a name="l00857"></a>00857 <span class="comment"></span>
<a name="l00858"></a>00858 <span class="comment">/*! </span>
<a name="l00859"></a>00859 <span class="comment">   \brief Lexicographical comparison of GAP buffers.</span>
<a name="l00860"></a>00860 <span class="comment">   \param buf1 - First GAP buffer pointer.</span>
<a name="l00861"></a>00861 <span class="comment">   \param buf2 - Second GAP buffer pointer.</span>
<a name="l00862"></a>00862 <span class="comment">   \return  &lt;0 - less, =0 - equal,  &gt;0 - greater.</span>
<a name="l00863"></a>00863 <span class="comment"></span>
<a name="l00864"></a>00864 <span class="comment">   @ingroup gapfunc</span>
<a name="l00865"></a>00865 <span class="comment">*/</span>
<a name="l00866"></a><a class="code" href="a00119.html#ga406952734f1b05962941b32e37b3eb96">00866</a> <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keywordtype">int</span> <a class="code" href="a00119.html#ga406952734f1b05962941b32e37b3eb96" title="Lexicographical comparison of GAP buffers.">gapcmp</a>(<span class="keyword">const</span> T* buf1, <span class="keyword">const</span> T* buf2)
<a name="l00867"></a>00867 {
<a name="l00868"></a>00868     <span class="keyword">const</span> T* pcurr1 = buf1;
<a name="l00869"></a>00869     <span class="keyword">const</span> T* pend1 = pcurr1 + (*pcurr1 &gt;&gt; 3);
<a name="l00870"></a>00870     <span class="keywordtype">unsigned</span> bitval1 = *buf1 &amp; 1;
<a name="l00871"></a>00871     ++pcurr1;
<a name="l00872"></a>00872 
<a name="l00873"></a>00873     <span class="keyword">const</span> T* pcurr2 = buf2;
<a name="l00874"></a>00874     <span class="keywordtype">unsigned</span> bitval2 = *buf2 &amp; 1;
<a name="l00875"></a>00875     ++pcurr2;
<a name="l00876"></a>00876 
<a name="l00877"></a>00877     <span class="keywordflow">while</span> (pcurr1 &lt;= pend1)
<a name="l00878"></a>00878     {
<a name="l00879"></a>00879         <span class="keywordflow">if</span> (*pcurr1 == *pcurr2)
<a name="l00880"></a>00880         {
<a name="l00881"></a>00881             <span class="keywordflow">if</span> (bitval1 != bitval2)
<a name="l00882"></a>00882             {
<a name="l00883"></a>00883                 <span class="keywordflow">return</span> (bitval1) ? 1 : -1;
<a name="l00884"></a>00884             }
<a name="l00885"></a>00885         }
<a name="l00886"></a>00886         <span class="keywordflow">else</span>
<a name="l00887"></a>00887         {
<a name="l00888"></a>00888             <span class="keywordflow">if</span> (bitval1 == bitval2)
<a name="l00889"></a>00889             {
<a name="l00890"></a>00890                 <span class="keywordflow">if</span> (bitval1)
<a name="l00891"></a>00891                 {
<a name="l00892"></a>00892                     <span class="keywordflow">return</span> (*pcurr1 &lt; *pcurr2) ? -1 : 1;
<a name="l00893"></a>00893                 }
<a name="l00894"></a>00894                 <span class="keywordflow">else</span>
<a name="l00895"></a>00895                 {
<a name="l00896"></a>00896                     <span class="keywordflow">return</span> (*pcurr1 &lt; *pcurr2) ? 1 : -1;
<a name="l00897"></a>00897                 }
<a name="l00898"></a>00898             }
<a name="l00899"></a>00899             <span class="keywordflow">else</span>
<a name="l00900"></a>00900             {
<a name="l00901"></a>00901                 <span class="keywordflow">return</span> (bitval1) ? 1 : -1;
<a name="l00902"></a>00902             }
<a name="l00903"></a>00903         }
<a name="l00904"></a>00904 
<a name="l00905"></a>00905         ++pcurr1; ++pcurr2;
<a name="l00906"></a>00906 
<a name="l00907"></a>00907         bitval1 ^= 1;
<a name="l00908"></a>00908         bitval2 ^= 1;
<a name="l00909"></a>00909     }
<a name="l00910"></a>00910 
<a name="l00911"></a>00911     <span class="keywordflow">return</span> 0;
<a name="l00912"></a>00912 }
<a name="l00913"></a>00913 
<a name="l00914"></a>00914 <span class="comment"></span>
<a name="l00915"></a>00915 <span class="comment">/*!</span>
<a name="l00916"></a>00916 <span class="comment">   \brief Abstract operation for GAP buffers. </span>
<a name="l00917"></a>00917 <span class="comment">          Receives functor F as a template argument</span>
<a name="l00918"></a>00918 <span class="comment">   \param dest - destination memory buffer.</span>
<a name="l00919"></a>00919 <span class="comment">   \param vect1 - operand 1 GAP encoded buffer.</span>
<a name="l00920"></a>00920 <span class="comment">   \param vect1_mask - XOR mask for starting bitflag for vector1 </span>
<a name="l00921"></a>00921 <span class="comment">   can be 0 or 1 (1 inverts the vector)</span>
<a name="l00922"></a>00922 <span class="comment">   \param vect2 - operand 2 GAP encoded buffer.</span>
<a name="l00923"></a>00923 <span class="comment">   \param vect2_mask - same as vect1_mask</span>
<a name="l00924"></a>00924 <span class="comment">   \param f - operation functor.</span>
<a name="l00925"></a>00925 <span class="comment">   \param dlen - destination length after the operation</span>
<a name="l00926"></a>00926 <span class="comment"></span>
<a name="l00927"></a>00927 <span class="comment">   \note Internal function.</span>
<a name="l00928"></a>00928 <span class="comment">   @internal</span>
<a name="l00929"></a>00929 <span class="comment"></span>
<a name="l00930"></a>00930 <span class="comment">   @ingroup gapfunc</span>
<a name="l00931"></a>00931 <span class="comment">*/</span>
<a name="l00932"></a>00932 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">class</span> F&gt; 
<a name="l00933"></a><a class="code" href="a00115.html#aac0daaac2b5a7c88e6be726c77f52c68">00933</a> <span class="keywordtype">void</span> <a class="code" href="a00115.html#aac0daaac2b5a7c88e6be726c77f52c68" title="Abstract operation for GAP buffers. Receives functor F as a template argument.">gap_buff_op</a>(T*         BMRESTRICT dest, 
<a name="l00934"></a>00934                  <span class="keyword">const</span> T*   BMRESTRICT vect1,
<a name="l00935"></a>00935                  <span class="keywordtype">unsigned</span>   vect1_mask, 
<a name="l00936"></a>00936                  <span class="keyword">const</span> T*   BMRESTRICT vect2,
<a name="l00937"></a>00937                  <span class="keywordtype">unsigned</span>   vect2_mask, 
<a name="l00938"></a>00938                  F&amp;         f,
<a name="l00939"></a>00939                  <span class="keywordtype">unsigned</span>&amp;  dlen)
<a name="l00940"></a>00940 {
<a name="l00941"></a>00941     <span class="keyword">register</span> <span class="keyword">const</span> T*  cur1 = vect1;
<a name="l00942"></a>00942     <span class="keyword">register</span> <span class="keyword">const</span> T*  cur2 = vect2;
<a name="l00943"></a>00943 
<a name="l00944"></a>00944     T bitval1 = (T)((*cur1++ &amp; 1) ^ vect1_mask);
<a name="l00945"></a>00945     T bitval2 = (T)((*cur2++ &amp; 1) ^ vect2_mask);
<a name="l00946"></a>00946     
<a name="l00947"></a>00947     T bitval = (T) f(bitval1, bitval2);
<a name="l00948"></a>00948     T bitval_prev = bitval;
<a name="l00949"></a>00949 
<a name="l00950"></a>00950     <span class="keyword">register</span> T* res = dest; 
<a name="l00951"></a>00951     *res = bitval;
<a name="l00952"></a>00952     ++res;
<a name="l00953"></a>00953 
<a name="l00954"></a>00954     <span class="keywordflow">while</span> (1)
<a name="l00955"></a>00955     {
<a name="l00956"></a>00956         bitval = (T) f(bitval1, bitval2);
<a name="l00957"></a>00957 
<a name="l00958"></a>00958         <span class="comment">// Check if GAP value changes and we need to </span>
<a name="l00959"></a>00959         <span class="comment">// start the next one.</span>
<a name="l00960"></a>00960         <span class="keywordflow">if</span> (bitval != bitval_prev)
<a name="l00961"></a>00961         {
<a name="l00962"></a>00962             ++res;
<a name="l00963"></a>00963             bitval_prev = bitval;
<a name="l00964"></a>00964         }
<a name="l00965"></a>00965 
<a name="l00966"></a>00966         <span class="keywordflow">if</span> (*cur1 &lt; *cur2)
<a name="l00967"></a>00967         {
<a name="l00968"></a>00968             *res = *cur1;
<a name="l00969"></a>00969             ++cur1;
<a name="l00970"></a>00970             bitval1 ^= 1;
<a name="l00971"></a>00971         }
<a name="l00972"></a>00972         <span class="keywordflow">else</span> <span class="comment">// &gt;=</span>
<a name="l00973"></a>00973         {
<a name="l00974"></a>00974             *res = *cur2;
<a name="l00975"></a>00975             <span class="keywordflow">if</span> (*cur2 &lt; *cur1)
<a name="l00976"></a>00976             {
<a name="l00977"></a>00977                 bitval2 ^= 1;                
<a name="l00978"></a>00978             }
<a name="l00979"></a>00979             <span class="keywordflow">else</span>  <span class="comment">// equal</span>
<a name="l00980"></a>00980             {
<a name="l00981"></a>00981                 <span class="keywordflow">if</span> (*cur2 == (<a class="code" href="a00115.html#ad0b8714080144ac70197840ff96752b7">bm::gap_max_bits</a> - 1))
<a name="l00982"></a>00982                 {
<a name="l00983"></a>00983                     <span class="keywordflow">break</span>;
<a name="l00984"></a>00984                 }
<a name="l00985"></a>00985 
<a name="l00986"></a>00986                 ++cur1;
<a name="l00987"></a>00987                 bitval1 ^= 1;
<a name="l00988"></a>00988                 bitval2 ^= 1;
<a name="l00989"></a>00989             }
<a name="l00990"></a>00990             ++cur2;
<a name="l00991"></a>00991         }
<a name="l00992"></a>00992 
<a name="l00993"></a>00993     } <span class="comment">// while</span>
<a name="l00994"></a>00994 
<a name="l00995"></a>00995     dlen = (unsigned)(res - dest);
<a name="l00996"></a>00996     *dest = (T)((*dest &amp; 7) + (dlen &lt;&lt; 3));
<a name="l00997"></a>00997 
<a name="l00998"></a>00998 }
<a name="l00999"></a>00999 <span class="comment"></span>
<a name="l01000"></a>01000 <span class="comment">/*!</span>
<a name="l01001"></a>01001 <span class="comment">   \brief Abstract distance test operation for GAP buffers. </span>
<a name="l01002"></a>01002 <span class="comment">          Receives functor F as a template argument</span>
<a name="l01003"></a>01003 <span class="comment">   \param vect1 - operand 1 GAP encoded buffer.</span>
<a name="l01004"></a>01004 <span class="comment">   \param vect1_mask - XOR mask for starting bitflag for vector1 </span>
<a name="l01005"></a>01005 <span class="comment">                       can be 0 or 1 (1 inverts the vector)</span>
<a name="l01006"></a>01006 <span class="comment">   \param vect2 - operand 2 GAP encoded buffer.</span>
<a name="l01007"></a>01007 <span class="comment">   \param vect2_mask - same as vect1_mask</span>
<a name="l01008"></a>01008 <span class="comment">   \param f - operation functor.</span>
<a name="l01009"></a>01009 <span class="comment">   \note Internal function.</span>
<a name="l01010"></a>01010 <span class="comment">   \return non zero value if operation result returns any 1 bit </span>
<a name="l01011"></a>01011 <span class="comment"></span>
<a name="l01012"></a>01012 <span class="comment">   @ingroup gapfunc</span>
<a name="l01013"></a>01013 <span class="comment">*/</span>
<a name="l01014"></a>01014 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">class</span> F&gt; 
<a name="l01015"></a><a class="code" href="a00119.html#ga5e3123c3c9d3587f470abdbe6c8c3ad3">01015</a> <span class="keywordtype">unsigned</span> <a class="code" href="a00119.html#ga5e3123c3c9d3587f470abdbe6c8c3ad3" title="Abstract distance test operation for GAP buffers. Receives functor F as a template...">gap_buff_any_op</a>(<span class="keyword">const</span> T*   BMRESTRICT vect1,
<a name="l01016"></a>01016                          <span class="keywordtype">unsigned</span>              vect1_mask, 
<a name="l01017"></a>01017                          <span class="keyword">const</span> T*   BMRESTRICT vect2,
<a name="l01018"></a>01018                          <span class="keywordtype">unsigned</span>              vect2_mask, 
<a name="l01019"></a>01019                          F                     f)
<a name="l01020"></a>01020 {
<a name="l01021"></a>01021     <span class="keyword">register</span> <span class="keyword">const</span> T*  cur1 = vect1;
<a name="l01022"></a>01022     <span class="keyword">register</span> <span class="keyword">const</span> T*  cur2 = vect2;
<a name="l01023"></a>01023 
<a name="l01024"></a>01024     <span class="keywordtype">unsigned</span> bitval1 = (*cur1++ &amp; 1) ^ vect1_mask;
<a name="l01025"></a>01025     <span class="keywordtype">unsigned</span> bitval2 = (*cur2++ &amp; 1) ^ vect2_mask;
<a name="l01026"></a>01026     
<a name="l01027"></a>01027     <span class="keywordtype">unsigned</span> bitval = f(bitval1, bitval2);
<a name="l01028"></a>01028     <span class="keywordflow">if</span> (bitval)
<a name="l01029"></a>01029         <span class="keywordflow">return</span> bitval;
<a name="l01030"></a>01030     <span class="keywordtype">unsigned</span> bitval_prev = bitval;
<a name="l01031"></a>01031 
<a name="l01032"></a>01032     <span class="keywordflow">while</span> (1)
<a name="l01033"></a>01033     {
<a name="l01034"></a>01034         bitval = f(bitval1, bitval2);
<a name="l01035"></a>01035         <span class="keywordflow">if</span> (bitval)
<a name="l01036"></a>01036             <span class="keywordflow">return</span> bitval;
<a name="l01037"></a>01037 
<a name="l01038"></a>01038         <span class="keywordflow">if</span> (bitval != bitval_prev)
<a name="l01039"></a>01039             bitval_prev = bitval;
<a name="l01040"></a>01040 
<a name="l01041"></a>01041         <span class="keywordflow">if</span> (*cur1 &lt; *cur2)
<a name="l01042"></a>01042         {
<a name="l01043"></a>01043             ++cur1;
<a name="l01044"></a>01044             bitval1 ^= 1;
<a name="l01045"></a>01045         }
<a name="l01046"></a>01046         <span class="keywordflow">else</span> <span class="comment">// &gt;=</span>
<a name="l01047"></a>01047         {
<a name="l01048"></a>01048             <span class="keywordflow">if</span> (*cur2 &lt; *cur1)
<a name="l01049"></a>01049             {
<a name="l01050"></a>01050                 bitval2 ^= 1;                
<a name="l01051"></a>01051             }
<a name="l01052"></a>01052             <span class="keywordflow">else</span>  <span class="comment">// equal</span>
<a name="l01053"></a>01053             {
<a name="l01054"></a>01054                 <span class="keywordflow">if</span> (*cur2 == (<a class="code" href="a00115.html#ad0b8714080144ac70197840ff96752b7">bm::gap_max_bits</a> - 1))
<a name="l01055"></a>01055                 {
<a name="l01056"></a>01056                     <span class="keywordflow">break</span>;
<a name="l01057"></a>01057                 }
<a name="l01058"></a>01058 
<a name="l01059"></a>01059                 ++cur1;
<a name="l01060"></a>01060                 bitval1 ^= 1;
<a name="l01061"></a>01061                 bitval2 ^= 1;
<a name="l01062"></a>01062             }
<a name="l01063"></a>01063             ++cur2;
<a name="l01064"></a>01064         }
<a name="l01065"></a>01065 
<a name="l01066"></a>01066     } <span class="comment">// while</span>
<a name="l01067"></a>01067 
<a name="l01068"></a>01068     <span class="keywordflow">return</span> 0;
<a name="l01069"></a>01069 }
<a name="l01070"></a>01070 
<a name="l01071"></a>01071 
<a name="l01072"></a>01072 <span class="comment"></span>
<a name="l01073"></a>01073 <span class="comment">/*!</span>
<a name="l01074"></a>01074 <span class="comment">   \brief Abstract distance(similarity) operation for GAP buffers. </span>
<a name="l01075"></a>01075 <span class="comment">          Receives functor F as a template argument</span>
<a name="l01076"></a>01076 <span class="comment">   \param vect1 - operand 1 GAP encoded buffer.</span>
<a name="l01077"></a>01077 <span class="comment">   \param vect2 - operand 2 GAP encoded buffer.</span>
<a name="l01078"></a>01078 <span class="comment">   \param f - operation functor.</span>
<a name="l01079"></a>01079 <span class="comment">   \note Internal function.</span>
<a name="l01080"></a>01080 <span class="comment"></span>
<a name="l01081"></a>01081 <span class="comment">   @ingroup gapfunc</span>
<a name="l01082"></a>01082 <span class="comment">*/</span>
<a name="l01083"></a>01083 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">class</span> F&gt; 
<a name="l01084"></a><a class="code" href="a00119.html#ga9a5ff7782f3de0d1c699eb72d432f255">01084</a> <span class="keywordtype">unsigned</span> <a class="code" href="a00119.html#ga9a5ff7782f3de0d1c699eb72d432f255" title="Abstract distance(similarity) operation for GAP buffers. Receives functor F as a...">gap_buff_count_op</a>(<span class="keyword">const</span> T*  vect1, <span class="keyword">const</span> T*  vect2, F f)
<a name="l01085"></a>01085 {
<a name="l01086"></a>01086     <span class="keywordtype">unsigned</span> count;<span class="comment">// = 0;</span>
<a name="l01087"></a>01087     <span class="keyword">const</span> T* cur1 = vect1;
<a name="l01088"></a>01088     <span class="keyword">const</span> T* cur2 = vect2;
<a name="l01089"></a>01089 
<a name="l01090"></a>01090     <span class="keywordtype">unsigned</span> bitval1 = (*cur1++ &amp; 1);
<a name="l01091"></a>01091     <span class="keywordtype">unsigned</span> bitval2 = (*cur2++ &amp; 1);
<a name="l01092"></a>01092     <span class="keywordtype">unsigned</span> bitval = count = f(bitval1, bitval2);
<a name="l01093"></a>01093     <span class="keywordtype">unsigned</span> bitval_prev = bitval;
<a name="l01094"></a>01094 
<a name="l01095"></a>01095     <span class="comment">//if (bitval) ++count;</span>
<a name="l01096"></a>01096     
<a name="l01097"></a>01097     T res, res_prev;
<a name="l01098"></a>01098     res = res_prev = 0;
<a name="l01099"></a>01099 
<a name="l01100"></a>01100     <span class="keywordflow">while</span> (1)
<a name="l01101"></a>01101     {
<a name="l01102"></a>01102         bitval = f(bitval1, bitval2);
<a name="l01103"></a>01103 
<a name="l01104"></a>01104         <span class="comment">// Check if GAP value changes and we need to </span>
<a name="l01105"></a>01105         <span class="comment">// start the next one.</span>
<a name="l01106"></a>01106         <span class="keywordflow">if</span> (bitval != bitval_prev)
<a name="l01107"></a>01107         {
<a name="l01108"></a>01108             bitval_prev = bitval;
<a name="l01109"></a>01109             res_prev = res;
<a name="l01110"></a>01110         }
<a name="l01111"></a>01111 
<a name="l01112"></a>01112         <span class="keywordflow">if</span> (*cur1 &lt; *cur2)
<a name="l01113"></a>01113         {
<a name="l01114"></a>01114             res = *cur1;
<a name="l01115"></a>01115             <span class="keywordflow">if</span> (bitval)
<a name="l01116"></a>01116             {
<a name="l01117"></a>01117                 count += res - res_prev; 
<a name="l01118"></a>01118                 res_prev = res;
<a name="l01119"></a>01119             }
<a name="l01120"></a>01120             ++cur1;
<a name="l01121"></a>01121             bitval1 ^= 1;
<a name="l01122"></a>01122         }
<a name="l01123"></a>01123         <span class="keywordflow">else</span> <span class="comment">// &gt;=</span>
<a name="l01124"></a>01124         {
<a name="l01125"></a>01125             res = *cur2;
<a name="l01126"></a>01126             <span class="keywordflow">if</span> (bitval)
<a name="l01127"></a>01127             {
<a name="l01128"></a>01128                 count += res - res_prev; 
<a name="l01129"></a>01129                 res_prev = res;
<a name="l01130"></a>01130             }
<a name="l01131"></a>01131             <span class="keywordflow">if</span> (*cur2 &lt; *cur1)
<a name="l01132"></a>01132             {
<a name="l01133"></a>01133                 bitval2 ^= 1;                
<a name="l01134"></a>01134             }
<a name="l01135"></a>01135             <span class="keywordflow">else</span>  <span class="comment">// equal</span>
<a name="l01136"></a>01136             {
<a name="l01137"></a>01137                 <span class="keywordflow">if</span> (*cur2 == (<a class="code" href="a00115.html#ad0b8714080144ac70197840ff96752b7">bm::gap_max_bits</a> - 1))
<a name="l01138"></a>01138                 {
<a name="l01139"></a>01139                     <span class="keywordflow">break</span>;
<a name="l01140"></a>01140                 }
<a name="l01141"></a>01141 
<a name="l01142"></a>01142                 ++cur1;
<a name="l01143"></a>01143                 bitval1 ^= 1;
<a name="l01144"></a>01144                 bitval2 ^= 1;
<a name="l01145"></a>01145             }
<a name="l01146"></a>01146             ++cur2;
<a name="l01147"></a>01147         }
<a name="l01148"></a>01148 
<a name="l01149"></a>01149     } <span class="comment">// while</span>
<a name="l01150"></a>01150 
<a name="l01151"></a>01151     <span class="keywordflow">return</span> count;
<a name="l01152"></a>01152 }
<a name="l01153"></a>01153 
<a name="l01154"></a>01154 
<a name="l01155"></a>01155 <span class="comment"></span>
<a name="l01156"></a>01156 <span class="comment">/*!</span>
<a name="l01157"></a>01157 <span class="comment">   \brief Sets or clears bit in the GAP buffer.</span>
<a name="l01158"></a>01158 <span class="comment"></span>
<a name="l01159"></a>01159 <span class="comment">   \param val - new bit value</span>
<a name="l01160"></a>01160 <span class="comment">   \param buf - GAP buffer.</span>
<a name="l01161"></a>01161 <span class="comment">   \param pos - Index of bit to set.</span>
<a name="l01162"></a>01162 <span class="comment">   \param is_set - (OUT) flag if bit was actually set.</span>
<a name="l01163"></a>01163 <span class="comment"></span>
<a name="l01164"></a>01164 <span class="comment">   \return New GAP buffer length. </span>
<a name="l01165"></a>01165 <span class="comment"></span>
<a name="l01166"></a>01166 <span class="comment">   @ingroup gapfunc</span>
<a name="l01167"></a>01167 <span class="comment">*/</span>
<a name="l01168"></a><a class="code" href="a00119.html#ga69186bd13bda27e04b3e33683ff884c2">01168</a> <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keywordtype">unsigned</span> <a class="code" href="a00119.html#ga69186bd13bda27e04b3e33683ff884c2" title="Sets or clears bit in the GAP buffer.">gap_set_value</a>(<span class="keywordtype">unsigned</span> val, 
<a name="l01169"></a>01169                                             T* BMRESTRICT buf, 
<a name="l01170"></a>01170                                             <span class="keywordtype">unsigned</span> pos, 
<a name="l01171"></a>01171                                             <span class="keywordtype">unsigned</span>* BMRESTRICT is_set)
<a name="l01172"></a>01172 {
<a name="l01173"></a>01173     <a class="code" href="a00092.html#aa44515fab0ace8928d1cb82009a95bf8">BM_ASSERT</a>(pos &lt; <a class="code" href="a00115.html#ad0b8714080144ac70197840ff96752b7">bm::gap_max_bits</a>);
<a name="l01174"></a>01174     <span class="keywordtype">unsigned</span> curr = <a class="code" href="a00115.html#acebed8b533c2c9e17167617501477693">gap_bfind</a>(buf, pos, is_set);
<a name="l01175"></a>01175 
<a name="l01176"></a>01176     <span class="keyword">register</span> T end = (*buf &gt;&gt; 3);
<a name="l01177"></a>01177     <span class="keywordflow">if</span> (*is_set == val)
<a name="l01178"></a>01178     {
<a name="l01179"></a>01179         *is_set = 0;
<a name="l01180"></a>01180         <span class="keywordflow">return</span> end;
<a name="l01181"></a>01181     }
<a name="l01182"></a>01182     *is_set = 1;
<a name="l01183"></a>01183 
<a name="l01184"></a>01184     <span class="keyword">register</span> T* pcurr = buf + curr;
<a name="l01185"></a>01185     <span class="keyword">register</span> T* pprev = pcurr - 1;
<a name="l01186"></a>01186     <span class="keyword">register</span> T* pend = buf + end;
<a name="l01187"></a>01187 
<a name="l01188"></a>01188     <span class="comment">// Special case, first bit GAP operation. There is no platform beside it.</span>
<a name="l01189"></a>01189     <span class="comment">// initial flag must be inverted.</span>
<a name="l01190"></a>01190     <span class="keywordflow">if</span> (pos == 0)
<a name="l01191"></a>01191     {
<a name="l01192"></a>01192         *buf ^= 1;
<a name="l01193"></a>01193         <span class="keywordflow">if</span> ( buf[1] ) <span class="comment">// We need to insert a 1 bit platform here.</span>
<a name="l01194"></a>01194         {
<a name="l01195"></a>01195             ::memmove(&amp;buf[2], &amp;buf[1], (end - 1) * <span class="keyword">sizeof</span>(<a class="code" href="a00115.html#ac654d6319039a86546d235a236fc7cf6">gap_word_t</a>));
<a name="l01196"></a>01196             buf[1] = 0;
<a name="l01197"></a>01197             ++end;
<a name="l01198"></a>01198         }
<a name="l01199"></a>01199         <span class="keywordflow">else</span> <span class="comment">// Only 1 bit in the GAP. We need to delete the first GAP.</span>
<a name="l01200"></a>01200         {
<a name="l01201"></a>01201             pprev = buf + 1;
<a name="l01202"></a>01202             pcurr = pprev + 1;
<a name="l01203"></a>01203             <span class="keywordflow">do</span>
<a name="l01204"></a>01204             {
<a name="l01205"></a>01205                 *pprev++ = *pcurr++;
<a name="l01206"></a>01206             } <span class="keywordflow">while</span> (pcurr &lt; pend);
<a name="l01207"></a>01207             --end;
<a name="l01208"></a>01208         }
<a name="l01209"></a>01209     }
<a name="l01210"></a>01210     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (curr &gt; 1 &amp;&amp; ((<span class="keywordtype">unsigned</span>)(*pprev))+1 == pos) <span class="comment">// Left border bit</span>
<a name="l01211"></a>01211     {
<a name="l01212"></a>01212        ++(*pprev);
<a name="l01213"></a>01213        <span class="keywordflow">if</span> (*pprev == *pcurr)  <span class="comment">// Curr. GAP to be merged with prev.GAP.</span>
<a name="l01214"></a>01214        {
<a name="l01215"></a>01215             --end;
<a name="l01216"></a>01216             <span class="keywordflow">if</span> (pcurr != pend) <span class="comment">// GAP merge: 2 GAPS to be deleted </span>
<a name="l01217"></a>01217             {
<a name="l01218"></a>01218                 --end;
<a name="l01219"></a>01219                 ++pcurr;
<a name="l01220"></a>01220                 <span class="keywordflow">do</span>
<a name="l01221"></a>01221                 {
<a name="l01222"></a>01222                     *pprev++ = *pcurr++;
<a name="l01223"></a>01223                 } <span class="keywordflow">while</span> (pcurr &lt; pend);
<a name="l01224"></a>01224             }
<a name="l01225"></a>01225        }    
<a name="l01226"></a>01226     }
<a name="l01227"></a>01227     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (*pcurr == pos) <span class="comment">// Rightmost bit in the GAP. Border goes left.</span>
<a name="l01228"></a>01228     {
<a name="l01229"></a>01229         --(*pcurr);       
<a name="l01230"></a>01230         <span class="keywordflow">if</span> (pcurr == pend)
<a name="l01231"></a>01231         {
<a name="l01232"></a>01232            ++end;
<a name="l01233"></a>01233         }
<a name="l01234"></a>01234     }
<a name="l01235"></a>01235     <span class="keywordflow">else</span>  <span class="comment">// Worst case we need to split current block.</span>
<a name="l01236"></a>01236     {
<a name="l01237"></a>01237         ::memmove(pcurr+2, pcurr,(end - curr + 1)*<span class="keyword">sizeof</span>(T));
<a name="l01238"></a>01238         *pcurr++ = (T)(pos - 1);
<a name="l01239"></a>01239         *pcurr = (T)pos;
<a name="l01240"></a>01240         end+=2;
<a name="l01241"></a>01241     }
<a name="l01242"></a>01242 
<a name="l01243"></a>01243     <span class="comment">// Set correct length word.</span>
<a name="l01244"></a>01244     *buf = (*buf &amp; 7) + (end &lt;&lt; 3);
<a name="l01245"></a>01245 
<a name="l01246"></a>01246     buf[end] = <a class="code" href="a00115.html#ad0b8714080144ac70197840ff96752b7">bm::gap_max_bits</a> - 1;
<a name="l01247"></a>01247     <span class="keywordflow">return</span> end;
<a name="l01248"></a>01248 }
<a name="l01249"></a>01249 <span class="comment"></span>
<a name="l01250"></a>01250 <span class="comment">/*!</span>
<a name="l01251"></a>01251 <span class="comment">   \brief Add new value to the end of GAP buffer.</span>
<a name="l01252"></a>01252 <span class="comment"></span>
<a name="l01253"></a>01253 <span class="comment">   \param buf - GAP buffer.</span>
<a name="l01254"></a>01254 <span class="comment">   \param pos - Index of bit to set.</span>
<a name="l01255"></a>01255 <span class="comment"></span>
<a name="l01256"></a>01256 <span class="comment">   \return New GAP buffer length. </span>
<a name="l01257"></a>01257 <span class="comment"></span>
<a name="l01258"></a>01258 <span class="comment">   @ingroup gapfunc</span>
<a name="l01259"></a>01259 <span class="comment">*/</span>
<a name="l01260"></a>01260 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; 
<a name="l01261"></a><a class="code" href="a00119.html#gadae4001e2834125b9c08b154a8a874a7">01261</a> <span class="keywordtype">unsigned</span> <a class="code" href="a00119.html#gadae4001e2834125b9c08b154a8a874a7" title="Add new value to the end of GAP buffer.">gap_add_value</a>(T* buf, T pos)
<a name="l01262"></a>01262 {
<a name="l01263"></a>01263     <a class="code" href="a00092.html#aa44515fab0ace8928d1cb82009a95bf8">BM_ASSERT</a>(pos &lt; <a class="code" href="a00115.html#ad0b8714080144ac70197840ff96752b7">bm::gap_max_bits</a>);
<a name="l01264"></a>01264 
<a name="l01265"></a>01265     <span class="keyword">register</span> T end = (*buf &gt;&gt; 3);
<a name="l01266"></a>01266     T curr = end;
<a name="l01267"></a>01267     <span class="keyword">register</span> T* pcurr = buf + end;
<a name="l01268"></a>01268     <span class="keyword">register</span> T* pend  = pcurr;
<a name="l01269"></a>01269     <span class="keyword">register</span> T* pprev = pcurr - 1;
<a name="l01270"></a>01270 
<a name="l01271"></a>01271     <span class="comment">// Special case, first bit GAP operation. There is no platform beside it.</span>
<a name="l01272"></a>01272     <span class="comment">// initial flag must be inverted.</span>
<a name="l01273"></a>01273     <span class="keywordflow">if</span> (pos == 0)
<a name="l01274"></a>01274     {
<a name="l01275"></a>01275         *buf ^= 1;
<a name="l01276"></a>01276         <span class="keywordflow">if</span> ( buf[1] ) <span class="comment">// We need to insert a 1 bit platform here.</span>
<a name="l01277"></a>01277         {
<a name="l01278"></a>01278             ::memmove(&amp;buf[2], &amp;buf[1], (end - 1) * <span class="keyword">sizeof</span>(<a class="code" href="a00115.html#ac654d6319039a86546d235a236fc7cf6">gap_word_t</a>));
<a name="l01279"></a>01279             buf[1] = 0;
<a name="l01280"></a>01280             ++end;
<a name="l01281"></a>01281         }
<a name="l01282"></a>01282         <span class="keywordflow">else</span> <span class="comment">// Only 1 bit in the GAP. We need to delete the first GAP.</span>
<a name="l01283"></a>01283         {
<a name="l01284"></a>01284             pprev = buf + 1;
<a name="l01285"></a>01285             pcurr = pprev + 1;
<a name="l01286"></a>01286             <span class="keywordflow">do</span>
<a name="l01287"></a>01287             {
<a name="l01288"></a>01288                 *pprev++ = *pcurr++;
<a name="l01289"></a>01289             } <span class="keywordflow">while</span> (pcurr &lt; pend);
<a name="l01290"></a>01290             --end;
<a name="l01291"></a>01291         }
<a name="l01292"></a>01292     }
<a name="l01293"></a>01293     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (((<span class="keywordtype">unsigned</span>)(*pprev))+1 == pos &amp;&amp; (curr &gt; 1) ) <span class="comment">// Left border bit</span>
<a name="l01294"></a>01294     {
<a name="l01295"></a>01295        ++(*pprev);
<a name="l01296"></a>01296        <span class="keywordflow">if</span> (*pprev == *pcurr)  <span class="comment">// Curr. GAP to be merged with prev.GAP.</span>
<a name="l01297"></a>01297        {
<a name="l01298"></a>01298             --end;
<a name="l01299"></a>01299             <span class="keywordflow">if</span> (pcurr != pend) <span class="comment">// GAP merge: 2 GAPS to be deleted </span>
<a name="l01300"></a>01300             {
<a name="l01301"></a>01301                 <span class="comment">// TODO: should never get here...</span>
<a name="l01302"></a>01302                 --end;
<a name="l01303"></a>01303                 ++pcurr;
<a name="l01304"></a>01304                 <span class="keywordflow">do</span>
<a name="l01305"></a>01305                 {
<a name="l01306"></a>01306                     *pprev++ = *pcurr++;
<a name="l01307"></a>01307                 } <span class="keywordflow">while</span> (pcurr &lt; pend);
<a name="l01308"></a>01308             }
<a name="l01309"></a>01309        } 
<a name="l01310"></a>01310     }
<a name="l01311"></a>01311     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (*pcurr == pos) <span class="comment">// Rightmost bit in the GAP. Border goes left.</span>
<a name="l01312"></a>01312     {
<a name="l01313"></a>01313         --(*pcurr);       
<a name="l01314"></a>01314         <span class="keywordflow">if</span> (pcurr == pend)
<a name="l01315"></a>01315         {
<a name="l01316"></a>01316            ++end;
<a name="l01317"></a>01317         }
<a name="l01318"></a>01318     }
<a name="l01319"></a>01319     <span class="keywordflow">else</span>  <span class="comment">// Worst case we need to split current block.</span>
<a name="l01320"></a>01320     {
<a name="l01321"></a>01321         *pcurr++ = pos - 1;
<a name="l01322"></a>01322         *pcurr = pos;
<a name="l01323"></a>01323         end+=2;
<a name="l01324"></a>01324     }
<a name="l01325"></a>01325 
<a name="l01326"></a>01326     <span class="comment">// Set correct length word.</span>
<a name="l01327"></a>01327     *buf = (*buf &amp; 7) + (end &lt;&lt; 3);
<a name="l01328"></a>01328 
<a name="l01329"></a>01329     buf[end] = <a class="code" href="a00115.html#ad0b8714080144ac70197840ff96752b7">bm::gap_max_bits</a> - 1;
<a name="l01330"></a>01330     <span class="keywordflow">return</span> end;
<a name="l01331"></a>01331 }
<a name="l01332"></a>01332 <span class="comment"></span>
<a name="l01333"></a>01333 <span class="comment">/*!</span>
<a name="l01334"></a>01334 <span class="comment">   \brief Convert array to GAP buffer.</span>
<a name="l01335"></a>01335 <span class="comment"></span>
<a name="l01336"></a>01336 <span class="comment">   \param buf - GAP buffer.</span>
<a name="l01337"></a>01337 <span class="comment">   \param arr - array of values to set</span>
<a name="l01338"></a>01338 <span class="comment">   \param len - length of the array</span>
<a name="l01339"></a>01339 <span class="comment"></span>
<a name="l01340"></a>01340 <span class="comment">   \return New GAP buffer length. </span>
<a name="l01341"></a>01341 <span class="comment"></span>
<a name="l01342"></a>01342 <span class="comment">   @ingroup gapfunc</span>
<a name="l01343"></a>01343 <span class="comment">*/</span>
<a name="l01344"></a>01344 
<a name="l01345"></a>01345 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; 
<a name="l01346"></a><a class="code" href="a00119.html#ga550394048c163d41a135fb9068f2251b">01346</a> <span class="keywordtype">unsigned</span> <a class="code" href="a00119.html#ga550394048c163d41a135fb9068f2251b" title="Convert array to GAP buffer.">gap_set_array</a>(T* buf, <span class="keyword">const</span> T* arr, <span class="keywordtype">unsigned</span> len)
<a name="l01347"></a>01347 {
<a name="l01348"></a>01348     *buf = (*buf &amp; 6u) + (1u &lt;&lt; 3); <span class="comment">// gap header setup</span>
<a name="l01349"></a>01349 
<a name="l01350"></a>01350     T* pcurr = buf + 1;
<a name="l01351"></a>01351 
<a name="l01352"></a>01352     <span class="keywordtype">unsigned</span> i = 0;
<a name="l01353"></a>01353     T curr = arr[i];
<a name="l01354"></a>01354     <span class="keywordflow">if</span> (curr != 0) <span class="comment">// need to add the first gap: (0 to arr[0]-1)</span>
<a name="l01355"></a>01355     {
<a name="l01356"></a>01356         *pcurr = curr - 1;
<a name="l01357"></a>01357         ++pcurr;
<a name="l01358"></a>01358     }
<a name="l01359"></a>01359     <span class="keywordflow">else</span>
<a name="l01360"></a>01360     {
<a name="l01361"></a>01361         *buf += 1; <span class="comment">// GAP starts with 1</span>
<a name="l01362"></a>01362     }
<a name="l01363"></a>01363     T prev = curr; 
<a name="l01364"></a>01364     T acc = prev;
<a name="l01365"></a>01365 
<a name="l01366"></a>01366     <span class="keywordflow">for</span> (i = 1; i &lt; len; ++i)
<a name="l01367"></a>01367     {
<a name="l01368"></a>01368         T curr = arr[i];
<a name="l01369"></a>01369         <span class="keywordflow">if</span> (curr == prev + 1)
<a name="l01370"></a>01370         {
<a name="l01371"></a>01371             ++acc;
<a name="l01372"></a>01372             prev = curr;
<a name="l01373"></a>01373         }
<a name="l01374"></a>01374         <span class="keywordflow">else</span>
<a name="l01375"></a>01375         {
<a name="l01376"></a>01376             *pcurr++ = acc;
<a name="l01377"></a>01377             acc = curr;
<a name="l01378"></a>01378             *pcurr++ = curr-1;
<a name="l01379"></a>01379         }
<a name="l01380"></a>01380         prev = curr;
<a name="l01381"></a>01381     }
<a name="l01382"></a>01382     *pcurr = acc;
<a name="l01383"></a>01383     <span class="keywordflow">if</span> (acc != <a class="code" href="a00115.html#ad0b8714080144ac70197840ff96752b7">bm::gap_max_bits</a> - 1)
<a name="l01384"></a>01384     {
<a name="l01385"></a>01385         ++pcurr;
<a name="l01386"></a>01386         *pcurr = <a class="code" href="a00115.html#ad0b8714080144ac70197840ff96752b7">bm::gap_max_bits</a> - 1;
<a name="l01387"></a>01387     }
<a name="l01388"></a>01388 
<a name="l01389"></a>01389     <span class="keywordtype">unsigned</span> end = pcurr - buf;
<a name="l01390"></a>01390 
<a name="l01391"></a>01391     *buf = (T)((*buf &amp; 7) + (end &lt;&lt; 3));
<a name="l01392"></a>01392     <span class="keywordflow">return</span> end+1;
<a name="l01393"></a>01393 }
<a name="l01394"></a>01394 
<a name="l01395"></a>01395 
<a name="l01396"></a>01396 <span class="comment">//------------------------------------------------------------------------</span>
<a name="l01397"></a>01397 <span class="comment"></span>
<a name="l01398"></a>01398 <span class="comment">/**</span>
<a name="l01399"></a>01399 <span class="comment">    \brief Compute number of GAPs in bit-array</span>
<a name="l01400"></a>01400 <span class="comment">    \param arr - array of BITs</span>
<a name="l01401"></a>01401 <span class="comment">    \param len - array length</span>
<a name="l01402"></a>01402 <span class="comment"></span>
<a name="l01403"></a>01403 <span class="comment">    @ingroup gapfunc</span>
<a name="l01404"></a>01404 <span class="comment">*/</span>
<a name="l01405"></a>01405 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; 
<a name="l01406"></a><a class="code" href="a00119.html#ga68e53a96e93a31e8a323d10c7a2f21f5">01406</a> <span class="keywordtype">unsigned</span> <a class="code" href="a00119.html#ga68e53a96e93a31e8a323d10c7a2f21f5" title="Compute number of GAPs in bit-array.">bit_array_compute_gaps</a>(<span class="keyword">const</span> T* arr, 
<a name="l01407"></a>01407                                 <span class="keywordtype">unsigned</span> len)
<a name="l01408"></a>01408 {
<a name="l01409"></a>01409     <span class="keywordtype">unsigned</span> gap_count = 1;
<a name="l01410"></a>01410     T prev = arr[0];
<a name="l01411"></a>01411     <span class="keywordflow">if</span> (prev &gt; 0)
<a name="l01412"></a>01412         ++gap_count;
<a name="l01413"></a>01413     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i = 1; i &lt; len; ++i)
<a name="l01414"></a>01414     {
<a name="l01415"></a>01415         T curr = arr[i];
<a name="l01416"></a>01416         <span class="keywordflow">if</span> (curr != prev + 1)
<a name="l01417"></a>01417         {
<a name="l01418"></a>01418             gap_count += 2;
<a name="l01419"></a>01419         }
<a name="l01420"></a>01420         prev = curr;
<a name="l01421"></a>01421     }
<a name="l01422"></a>01422     <span class="keywordflow">return</span> gap_count;
<a name="l01423"></a>01423 }
<a name="l01424"></a>01424 
<a name="l01425"></a>01425 
<a name="l01426"></a>01426 <span class="comment">//------------------------------------------------------------------------</span>
<a name="l01427"></a>01427 <span class="comment"></span>
<a name="l01428"></a>01428 <span class="comment">/**</span>
<a name="l01429"></a>01429 <span class="comment">    \brief Searches for the next 1 bit in the GAP block</span>
<a name="l01430"></a>01430 <span class="comment">    \param buf - GAP buffer</span>
<a name="l01431"></a>01431 <span class="comment">    \param nbit - bit index to start checking from.</span>
<a name="l01432"></a>01432 <span class="comment">    \param prev - returns previously checked value</span>
<a name="l01433"></a>01433 <span class="comment"></span>
<a name="l01434"></a>01434 <span class="comment">    @ingroup gapfunc</span>
<a name="l01435"></a>01435 <span class="comment">*/</span>
<a name="l01436"></a><a class="code" href="a00119.html#gaa7df7193094353ea24b8519debf745be">01436</a> <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keywordtype">int</span> <a class="code" href="a00119.html#gaa7df7193094353ea24b8519debf745be" title="Searches for the next 1 bit in the GAP block.">gap_find_in_block</a>(<span class="keyword">const</span> T* buf, 
<a name="l01437"></a>01437                                            <span class="keywordtype">unsigned</span> nbit, 
<a name="l01438"></a>01438                                            <a class="code" href="a00115.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a>* prev)
<a name="l01439"></a>01439 {
<a name="l01440"></a>01440     <a class="code" href="a00092.html#aa44515fab0ace8928d1cb82009a95bf8">BM_ASSERT</a>(nbit &lt; <a class="code" href="a00115.html#ad0b8714080144ac70197840ff96752b7">bm::gap_max_bits</a>);
<a name="l01441"></a>01441 
<a name="l01442"></a>01442     <span class="keywordtype">unsigned</span> bitval;
<a name="l01443"></a>01443     <span class="keywordtype">unsigned</span> gap_idx = <a class="code" href="a00115.html#acebed8b533c2c9e17167617501477693">bm::gap_bfind</a>(buf, nbit, &amp;bitval);
<a name="l01444"></a>01444 
<a name="l01445"></a>01445     <span class="keywordflow">if</span> (bitval) <span class="comment">// positive block.</span>
<a name="l01446"></a>01446     {
<a name="l01447"></a>01447        <span class="keywordflow">return</span> 1;
<a name="l01448"></a>01448     }
<a name="l01449"></a>01449 
<a name="l01450"></a>01450     <span class="keyword">register</span> <span class="keywordtype">unsigned</span> val = buf[gap_idx] + 1;
<a name="l01451"></a>01451     *prev += val - nbit;
<a name="l01452"></a>01452  
<a name="l01453"></a>01453     <span class="keywordflow">return</span> (val != <a class="code" href="a00115.html#ad0b8714080144ac70197840ff96752b7">bm::gap_max_bits</a>);  <span class="comment">// no bug here.</span>
<a name="l01454"></a>01454 }
<a name="l01455"></a>01455 <span class="comment"></span>
<a name="l01456"></a>01456 <span class="comment">/*! </span>
<a name="l01457"></a>01457 <span class="comment">    \brief Set 1 bit in a block</span>
<a name="l01458"></a>01458 <span class="comment">    </span>
<a name="l01459"></a>01459 <span class="comment">    @ingroup bitfunc</span>
<a name="l01460"></a>01460 <span class="comment">*/</span>
<a name="l01461"></a><a class="code" href="a00120.html#ga2becf9a16ec20ab124ca8938e34b4aa8">01461</a> <a class="code" href="a00092.html#a938734d014fb68dd8b2251fe8ec2b025">BMFORCEINLINE</a> <span class="keywordtype">void</span> <a class="code" href="a00120.html#ga2becf9a16ec20ab124ca8938e34b4aa8" title="Set 1 bit in a block.">set_bit</a>(<span class="keywordtype">unsigned</span>* dest, <span class="keywordtype">unsigned</span>  bitpos)
<a name="l01462"></a>01462 {
<a name="l01463"></a>01463     <span class="keywordtype">unsigned</span> nbit  = unsigned(bitpos &amp; <a class="code" href="a00115.html#a201fb8b1f81b7487f1c1c129fc3d6557">bm::set_block_mask</a>); 
<a name="l01464"></a>01464     <span class="keywordtype">unsigned</span> nword = unsigned(nbit &gt;&gt; <a class="code" href="a00115.html#a83d76bccf6fe3770f32d5ba11d2a37ad">bm::set_word_shift</a>); 
<a name="l01465"></a>01465     nbit &amp;= <a class="code" href="a00115.html#addbf345be3733d5e4575d71733ed1da8">bm::set_word_mask</a>;
<a name="l01466"></a>01466     dest[nword] |= unsigned(1 &lt;&lt; nbit);
<a name="l01467"></a>01467 }
<a name="l01468"></a>01468 <span class="comment"></span>
<a name="l01469"></a>01469 <span class="comment">/*! </span>
<a name="l01470"></a>01470 <span class="comment">    \brief Test 1 bit in a block</span>
<a name="l01471"></a>01471 <span class="comment">    </span>
<a name="l01472"></a>01472 <span class="comment">    @ingroup bitfunc</span>
<a name="l01473"></a>01473 <span class="comment">*/</span>
<a name="l01474"></a><a class="code" href="a00120.html#ga9bccc586aa791f98f1bec284b799102c">01474</a> <a class="code" href="a00092.html#a938734d014fb68dd8b2251fe8ec2b025">BMFORCEINLINE</a> <span class="keywordtype">unsigned</span> <a class="code" href="a00120.html#ga9bccc586aa791f98f1bec284b799102c" title="Test 1 bit in a block.">test_bit</a>(<span class="keyword">const</span> <span class="keywordtype">unsigned</span>* block, <span class="keywordtype">unsigned</span>  bitpos)
<a name="l01475"></a>01475 {
<a name="l01476"></a>01476     <span class="keywordtype">unsigned</span> nbit  = unsigned(bitpos &amp; <a class="code" href="a00115.html#a201fb8b1f81b7487f1c1c129fc3d6557">bm::set_block_mask</a>); 
<a name="l01477"></a>01477     <span class="keywordtype">unsigned</span> nword = unsigned(nbit &gt;&gt; <a class="code" href="a00115.html#a83d76bccf6fe3770f32d5ba11d2a37ad">bm::set_word_shift</a>); 
<a name="l01478"></a>01478     nbit &amp;= <a class="code" href="a00115.html#addbf345be3733d5e4575d71733ed1da8">bm::set_word_mask</a>;
<a name="l01479"></a>01479     <span class="keywordflow">return</span> (block[nword] &gt;&gt; nbit) &amp; 1u;
<a name="l01480"></a>01480 }
<a name="l01481"></a>01481 
<a name="l01482"></a>01482 <span class="comment"></span>
<a name="l01483"></a>01483 <span class="comment">/*! </span>
<a name="l01484"></a>01484 <span class="comment">   \brief Sets bits to 1 in the bitblock.</span>
<a name="l01485"></a>01485 <span class="comment">   \param dest - Bitset buffer.</span>
<a name="l01486"></a>01486 <span class="comment">   \param bitpos - Offset of the start bit.</span>
<a name="l01487"></a>01487 <span class="comment">   \param bitcount - number of bits to set.</span>
<a name="l01488"></a>01488 <span class="comment"></span>
<a name="l01489"></a>01489 <span class="comment">   @ingroup bitfunc</span>
<a name="l01490"></a>01490 <span class="comment">*/</span>  
<a name="l01491"></a><a class="code" href="a00120.html#gad698b5242f5b629aa28e7338b7150497">01491</a> <span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="a00120.html#gad698b5242f5b629aa28e7338b7150497" title="Sets bits to 1 in the bitblock.">or_bit_block</a>(<span class="keywordtype">unsigned</span>* dest, 
<a name="l01492"></a>01492                          <span class="keywordtype">unsigned</span> bitpos, 
<a name="l01493"></a>01493                          <span class="keywordtype">unsigned</span> bitcount)
<a name="l01494"></a>01494 {
<a name="l01495"></a>01495     <span class="keywordtype">unsigned</span> nbit  = unsigned(bitpos &amp; <a class="code" href="a00115.html#a201fb8b1f81b7487f1c1c129fc3d6557">bm::set_block_mask</a>); 
<a name="l01496"></a>01496     <span class="keywordtype">unsigned</span> nword = unsigned(nbit &gt;&gt; <a class="code" href="a00115.html#a83d76bccf6fe3770f32d5ba11d2a37ad">bm::set_word_shift</a>); 
<a name="l01497"></a>01497     nbit &amp;= <a class="code" href="a00115.html#addbf345be3733d5e4575d71733ed1da8">bm::set_word_mask</a>;
<a name="l01498"></a>01498 
<a name="l01499"></a>01499     <a class="code" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a>* word = dest + nword;
<a name="l01500"></a>01500 
<a name="l01501"></a>01501     <span class="keywordflow">if</span> (bitcount == 1)  <span class="comment">// special case (only 1 bit to set)</span>
<a name="l01502"></a>01502     {
<a name="l01503"></a>01503         *word |= unsigned(1 &lt;&lt; nbit);
<a name="l01504"></a>01504         <span class="keywordflow">return</span>;
<a name="l01505"></a>01505     }
<a name="l01506"></a>01506 
<a name="l01507"></a>01507     <span class="keywordflow">if</span> (nbit) <span class="comment">// starting position is not aligned</span>
<a name="l01508"></a>01508     {
<a name="l01509"></a>01509         <span class="keywordtype">unsigned</span> right_margin = nbit + bitcount;
<a name="l01510"></a>01510 
<a name="l01511"></a>01511         <span class="comment">// here we checking if we setting bits only in the current</span>
<a name="l01512"></a>01512         <span class="comment">// word. Example: 00111000000000000000000000000000 (32 bits word)</span>
<a name="l01513"></a>01513 
<a name="l01514"></a>01514         <span class="keywordflow">if</span> (right_margin &lt; 32) 
<a name="l01515"></a>01515         {
<a name="l01516"></a>01516             <span class="keywordtype">unsigned</span> mask = 
<a name="l01517"></a>01517                 <a class="code" href="a00040.html" title="Structure keeps all-left/right ON bits masks.">block_set_table&lt;true&gt;::_right</a>[nbit] &amp; 
<a name="l01518"></a>01518                 <a class="code" href="a00040.html" title="Structure keeps all-left/right ON bits masks.">block_set_table&lt;true&gt;::_left</a>[right_margin-1];
<a name="l01519"></a>01519             *word |= mask;
<a name="l01520"></a>01520             <span class="keywordflow">return</span>; <span class="comment">// we are done</span>
<a name="l01521"></a>01521         }
<a name="l01522"></a>01522         <span class="keywordflow">else</span>
<a name="l01523"></a>01523         {
<a name="l01524"></a>01524             *word |= <a class="code" href="a00040.html" title="Structure keeps all-left/right ON bits masks.">block_set_table&lt;true&gt;::_right</a>[nbit];
<a name="l01525"></a>01525             bitcount -= 32 - nbit;
<a name="l01526"></a>01526         }
<a name="l01527"></a>01527         ++word;
<a name="l01528"></a>01528     }
<a name="l01529"></a>01529 
<a name="l01530"></a>01530     <span class="comment">// now we are word aligned, lets find out how many words we </span>
<a name="l01531"></a>01531     <span class="comment">// can now turn ON using loop</span>
<a name="l01532"></a>01532 
<a name="l01533"></a>01533     <span class="keywordflow">for</span> ( ;bitcount &gt;= 32; bitcount -= 32) 
<a name="l01534"></a>01534     {
<a name="l01535"></a>01535         *word++ = 0xffffffff;
<a name="l01536"></a>01536     }
<a name="l01537"></a>01537 
<a name="l01538"></a>01538     <span class="keywordflow">if</span> (bitcount) 
<a name="l01539"></a>01539     {
<a name="l01540"></a>01540         *word |= <a class="code" href="a00040.html" title="Structure keeps all-left/right ON bits masks.">block_set_table&lt;true&gt;::_left</a>[bitcount-1];
<a name="l01541"></a>01541     }
<a name="l01542"></a>01542 }
<a name="l01543"></a>01543 
<a name="l01544"></a>01544 <span class="comment"></span>
<a name="l01545"></a>01545 <span class="comment">/*! </span>
<a name="l01546"></a>01546 <span class="comment">   \brief SUB (AND NOT) bit interval to 1 in the bitblock.</span>
<a name="l01547"></a>01547 <span class="comment">   \param dest - Bitset buffer.</span>
<a name="l01548"></a>01548 <span class="comment">   \param bitpos - Offset of the start bit.</span>
<a name="l01549"></a>01549 <span class="comment">   \param bitcount - number of bits to set.</span>
<a name="l01550"></a>01550 <span class="comment"></span>
<a name="l01551"></a>01551 <span class="comment">   @ingroup bitfunc</span>
<a name="l01552"></a>01552 <span class="comment">*/</span>  
<a name="l01553"></a><a class="code" href="a00120.html#gaceaa54aa59b16299f5a87b925715e5e8">01553</a> <span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="a00120.html#gaceaa54aa59b16299f5a87b925715e5e8" title="SUB (AND NOT) bit interval to 1 in the bitblock.">sub_bit_block</a>(<span class="keywordtype">unsigned</span>* dest, 
<a name="l01554"></a>01554                           <span class="keywordtype">unsigned</span> bitpos, 
<a name="l01555"></a>01555                           <span class="keywordtype">unsigned</span> bitcount)
<a name="l01556"></a>01556 {
<a name="l01557"></a>01557     <span class="keywordtype">unsigned</span> nbit  = unsigned(bitpos &amp; <a class="code" href="a00115.html#a201fb8b1f81b7487f1c1c129fc3d6557">bm::set_block_mask</a>); 
<a name="l01558"></a>01558     <span class="keywordtype">unsigned</span> nword = unsigned(nbit &gt;&gt; <a class="code" href="a00115.html#a83d76bccf6fe3770f32d5ba11d2a37ad">bm::set_word_shift</a>); 
<a name="l01559"></a>01559     nbit &amp;= <a class="code" href="a00115.html#addbf345be3733d5e4575d71733ed1da8">bm::set_word_mask</a>;
<a name="l01560"></a>01560 
<a name="l01561"></a>01561     <a class="code" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a>* word = dest + nword;
<a name="l01562"></a>01562 
<a name="l01563"></a>01563     <span class="keywordflow">if</span> (bitcount == 1)  <span class="comment">// special case (only 1 bit to set)</span>
<a name="l01564"></a>01564     {
<a name="l01565"></a>01565         *word &amp;= ~unsigned(1 &lt;&lt; nbit);
<a name="l01566"></a>01566         <span class="keywordflow">return</span>;
<a name="l01567"></a>01567     }
<a name="l01568"></a>01568 
<a name="l01569"></a>01569     <span class="keywordflow">if</span> (nbit) <span class="comment">// starting position is not aligned</span>
<a name="l01570"></a>01570     {
<a name="l01571"></a>01571         <span class="keywordtype">unsigned</span> right_margin = nbit + bitcount;
<a name="l01572"></a>01572 
<a name="l01573"></a>01573         <span class="comment">// here we checking if we setting bits only in the current</span>
<a name="l01574"></a>01574         <span class="comment">// word. Example: 00111000000000000000000000000000 (32 bits word)</span>
<a name="l01575"></a>01575 
<a name="l01576"></a>01576         <span class="keywordflow">if</span> (right_margin &lt; 32) 
<a name="l01577"></a>01577         {
<a name="l01578"></a>01578             <span class="keywordtype">unsigned</span> mask = 
<a name="l01579"></a>01579                 <a class="code" href="a00040.html" title="Structure keeps all-left/right ON bits masks.">block_set_table&lt;true&gt;::_right</a>[nbit] &amp; 
<a name="l01580"></a>01580                 <a class="code" href="a00040.html" title="Structure keeps all-left/right ON bits masks.">block_set_table&lt;true&gt;::_left</a>[right_margin-1];
<a name="l01581"></a>01581             *word &amp;= ~mask;
<a name="l01582"></a>01582             <span class="keywordflow">return</span>; <span class="comment">// we are done</span>
<a name="l01583"></a>01583         }
<a name="l01584"></a>01584         <span class="keywordflow">else</span>
<a name="l01585"></a>01585         {
<a name="l01586"></a>01586             *word &amp;= ~<a class="code" href="a00040.html" title="Structure keeps all-left/right ON bits masks.">block_set_table&lt;true&gt;::_right</a>[nbit];
<a name="l01587"></a>01587             bitcount -= 32 - nbit;
<a name="l01588"></a>01588         }
<a name="l01589"></a>01589         ++word;
<a name="l01590"></a>01590     }
<a name="l01591"></a>01591 
<a name="l01592"></a>01592     <span class="comment">// now we are word aligned, lets find out how many words we </span>
<a name="l01593"></a>01593     <span class="comment">// can now turn ON using loop</span>
<a name="l01594"></a>01594 
<a name="l01595"></a>01595     <span class="keywordflow">for</span> ( ;bitcount &gt;= 32; bitcount -= 32) 
<a name="l01596"></a>01596     {
<a name="l01597"></a>01597         *word++ = 0;
<a name="l01598"></a>01598     }
<a name="l01599"></a>01599 
<a name="l01600"></a>01600     <span class="keywordflow">if</span> (bitcount) 
<a name="l01601"></a>01601     {
<a name="l01602"></a>01602         *word &amp;= ~<a class="code" href="a00040.html" title="Structure keeps all-left/right ON bits masks.">block_set_table&lt;true&gt;::_left</a>[bitcount-1];
<a name="l01603"></a>01603     }
<a name="l01604"></a>01604 }
<a name="l01605"></a>01605 
<a name="l01606"></a>01606 <span class="comment"></span>
<a name="l01607"></a>01607 <span class="comment">/*! </span>
<a name="l01608"></a>01608 <span class="comment">   \brief XOR bit interval to 1 in the bitblock.</span>
<a name="l01609"></a>01609 <span class="comment">   \param dest - Bitset buffer.</span>
<a name="l01610"></a>01610 <span class="comment">   \param bitpos - Offset of the start bit.</span>
<a name="l01611"></a>01611 <span class="comment">   \param bitcount - number of bits to set.</span>
<a name="l01612"></a>01612 <span class="comment"></span>
<a name="l01613"></a>01613 <span class="comment">   @ingroup bitfunc</span>
<a name="l01614"></a>01614 <span class="comment">*/</span>  
<a name="l01615"></a><a class="code" href="a00120.html#ga6191abb017003b633fab24e0c6357521">01615</a> <span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="a00120.html#ga6191abb017003b633fab24e0c6357521" title="XOR bit interval to 1 in the bitblock.">xor_bit_block</a>(<span class="keywordtype">unsigned</span>* dest, 
<a name="l01616"></a>01616                           <span class="keywordtype">unsigned</span> bitpos, 
<a name="l01617"></a>01617                           <span class="keywordtype">unsigned</span> bitcount)
<a name="l01618"></a>01618 {
<a name="l01619"></a>01619     <span class="keywordtype">unsigned</span> nbit  = unsigned(bitpos &amp; <a class="code" href="a00115.html#a201fb8b1f81b7487f1c1c129fc3d6557">bm::set_block_mask</a>); 
<a name="l01620"></a>01620     <span class="keywordtype">unsigned</span> nword = unsigned(nbit &gt;&gt; <a class="code" href="a00115.html#a83d76bccf6fe3770f32d5ba11d2a37ad">bm::set_word_shift</a>); 
<a name="l01621"></a>01621     nbit &amp;= <a class="code" href="a00115.html#addbf345be3733d5e4575d71733ed1da8">bm::set_word_mask</a>;
<a name="l01622"></a>01622 
<a name="l01623"></a>01623     <a class="code" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a>* word = dest + nword;
<a name="l01624"></a>01624 
<a name="l01625"></a>01625     <span class="keywordflow">if</span> (bitcount == 1)  <span class="comment">// special case (only 1 bit to set)</span>
<a name="l01626"></a>01626     {
<a name="l01627"></a>01627         *word ^= unsigned(1 &lt;&lt; nbit);
<a name="l01628"></a>01628         <span class="keywordflow">return</span>;                             
<a name="l01629"></a>01629     }
<a name="l01630"></a>01630 
<a name="l01631"></a>01631     <span class="keywordflow">if</span> (nbit) <span class="comment">// starting position is not aligned</span>
<a name="l01632"></a>01632     {
<a name="l01633"></a>01633         <span class="keywordtype">unsigned</span> right_margin = nbit + bitcount;
<a name="l01634"></a>01634 
<a name="l01635"></a>01635         <span class="comment">// here we checking if we setting bits only in the current</span>
<a name="l01636"></a>01636         <span class="comment">// word. Example: 00111000000000000000000000000000 (32 bits word)</span>
<a name="l01637"></a>01637 
<a name="l01638"></a>01638         <span class="keywordflow">if</span> (right_margin &lt; 32) 
<a name="l01639"></a>01639         {
<a name="l01640"></a>01640             <span class="keywordtype">unsigned</span> mask = 
<a name="l01641"></a>01641                 <a class="code" href="a00040.html" title="Structure keeps all-left/right ON bits masks.">block_set_table&lt;true&gt;::_right</a>[nbit] &amp; 
<a name="l01642"></a>01642                 <a class="code" href="a00040.html" title="Structure keeps all-left/right ON bits masks.">block_set_table&lt;true&gt;::_left</a>[right_margin-1];
<a name="l01643"></a>01643             *word ^= mask;
<a name="l01644"></a>01644             <span class="keywordflow">return</span>; <span class="comment">// we are done</span>
<a name="l01645"></a>01645         }
<a name="l01646"></a>01646         <span class="keywordflow">else</span>
<a name="l01647"></a>01647         {
<a name="l01648"></a>01648             *word ^= <a class="code" href="a00040.html" title="Structure keeps all-left/right ON bits masks.">block_set_table&lt;true&gt;::_right</a>[nbit];
<a name="l01649"></a>01649             bitcount -= 32 - nbit;
<a name="l01650"></a>01650         }
<a name="l01651"></a>01651         ++word;
<a name="l01652"></a>01652     }
<a name="l01653"></a>01653 
<a name="l01654"></a>01654     <span class="comment">// now we are word aligned, lets find out how many words we </span>
<a name="l01655"></a>01655     <span class="comment">// can now turn ON using loop</span>
<a name="l01656"></a>01656 
<a name="l01657"></a>01657     <span class="keywordflow">for</span> ( ;bitcount &gt;= 32; bitcount -= 32) 
<a name="l01658"></a>01658     {
<a name="l01659"></a>01659         *word++ ^= 0xffffffff;
<a name="l01660"></a>01660     }
<a name="l01661"></a>01661 
<a name="l01662"></a>01662     <span class="keywordflow">if</span> (bitcount) 
<a name="l01663"></a>01663     {
<a name="l01664"></a>01664         *word ^= <a class="code" href="a00040.html" title="Structure keeps all-left/right ON bits masks.">block_set_table&lt;true&gt;::_left</a>[bitcount-1];
<a name="l01665"></a>01665     }
<a name="l01666"></a>01666 }
<a name="l01667"></a>01667 
<a name="l01668"></a>01668 <span class="comment"></span>
<a name="l01669"></a>01669 <span class="comment">/*!</span>
<a name="l01670"></a>01670 <span class="comment">   \brief SUB (AND NOT) GAP block to bitblock.</span>
<a name="l01671"></a>01671 <span class="comment">   \param dest - bitblock buffer pointer.</span>
<a name="l01672"></a>01672 <span class="comment">   \param buf  - GAP buffer pointer.</span>
<a name="l01673"></a>01673 <span class="comment"></span>
<a name="l01674"></a>01674 <span class="comment">   @ingroup gapfunc</span>
<a name="l01675"></a>01675 <span class="comment">*/</span>
<a name="l01676"></a>01676 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; 
<a name="l01677"></a><a class="code" href="a00119.html#gabcedad4aea1a503c30f10e6d09b523f2">01677</a> <span class="keywordtype">void</span> <a class="code" href="a00119.html#gabcedad4aea1a503c30f10e6d09b523f2" title="SUB (AND NOT) GAP block to bitblock.">gap_sub_to_bitset</a>(<span class="keywordtype">unsigned</span>* BMRESTRICT dest, <span class="keyword">const</span> T* BMRESTRICT buf)
<a name="l01678"></a>01678 {
<a name="l01679"></a>01679     <span class="keyword">const</span> T* pend = buf + (*buf &gt;&gt; 3);
<a name="l01680"></a>01680     T b = *buf &amp; 1;
<a name="l01681"></a>01681     ++buf;
<a name="l01682"></a>01682 
<a name="l01683"></a>01683     <span class="keywordflow">if</span> (b)  <span class="comment">// Starts with 1</span>
<a name="l01684"></a>01684     {
<a name="l01685"></a>01685         <a class="code" href="a00120.html#gaceaa54aa59b16299f5a87b925715e5e8" title="SUB (AND NOT) bit interval to 1 in the bitblock.">sub_bit_block</a>(dest, 0, *buf + 1);
<a name="l01686"></a>01686         ++buf;
<a name="l01687"></a>01687     }
<a name="l01688"></a>01688     <span class="keywordflow">for</span> (++buf; buf &lt;= pend; buf += 2)
<a name="l01689"></a>01689     {
<a name="l01690"></a>01690         T prev = *(buf-1);
<a name="l01691"></a>01691         <a class="code" href="a00092.html#aa44515fab0ace8928d1cb82009a95bf8">BM_ASSERT</a>(*buf &gt; prev);
<a name="l01692"></a>01692         <a class="code" href="a00120.html#gaceaa54aa59b16299f5a87b925715e5e8" title="SUB (AND NOT) bit interval to 1 in the bitblock.">sub_bit_block</a>(dest, prev + 1, *buf - prev);
<a name="l01693"></a>01693     }
<a name="l01694"></a>01694 }
<a name="l01695"></a>01695 
<a name="l01696"></a>01696 <span class="comment"></span>
<a name="l01697"></a>01697 <span class="comment">/*!</span>
<a name="l01698"></a>01698 <span class="comment">   \brief XOR GAP block to bitblock.</span>
<a name="l01699"></a>01699 <span class="comment">   \param dest - bitblock buffer pointer.</span>
<a name="l01700"></a>01700 <span class="comment">   \param buf  - GAP buffer pointer.</span>
<a name="l01701"></a>01701 <span class="comment"></span>
<a name="l01702"></a>01702 <span class="comment">   @ingroup gapfunc</span>
<a name="l01703"></a>01703 <span class="comment">*/</span>
<a name="l01704"></a>01704 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; 
<a name="l01705"></a><a class="code" href="a00119.html#ga63c33428c2f5eac9f69d663203cd2172">01705</a> <span class="keywordtype">void</span> <a class="code" href="a00119.html#ga63c33428c2f5eac9f69d663203cd2172" title="XOR GAP block to bitblock.">gap_xor_to_bitset</a>(<span class="keywordtype">unsigned</span>* BMRESTRICT dest, <span class="keyword">const</span> T* BMRESTRICT buf)
<a name="l01706"></a>01706 {
<a name="l01707"></a>01707     <span class="keyword">const</span> T* pend = buf + (*buf &gt;&gt; 3);
<a name="l01708"></a>01708     T b = *buf &amp; 1;
<a name="l01709"></a>01709     ++buf;
<a name="l01710"></a>01710 
<a name="l01711"></a>01711     <span class="keywordflow">if</span> (b)  <span class="comment">// Starts with 1</span>
<a name="l01712"></a>01712     {
<a name="l01713"></a>01713         <a class="code" href="a00120.html#ga6191abb017003b633fab24e0c6357521" title="XOR bit interval to 1 in the bitblock.">xor_bit_block</a>(dest, 0, *buf + 1);
<a name="l01714"></a>01714         ++buf;
<a name="l01715"></a>01715     }
<a name="l01716"></a>01716     <span class="keywordflow">for</span> (++buf; buf &lt;= pend; buf += 2)
<a name="l01717"></a>01717     {
<a name="l01718"></a>01718         T prev = *(buf-1);
<a name="l01719"></a>01719         <a class="code" href="a00092.html#aa44515fab0ace8928d1cb82009a95bf8">BM_ASSERT</a>(*buf &gt; prev);
<a name="l01720"></a>01720         <a class="code" href="a00120.html#ga6191abb017003b633fab24e0c6357521" title="XOR bit interval to 1 in the bitblock.">xor_bit_block</a>(dest, prev + 1, *buf - prev);
<a name="l01721"></a>01721     }
<a name="l01722"></a>01722 }
<a name="l01723"></a>01723 <span class="comment"></span>
<a name="l01724"></a>01724 <span class="comment">/*!</span>
<a name="l01725"></a>01725 <span class="comment">\brief Adds(OR) GAP block to bitblock.</span>
<a name="l01726"></a>01726 <span class="comment">\param dest - bitblock buffer pointer.</span>
<a name="l01727"></a>01727 <span class="comment">\param buf  - GAP buffer pointer.</span>
<a name="l01728"></a>01728 <span class="comment">\param buf_len - GAP buffer length</span>
<a name="l01729"></a>01729 <span class="comment"></span>
<a name="l01730"></a>01730 <span class="comment">@ingroup gapfunc</span>
<a name="l01731"></a>01731 <span class="comment">*/</span>
<a name="l01732"></a>01732 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; 
<a name="l01733"></a><a class="code" href="a00119.html#ga78510a39b6e8c6b8904ecbffb6ab215b">01733</a> <span class="keywordtype">void</span> <a class="code" href="a00119.html#ga78510a39b6e8c6b8904ecbffb6ab215b" title="Adds(OR) GAP block to bitblock.">gap_add_to_bitset_l</a>(<span class="keywordtype">unsigned</span>* dest, <span class="keyword">const</span> T*  buf, <span class="keywordtype">unsigned</span> buf_len)
<a name="l01734"></a>01734 {
<a name="l01735"></a>01735     <a class="code" href="a00092.html#aa44515fab0ace8928d1cb82009a95bf8">BM_ASSERT</a>(buf_len);
<a name="l01736"></a>01736     <span class="keyword">register</span> <span class="keyword">const</span> T* pend = buf + buf_len;
<a name="l01737"></a>01737     T b = *buf &amp; 1;
<a name="l01738"></a>01738     ++buf;
<a name="l01739"></a>01739 
<a name="l01740"></a>01740     <span class="keywordflow">if</span> (b)  <span class="comment">// Starts with 1</span>
<a name="l01741"></a>01741     {
<a name="l01742"></a>01742         <a class="code" href="a00120.html#gad698b5242f5b629aa28e7338b7150497" title="Sets bits to 1 in the bitblock.">or_bit_block</a>(dest, 0, *buf + 1);
<a name="l01743"></a>01743         ++buf;
<a name="l01744"></a>01744     }
<a name="l01745"></a>01745     <span class="keywordflow">for</span> (++buf; buf &lt;= pend; buf += 2)
<a name="l01746"></a>01746     {
<a name="l01747"></a>01747         T prev = *(buf-1);
<a name="l01748"></a>01748         <a class="code" href="a00092.html#aa44515fab0ace8928d1cb82009a95bf8">BM_ASSERT</a>(*buf &gt; prev);
<a name="l01749"></a>01749         <a class="code" href="a00120.html#gad698b5242f5b629aa28e7338b7150497" title="Sets bits to 1 in the bitblock.">or_bit_block</a>(dest, prev + 1, *buf - prev);
<a name="l01750"></a>01750     }
<a name="l01751"></a>01751 }
<a name="l01752"></a>01752 
<a name="l01753"></a>01753 
<a name="l01754"></a>01754 <span class="comment"></span>
<a name="l01755"></a>01755 <span class="comment">/*!</span>
<a name="l01756"></a>01756 <span class="comment">   \brief Adds(OR) GAP block to bitblock.</span>
<a name="l01757"></a>01757 <span class="comment">   \param dest - bitblock buffer pointer.</span>
<a name="l01758"></a>01758 <span class="comment">   \param buf  - GAP buffer pointer.</span>
<a name="l01759"></a>01759 <span class="comment"></span>
<a name="l01760"></a>01760 <span class="comment">   @ingroup gapfunc</span>
<a name="l01761"></a>01761 <span class="comment">*/</span>
<a name="l01762"></a>01762 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; 
<a name="l01763"></a><a class="code" href="a00119.html#ga12615cd62f2e5367e1bc688d00a2188f">01763</a> <span class="keywordtype">void</span> <a class="code" href="a00119.html#ga12615cd62f2e5367e1bc688d00a2188f" title="Adds(OR) GAP block to bitblock.">gap_add_to_bitset</a>(<span class="keywordtype">unsigned</span>* dest, <span class="keyword">const</span> T*  buf)
<a name="l01764"></a>01764 {
<a name="l01765"></a>01765     <a class="code" href="a00119.html#ga78510a39b6e8c6b8904ecbffb6ab215b" title="Adds(OR) GAP block to bitblock.">gap_add_to_bitset_l</a>(dest, buf, *buf &gt;&gt; 3);
<a name="l01766"></a>01766 }
<a name="l01767"></a>01767 
<a name="l01768"></a>01768 <span class="comment"></span>
<a name="l01769"></a>01769 <span class="comment">/*!</span>
<a name="l01770"></a>01770 <span class="comment">   \brief ANDs GAP block to bitblock.</span>
<a name="l01771"></a>01771 <span class="comment">   \param dest - bitblock buffer pointer.</span>
<a name="l01772"></a>01772 <span class="comment">   \param buf  - GAP buffer pointer.</span>
<a name="l01773"></a>01773 <span class="comment"></span>
<a name="l01774"></a>01774 <span class="comment">   @ingroup gapfunc</span>
<a name="l01775"></a>01775 <span class="comment">*/</span>
<a name="l01776"></a>01776 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; 
<a name="l01777"></a><a class="code" href="a00119.html#gafe6f72a009618290eeab3cddee869543">01777</a> <span class="keywordtype">void</span> <a class="code" href="a00119.html#gafe6f72a009618290eeab3cddee869543" title="ANDs GAP block to bitblock.">gap_and_to_bitset</a>(<span class="keywordtype">unsigned</span>* dest, <span class="keyword">const</span> T*  buf)
<a name="l01778"></a>01778 {
<a name="l01779"></a>01779     <span class="keyword">register</span> <span class="keyword">const</span> T* pend = buf + (*buf &gt;&gt; 3);
<a name="l01780"></a>01780     T b = *buf &amp; 1;
<a name="l01781"></a>01781     ++buf;
<a name="l01782"></a>01782 
<a name="l01783"></a>01783     <span class="keywordflow">if</span> (!b )  <span class="comment">// Starts with 0 </span>
<a name="l01784"></a>01784     {
<a name="l01785"></a>01785         <span class="comment">// Instead of AND we can SUB 0 gaps here </span>
<a name="l01786"></a>01786         <a class="code" href="a00120.html#gaceaa54aa59b16299f5a87b925715e5e8" title="SUB (AND NOT) bit interval to 1 in the bitblock.">sub_bit_block</a>(dest, 0, *buf + 1);
<a name="l01787"></a>01787         ++buf;
<a name="l01788"></a>01788     }
<a name="l01789"></a>01789     <span class="keywordflow">for</span> (++buf; buf &lt;= pend; buf += 2)
<a name="l01790"></a>01790     {
<a name="l01791"></a>01791         T prev = *(buf-1);
<a name="l01792"></a>01792         <a class="code" href="a00092.html#aa44515fab0ace8928d1cb82009a95bf8">BM_ASSERT</a>(*buf &gt; prev);
<a name="l01793"></a>01793         <a class="code" href="a00120.html#gaceaa54aa59b16299f5a87b925715e5e8" title="SUB (AND NOT) bit interval to 1 in the bitblock.">sub_bit_block</a>(dest, prev + 1, *buf - prev);
<a name="l01794"></a>01794     }
<a name="l01795"></a>01795 }
<a name="l01796"></a>01796 
<a name="l01797"></a>01797 <span class="comment"></span>
<a name="l01798"></a>01798 <span class="comment">/*!</span>
<a name="l01799"></a>01799 <span class="comment">   \brief Compute bitcount of bit block AND masked by GAP block.</span>
<a name="l01800"></a>01800 <span class="comment">   \param dest - bitblock buffer pointer.</span>
<a name="l01801"></a>01801 <span class="comment">   \param buf  - GAP buffer pointer.</span>
<a name="l01802"></a>01802 <span class="comment"></span>
<a name="l01803"></a>01803 <span class="comment">   @ingroup gapfunc bitfunc</span>
<a name="l01804"></a>01804 <span class="comment">*/</span>
<a name="l01805"></a>01805 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; 
<a name="l01806"></a><a class="code" href="a00120.html#gab87384cbf46a04d86c008ab2463d02cc">01806</a> <a class="code" href="a00115.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a> <a class="code" href="a00120.html#gab87384cbf46a04d86c008ab2463d02cc" title="Compute bitcount of bit block AND masked by GAP block.">gap_bitset_and_count</a>(<span class="keyword">const</span> <span class="keywordtype">unsigned</span>* block, <span class="keyword">const</span> T*  buf)
<a name="l01807"></a>01807 {
<a name="l01808"></a>01808     <a class="code" href="a00092.html#aa44515fab0ace8928d1cb82009a95bf8">BM_ASSERT</a>(block);
<a name="l01809"></a>01809 
<a name="l01810"></a>01810     <span class="keyword">const</span> T* pcurr = buf;    
<a name="l01811"></a>01811     <span class="keyword">const</span> T* pend = pcurr + (*pcurr &gt;&gt; 3);
<a name="l01812"></a>01812     ++pcurr;
<a name="l01813"></a>01813 
<a name="l01814"></a>01814     <a class="code" href="a00115.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a> count = 0;
<a name="l01815"></a>01815     <span class="keywordflow">if</span> (*buf &amp; 1)  <span class="comment">// Starts with 1</span>
<a name="l01816"></a>01816     {
<a name="l01817"></a>01817         count += <a class="code" href="a00120.html#ga2485f707b2629c5ce7681cf9fe385b91">bit_block_calc_count_range</a>(block, 0, *pcurr);
<a name="l01818"></a>01818         ++pcurr;
<a name="l01819"></a>01819     }
<a name="l01820"></a>01820     ++pcurr; <span class="comment">// now we are in GAP &quot;1&quot; again</span>
<a name="l01821"></a>01821     <span class="keywordflow">for</span> (;pcurr &lt;= pend; pcurr += 2)
<a name="l01822"></a>01822     {
<a name="l01823"></a>01823         count += <a class="code" href="a00120.html#ga2485f707b2629c5ce7681cf9fe385b91">bit_block_calc_count_range</a>(block, *(pcurr-1)+1, *pcurr);
<a name="l01824"></a>01824     }
<a name="l01825"></a>01825     <span class="keywordflow">return</span> count;
<a name="l01826"></a>01826 }
<a name="l01827"></a>01827 
<a name="l01828"></a>01828 <span class="comment"></span>
<a name="l01829"></a>01829 <span class="comment">/*!</span>
<a name="l01830"></a>01830 <span class="comment">   \brief Bitcount test of bit block AND masked by GAP block.</span>
<a name="l01831"></a>01831 <span class="comment">   \param dest - bitblock buffer pointer.</span>
<a name="l01832"></a>01832 <span class="comment">   \param buf  - GAP buffer pointer.</span>
<a name="l01833"></a>01833 <span class="comment"></span>
<a name="l01834"></a>01834 <span class="comment">   @ingroup gapfunc bitfunc</span>
<a name="l01835"></a>01835 <span class="comment">*/</span>
<a name="l01836"></a>01836 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; 
<a name="l01837"></a><a class="code" href="a00120.html#gad6e40898b8836ae1923b06a3d028fcaa">01837</a> <a class="code" href="a00115.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a> <a class="code" href="a00120.html#gad6e40898b8836ae1923b06a3d028fcaa" title="Bitcount test of bit block AND masked by GAP block.">gap_bitset_and_any</a>(<span class="keyword">const</span> <span class="keywordtype">unsigned</span>* block, <span class="keyword">const</span> T*  buf)
<a name="l01838"></a>01838 {
<a name="l01839"></a>01839     <a class="code" href="a00092.html#aa44515fab0ace8928d1cb82009a95bf8">BM_ASSERT</a>(block);
<a name="l01840"></a>01840 
<a name="l01841"></a>01841     <span class="keyword">register</span> <span class="keyword">const</span> T* pcurr = buf;    
<a name="l01842"></a>01842     <span class="keyword">register</span> <span class="keyword">const</span> T* pend = pcurr + (*pcurr &gt;&gt; 3);
<a name="l01843"></a>01843     ++pcurr;
<a name="l01844"></a>01844 
<a name="l01845"></a>01845     <a class="code" href="a00115.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a> count = 0;
<a name="l01846"></a>01846     <span class="keywordflow">if</span> (*buf &amp; 1)  <span class="comment">// Starts with 1</span>
<a name="l01847"></a>01847     {
<a name="l01848"></a>01848         count += <a class="code" href="a00120.html#ga503e0f3e79f819d9b58e4b0e905be116">bit_block_any_range</a>(block, 0, *pcurr);
<a name="l01849"></a>01849         <span class="keywordflow">if</span> (count)
<a name="l01850"></a>01850             <span class="keywordflow">return</span> count;
<a name="l01851"></a>01851         ++pcurr;
<a name="l01852"></a>01852     }
<a name="l01853"></a>01853     ++pcurr; <span class="comment">// now we are in GAP &quot;1&quot; again</span>
<a name="l01854"></a>01854 
<a name="l01855"></a>01855     <span class="keywordflow">while</span> (pcurr &lt;= pend)
<a name="l01856"></a>01856     {
<a name="l01857"></a>01857         <a class="code" href="a00115.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a> c = <a class="code" href="a00120.html#ga503e0f3e79f819d9b58e4b0e905be116">bit_block_any_range</a>(block, *(pcurr-1)+1, *pcurr);
<a name="l01858"></a>01858         count += c;
<a name="l01859"></a>01859         <span class="keywordflow">if</span> (count)
<a name="l01860"></a>01860             <span class="keywordflow">break</span>;
<a name="l01861"></a>01861         pcurr += 2;
<a name="l01862"></a>01862     }
<a name="l01863"></a>01863     <span class="keywordflow">return</span> count;
<a name="l01864"></a>01864 }
<a name="l01865"></a>01865 
<a name="l01866"></a>01866 
<a name="l01867"></a>01867 <span class="comment"></span>
<a name="l01868"></a>01868 <span class="comment">/*!</span>
<a name="l01869"></a>01869 <span class="comment">   \brief Compute bitcount of bit block SUB masked by GAP block.</span>
<a name="l01870"></a>01870 <span class="comment">   \param dest - bitblock buffer pointer.</span>
<a name="l01871"></a>01871 <span class="comment">   \param buf  - GAP buffer pointer.</span>
<a name="l01872"></a>01872 <span class="comment"></span>
<a name="l01873"></a>01873 <span class="comment">   @ingroup gapfunc bitfunc</span>
<a name="l01874"></a>01874 <span class="comment">*/</span>
<a name="l01875"></a>01875 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; 
<a name="l01876"></a><a class="code" href="a00120.html#ga15a780da58d5aeb67ffc51c84fa6152e">01876</a> <a class="code" href="a00115.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a> <a class="code" href="a00120.html#ga15a780da58d5aeb67ffc51c84fa6152e" title="Compute bitcount of bit block SUB masked by GAP block.">gap_bitset_sub_count</a>(<span class="keyword">const</span> <span class="keywordtype">unsigned</span>* block, <span class="keyword">const</span> T*  buf)
<a name="l01877"></a>01877 {
<a name="l01878"></a>01878     <a class="code" href="a00092.html#aa44515fab0ace8928d1cb82009a95bf8">BM_ASSERT</a>(block);
<a name="l01879"></a>01879 
<a name="l01880"></a>01880     <span class="keyword">register</span> <span class="keyword">const</span> T* pcurr = buf;    
<a name="l01881"></a>01881     <span class="keyword">register</span> <span class="keyword">const</span> T* pend = pcurr + (*pcurr &gt;&gt; 3);
<a name="l01882"></a>01882     ++pcurr;
<a name="l01883"></a>01883 
<a name="l01884"></a>01884     <a class="code" href="a00115.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a> count = 0;
<a name="l01885"></a>01885 
<a name="l01886"></a>01886     <span class="keywordflow">if</span> (!(*buf &amp; 1))  <span class="comment">// Starts with 0</span>
<a name="l01887"></a>01887     {
<a name="l01888"></a>01888         count += <a class="code" href="a00120.html#ga2485f707b2629c5ce7681cf9fe385b91">bit_block_calc_count_range</a>(block, 0, *pcurr);
<a name="l01889"></a>01889         ++pcurr;
<a name="l01890"></a>01890     }
<a name="l01891"></a>01891     ++pcurr; <span class="comment">// now we are in GAP &quot;0&quot; again</span>
<a name="l01892"></a>01892 
<a name="l01893"></a>01893     <span class="keywordflow">for</span> (;pcurr &lt;= pend; pcurr+=2)
<a name="l01894"></a>01894     {
<a name="l01895"></a>01895         count += <a class="code" href="a00120.html#ga2485f707b2629c5ce7681cf9fe385b91">bit_block_calc_count_range</a>(block, *(pcurr-1)+1, *pcurr);
<a name="l01896"></a>01896     }
<a name="l01897"></a>01897     <span class="keywordflow">return</span> count;
<a name="l01898"></a>01898 }
<a name="l01899"></a>01899 
<a name="l01900"></a>01900 <span class="comment"></span>
<a name="l01901"></a>01901 <span class="comment">/*!</span>
<a name="l01902"></a>01902 <span class="comment">   \brief Compute bitcount test of bit block SUB masked by GAP block.</span>
<a name="l01903"></a>01903 <span class="comment">   \param dest - bitblock buffer pointer.</span>
<a name="l01904"></a>01904 <span class="comment">   \param buf  - GAP buffer pointer.</span>
<a name="l01905"></a>01905 <span class="comment"></span>
<a name="l01906"></a>01906 <span class="comment">   @ingroup gapfunc bitfunc</span>
<a name="l01907"></a>01907 <span class="comment">*/</span>
<a name="l01908"></a>01908 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; 
<a name="l01909"></a><a class="code" href="a00120.html#gaab7c711122e8f189555dffd83a21111c">01909</a> <a class="code" href="a00115.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a> <a class="code" href="a00120.html#gaab7c711122e8f189555dffd83a21111c" title="Compute bitcount test of bit block SUB masked by GAP block.">gap_bitset_sub_any</a>(<span class="keyword">const</span> <span class="keywordtype">unsigned</span>* block, <span class="keyword">const</span> T*  buf)
<a name="l01910"></a>01910 {
<a name="l01911"></a>01911     <a class="code" href="a00092.html#aa44515fab0ace8928d1cb82009a95bf8">BM_ASSERT</a>(block);
<a name="l01912"></a>01912 
<a name="l01913"></a>01913     <span class="keyword">register</span> <span class="keyword">const</span> T* pcurr = buf;    
<a name="l01914"></a>01914     <span class="keyword">register</span> <span class="keyword">const</span> T* pend = pcurr + (*pcurr &gt;&gt; 3);
<a name="l01915"></a>01915     ++pcurr;
<a name="l01916"></a>01916 
<a name="l01917"></a>01917     <a class="code" href="a00115.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a> count = 0;
<a name="l01918"></a>01918 
<a name="l01919"></a>01919     <span class="keywordflow">if</span> (!(*buf &amp; 1))  <span class="comment">// Starts with 0</span>
<a name="l01920"></a>01920     {
<a name="l01921"></a>01921         count += <a class="code" href="a00120.html#ga503e0f3e79f819d9b58e4b0e905be116">bit_block_any_range</a>(block, 0, *pcurr);
<a name="l01922"></a>01922         <span class="keywordflow">if</span> (count)
<a name="l01923"></a>01923             <span class="keywordflow">return</span> count;
<a name="l01924"></a>01924         ++pcurr;
<a name="l01925"></a>01925     }
<a name="l01926"></a>01926     ++pcurr; <span class="comment">// now we are in GAP &quot;0&quot; again</span>
<a name="l01927"></a>01927 
<a name="l01928"></a>01928     <span class="keywordflow">for</span> (;pcurr &lt;= pend; pcurr+=2)
<a name="l01929"></a>01929     {
<a name="l01930"></a>01930         count += <a class="code" href="a00120.html#ga503e0f3e79f819d9b58e4b0e905be116">bit_block_any_range</a>(block, *(pcurr-1)+1, *pcurr);
<a name="l01931"></a>01931         <span class="keywordflow">if</span> (count)
<a name="l01932"></a>01932             <span class="keywordflow">return</span> count;
<a name="l01933"></a>01933     }
<a name="l01934"></a>01934     <span class="keywordflow">return</span> count;
<a name="l01935"></a>01935 }
<a name="l01936"></a>01936 
<a name="l01937"></a>01937 
<a name="l01938"></a>01938 <span class="comment"></span>
<a name="l01939"></a>01939 <span class="comment">/*!</span>
<a name="l01940"></a>01940 <span class="comment">   \brief Compute bitcount of bit block XOR masked by GAP block.</span>
<a name="l01941"></a>01941 <span class="comment">   \param dest - bitblock buffer pointer.</span>
<a name="l01942"></a>01942 <span class="comment">   \param buf  - GAP buffer pointer.</span>
<a name="l01943"></a>01943 <span class="comment"></span>
<a name="l01944"></a>01944 <span class="comment">   @ingroup gapfunc bitfunc</span>
<a name="l01945"></a>01945 <span class="comment">*/</span>
<a name="l01946"></a>01946 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; 
<a name="l01947"></a><a class="code" href="a00120.html#ga803fbc7c790f07b14175303e524bd2d8">01947</a> <a class="code" href="a00115.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a> <a class="code" href="a00120.html#ga803fbc7c790f07b14175303e524bd2d8" title="Compute bitcount of bit block XOR masked by GAP block.">gap_bitset_xor_count</a>(<span class="keyword">const</span> <span class="keywordtype">unsigned</span>* block, <span class="keyword">const</span> T*  buf)
<a name="l01948"></a>01948 {
<a name="l01949"></a>01949     <a class="code" href="a00092.html#aa44515fab0ace8928d1cb82009a95bf8">BM_ASSERT</a>(block);
<a name="l01950"></a>01950 
<a name="l01951"></a>01951     <span class="keyword">register</span> <span class="keyword">const</span> T* pcurr = buf;    
<a name="l01952"></a>01952     <span class="keyword">register</span> <span class="keyword">const</span> T* pend = pcurr + (*pcurr &gt;&gt; 3);
<a name="l01953"></a>01953     ++pcurr;
<a name="l01954"></a>01954 
<a name="l01955"></a>01955     <span class="keywordtype">unsigned</span> bitval = *buf &amp; 1;
<a name="l01956"></a>01956     
<a name="l01957"></a>01957     <span class="keyword">register</span> <a class="code" href="a00115.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a> count = <a class="code" href="a00120.html#ga2485f707b2629c5ce7681cf9fe385b91">bit_block_calc_count_range</a>(block, 0, *pcurr);
<a name="l01958"></a>01958     <span class="keywordflow">if</span> (bitval)
<a name="l01959"></a>01959     {
<a name="l01960"></a>01960         count = *pcurr + 1 - count;
<a name="l01961"></a>01961     }
<a name="l01962"></a>01962     
<a name="l01963"></a>01963     <span class="keywordflow">for</span> (bitval^=1, ++pcurr; pcurr &lt;= pend; bitval^=1, ++pcurr)
<a name="l01964"></a>01964     {
<a name="l01965"></a>01965         T prev = *(pcurr-1)+1;
<a name="l01966"></a>01966         <a class="code" href="a00115.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a> c = <a class="code" href="a00120.html#ga2485f707b2629c5ce7681cf9fe385b91">bit_block_calc_count_range</a>(block, prev, *pcurr);
<a name="l01967"></a>01967         
<a name="l01968"></a>01968         <span class="keywordflow">if</span> (bitval) <span class="comment">// 1 gap; means Result = Total_Bits - BitCount;</span>
<a name="l01969"></a>01969         {
<a name="l01970"></a>01970             c = (*pcurr - prev + 1) - c;
<a name="l01971"></a>01971         }
<a name="l01972"></a>01972         count += c;
<a name="l01973"></a>01973     }
<a name="l01974"></a>01974     <span class="keywordflow">return</span> count;
<a name="l01975"></a>01975 }
<a name="l01976"></a>01976 <span class="comment"></span>
<a name="l01977"></a>01977 <span class="comment">/*!</span>
<a name="l01978"></a>01978 <span class="comment">   \brief Compute bitcount test of bit block XOR masked by GAP block.</span>
<a name="l01979"></a>01979 <span class="comment">   \param dest - bitblock buffer pointer.</span>
<a name="l01980"></a>01980 <span class="comment">   \param buf  - GAP buffer pointer.</span>
<a name="l01981"></a>01981 <span class="comment"></span>
<a name="l01982"></a>01982 <span class="comment">   @ingroup gapfunc bitfunc</span>
<a name="l01983"></a>01983 <span class="comment">*/</span>
<a name="l01984"></a>01984 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; 
<a name="l01985"></a><a class="code" href="a00120.html#gad0f7ee00f84ea357d55e6a2f507c8918">01985</a> <a class="code" href="a00115.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a> <a class="code" href="a00120.html#gad0f7ee00f84ea357d55e6a2f507c8918" title="Compute bitcount test of bit block XOR masked by GAP block.">gap_bitset_xor_any</a>(<span class="keyword">const</span> <span class="keywordtype">unsigned</span>* block, <span class="keyword">const</span> T*  buf)
<a name="l01986"></a>01986 {
<a name="l01987"></a>01987     <a class="code" href="a00092.html#aa44515fab0ace8928d1cb82009a95bf8">BM_ASSERT</a>(block);
<a name="l01988"></a>01988 
<a name="l01989"></a>01989     <span class="keyword">register</span> <span class="keyword">const</span> T* pcurr = buf;    
<a name="l01990"></a>01990     <span class="keyword">register</span> <span class="keyword">const</span> T* pend = pcurr + (*pcurr &gt;&gt; 3);
<a name="l01991"></a>01991     ++pcurr;
<a name="l01992"></a>01992 
<a name="l01993"></a>01993     <span class="keywordtype">unsigned</span> bitval = *buf &amp; 1;
<a name="l01994"></a>01994     
<a name="l01995"></a>01995     <span class="keyword">register</span> <a class="code" href="a00115.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a> count = <a class="code" href="a00120.html#ga503e0f3e79f819d9b58e4b0e905be116">bit_block_any_range</a>(block, 0, *pcurr);
<a name="l01996"></a>01996     <span class="keywordflow">if</span> (bitval)
<a name="l01997"></a>01997     {
<a name="l01998"></a>01998         count = *pcurr + 1 - count;
<a name="l01999"></a>01999     }
<a name="l02000"></a>02000     
<a name="l02001"></a>02001     <span class="keywordflow">for</span> (bitval^=1, ++pcurr; pcurr &lt;= pend; bitval^=1, ++pcurr)
<a name="l02002"></a>02002     {
<a name="l02003"></a>02003         T prev = *(pcurr-1)+1;
<a name="l02004"></a>02004         <a class="code" href="a00115.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a> c = <a class="code" href="a00120.html#ga503e0f3e79f819d9b58e4b0e905be116">bit_block_any_range</a>(block, prev, *pcurr);
<a name="l02005"></a>02005         
<a name="l02006"></a>02006         <span class="keywordflow">if</span> (bitval) <span class="comment">// 1 gap; means Result = Total_Bits - BitCount;</span>
<a name="l02007"></a>02007         {
<a name="l02008"></a>02008             c = (*pcurr - prev + 1) - c;
<a name="l02009"></a>02009         }
<a name="l02010"></a>02010         
<a name="l02011"></a>02011         count += c;
<a name="l02012"></a>02012         <span class="keywordflow">if</span> (count)
<a name="l02013"></a>02013             <span class="keywordflow">return</span> count;
<a name="l02014"></a>02014     }
<a name="l02015"></a>02015     <span class="keywordflow">return</span> count;
<a name="l02016"></a>02016 }
<a name="l02017"></a>02017 
<a name="l02018"></a>02018 
<a name="l02019"></a>02019 <span class="comment"></span>
<a name="l02020"></a>02020 <span class="comment">/*!</span>
<a name="l02021"></a>02021 <span class="comment">   \brief Compute bitcount of bit block OR masked by GAP block.</span>
<a name="l02022"></a>02022 <span class="comment">   \param dest - bitblock buffer pointer.</span>
<a name="l02023"></a>02023 <span class="comment">   \param buf  - GAP buffer pointer.</span>
<a name="l02024"></a>02024 <span class="comment"></span>
<a name="l02025"></a>02025 <span class="comment">   @ingroup gapfunc bitfunc</span>
<a name="l02026"></a>02026 <span class="comment">*/</span>
<a name="l02027"></a>02027 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; 
<a name="l02028"></a><a class="code" href="a00120.html#ga23733890861063a59f787e26763a734a">02028</a> <a class="code" href="a00115.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a> <a class="code" href="a00120.html#ga23733890861063a59f787e26763a734a" title="Compute bitcount of bit block OR masked by GAP block.">gap_bitset_or_count</a>(<span class="keyword">const</span> <span class="keywordtype">unsigned</span>* block, <span class="keyword">const</span> T*  buf)
<a name="l02029"></a>02029 {
<a name="l02030"></a>02030     <a class="code" href="a00092.html#aa44515fab0ace8928d1cb82009a95bf8">BM_ASSERT</a>(block);
<a name="l02031"></a>02031 
<a name="l02032"></a>02032     <span class="keyword">register</span> <span class="keyword">const</span> T* pcurr = buf;    
<a name="l02033"></a>02033     <span class="keyword">register</span> <span class="keyword">const</span> T* pend = pcurr + (*pcurr &gt;&gt; 3);
<a name="l02034"></a>02034     ++pcurr;
<a name="l02035"></a>02035 
<a name="l02036"></a>02036     <span class="keywordtype">unsigned</span> bitval = *buf &amp; 1;
<a name="l02037"></a>02037     
<a name="l02038"></a>02038     <span class="keyword">register</span> <a class="code" href="a00115.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a> count;
<a name="l02039"></a>02039     <span class="keywordflow">if</span> (bitval)
<a name="l02040"></a>02040     {
<a name="l02041"></a>02041         count = *pcurr + 1;
<a name="l02042"></a>02042     } 
<a name="l02043"></a>02043     <span class="keywordflow">else</span>
<a name="l02044"></a>02044     {
<a name="l02045"></a>02045         count = <a class="code" href="a00120.html#ga2485f707b2629c5ce7681cf9fe385b91">bit_block_calc_count_range</a>(block, 0, *pcurr);
<a name="l02046"></a>02046     }
<a name="l02047"></a>02047     
<a name="l02048"></a>02048     <span class="keywordflow">for</span> (bitval^=1, ++pcurr; pcurr &lt;= pend; bitval^=1, ++pcurr)
<a name="l02049"></a>02049     {
<a name="l02050"></a>02050         T prev = *(pcurr-1)+1;
<a name="l02051"></a>02051         <a class="code" href="a00115.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a> c;
<a name="l02052"></a>02052         
<a name="l02053"></a>02053         <span class="keywordflow">if</span> (bitval)
<a name="l02054"></a>02054         {
<a name="l02055"></a>02055             c = (*pcurr - prev + 1);
<a name="l02056"></a>02056         }
<a name="l02057"></a>02057         <span class="keywordflow">else</span>
<a name="l02058"></a>02058         {
<a name="l02059"></a>02059             c = <a class="code" href="a00120.html#ga2485f707b2629c5ce7681cf9fe385b91">bit_block_calc_count_range</a>(block, prev, *pcurr);
<a name="l02060"></a>02060         }
<a name="l02061"></a>02061         
<a name="l02062"></a>02062         count += c;
<a name="l02063"></a>02063     }
<a name="l02064"></a>02064     <span class="keywordflow">return</span> count;
<a name="l02065"></a>02065 }
<a name="l02066"></a>02066 <span class="comment"></span>
<a name="l02067"></a>02067 <span class="comment">/*!</span>
<a name="l02068"></a>02068 <span class="comment">   \brief Compute bitcount test of bit block OR masked by GAP block.</span>
<a name="l02069"></a>02069 <span class="comment">   \param dest - bitblock buffer pointer.</span>
<a name="l02070"></a>02070 <span class="comment">   \param buf  - GAP buffer pointer.</span>
<a name="l02071"></a>02071 <span class="comment"></span>
<a name="l02072"></a>02072 <span class="comment">   @ingroup gapfunc bitfunc</span>
<a name="l02073"></a>02073 <span class="comment">*/</span>
<a name="l02074"></a>02074 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; 
<a name="l02075"></a><a class="code" href="a00120.html#gad15f1b92c70752cd3b97fa9e0c585f00">02075</a> <a class="code" href="a00115.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a> <a class="code" href="a00120.html#gad15f1b92c70752cd3b97fa9e0c585f00" title="Compute bitcount test of bit block OR masked by GAP block.">gap_bitset_or_any</a>(<span class="keyword">const</span> <span class="keywordtype">unsigned</span>* block, <span class="keyword">const</span> T*  buf)
<a name="l02076"></a>02076 {
<a name="l02077"></a>02077     <a class="code" href="a00092.html#aa44515fab0ace8928d1cb82009a95bf8">BM_ASSERT</a>(block);
<a name="l02078"></a>02078 
<a name="l02079"></a>02079     <span class="keyword">register</span> <span class="keyword">const</span> T* pcurr = buf;    
<a name="l02080"></a>02080     <span class="keyword">register</span> <span class="keyword">const</span> T* pend = pcurr + (*pcurr &gt;&gt; 3);
<a name="l02081"></a>02081     ++pcurr;
<a name="l02082"></a>02082 
<a name="l02083"></a>02083     <span class="keywordtype">unsigned</span> bitval = *buf &amp; 1;
<a name="l02084"></a>02084     
<a name="l02085"></a>02085     <span class="keyword">register</span> <a class="code" href="a00115.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a> count;
<a name="l02086"></a>02086     <span class="keywordflow">if</span> (bitval)
<a name="l02087"></a>02087     {
<a name="l02088"></a>02088         count = *pcurr + 1;
<a name="l02089"></a>02089     } 
<a name="l02090"></a>02090     <span class="keywordflow">else</span>
<a name="l02091"></a>02091     {
<a name="l02092"></a>02092         count = <a class="code" href="a00120.html#ga503e0f3e79f819d9b58e4b0e905be116">bit_block_any_range</a>(block, 0, *pcurr);
<a name="l02093"></a>02093     }
<a name="l02094"></a>02094     
<a name="l02095"></a>02095     <span class="keywordflow">for</span> (bitval^=1, ++pcurr; pcurr &lt;= pend; bitval^=1, ++pcurr)
<a name="l02096"></a>02096     {
<a name="l02097"></a>02097         T prev = *(pcurr-1)+1;
<a name="l02098"></a>02098         <a class="code" href="a00115.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a> c;
<a name="l02099"></a>02099         
<a name="l02100"></a>02100         <span class="keywordflow">if</span> (bitval)
<a name="l02101"></a>02101         {
<a name="l02102"></a>02102             c = (*pcurr - prev + 1);
<a name="l02103"></a>02103         }
<a name="l02104"></a>02104         <span class="keywordflow">else</span>
<a name="l02105"></a>02105         {
<a name="l02106"></a>02106             c = <a class="code" href="a00120.html#ga503e0f3e79f819d9b58e4b0e905be116">bit_block_any_range</a>(block, prev, *pcurr);
<a name="l02107"></a>02107         }        
<a name="l02108"></a>02108         count += c;
<a name="l02109"></a>02109         <span class="keywordflow">if</span> (count)
<a name="l02110"></a>02110             <span class="keywordflow">return</span> count;
<a name="l02111"></a>02111     }
<a name="l02112"></a>02112     <span class="keywordflow">return</span> count;
<a name="l02113"></a>02113 }
<a name="l02114"></a>02114 
<a name="l02115"></a>02115 
<a name="l02116"></a>02116 <span class="comment"></span>
<a name="l02117"></a>02117 <span class="comment">/*!</span>
<a name="l02118"></a>02118 <span class="comment">   \brief Bitblock memset operation. </span>
<a name="l02119"></a>02119 <span class="comment"></span>
<a name="l02120"></a>02120 <span class="comment">   \param dst - destination block.</span>
<a name="l02121"></a>02121 <span class="comment">   \param value - value to set.</span>
<a name="l02122"></a>02122 <span class="comment"></span>
<a name="l02123"></a>02123 <span class="comment">   @ingroup bitfunc</span>
<a name="l02124"></a>02124 <span class="comment">*/</span>
<a name="l02125"></a>02125 <span class="keyword">inline</span> 
<a name="l02126"></a><a class="code" href="a00120.html#gaada8b13c35acd8df90129b45edcfc5de">02126</a> <span class="keywordtype">void</span> <a class="code" href="a00120.html#gaada8b13c35acd8df90129b45edcfc5de" title="Bitblock memset operation.">bit_block_set</a>(<a class="code" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a>* BMRESTRICT dst, <a class="code" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> value)
<a name="l02127"></a>02127 {
<a name="l02128"></a>02128 <span class="comment">//#ifdef BMVECTOPT</span>
<a name="l02129"></a>02129 <span class="comment">//    VECT_SET_BLOCK(dst, dst + bm::set_block_size, value);</span>
<a name="l02130"></a>02130 <span class="comment">//#else</span>
<a name="l02131"></a>02131     ::memset(dst, value, <a class="code" href="a00115.html#a91319dbc0d0e1bf3a3efc4d92bac7972">bm::set_block_size</a> * <span class="keyword">sizeof</span>(<a class="code" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a>));
<a name="l02132"></a>02132 <span class="comment">//#endif</span>
<a name="l02133"></a>02133 }
<a name="l02134"></a>02134 
<a name="l02135"></a>02135 <span class="comment"></span>
<a name="l02136"></a>02136 <span class="comment">/*!</span>
<a name="l02137"></a>02137 <span class="comment">   \brief GAP block to bitblock conversion.</span>
<a name="l02138"></a>02138 <span class="comment">   \param dest - bitblock buffer pointer.</span>
<a name="l02139"></a>02139 <span class="comment">   \param buf  - GAP buffer pointer.</span>
<a name="l02140"></a>02140 <span class="comment"></span>
<a name="l02141"></a>02141 <span class="comment">   @ingroup gapfunc</span>
<a name="l02142"></a>02142 <span class="comment">*/</span>
<a name="l02143"></a>02143 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; 
<a name="l02144"></a><a class="code" href="a00119.html#ga4862f4dcdcb7c0575e2e2db9e5f2a849">02144</a> <span class="keywordtype">void</span> <a class="code" href="a00119.html#ga4862f4dcdcb7c0575e2e2db9e5f2a849" title="GAP block to bitblock conversion.">gap_convert_to_bitset</a>(<span class="keywordtype">unsigned</span>* dest, <span class="keyword">const</span> T*  buf)
<a name="l02145"></a>02145 {
<a name="l02146"></a>02146     <a class="code" href="a00120.html#gaada8b13c35acd8df90129b45edcfc5de" title="Bitblock memset operation.">bit_block_set</a>(dest, 0);
<a name="l02147"></a>02147     <a class="code" href="a00119.html#ga12615cd62f2e5367e1bc688d00a2188f" title="Adds(OR) GAP block to bitblock.">gap_add_to_bitset</a>(dest, buf);
<a name="l02148"></a>02148 }
<a name="l02149"></a>02149 <span class="comment"></span>
<a name="l02150"></a>02150 <span class="comment">/*!</span>
<a name="l02151"></a>02151 <span class="comment">\brief GAP block to bitblock conversion.</span>
<a name="l02152"></a>02152 <span class="comment">\param dest - bitblock buffer pointer.</span>
<a name="l02153"></a>02153 <span class="comment">\param buf  - GAP buffer pointer.</span>
<a name="l02154"></a>02154 <span class="comment"></span>
<a name="l02155"></a>02155 <span class="comment">@ingroup gapfunc</span>
<a name="l02156"></a>02156 <span class="comment">*/</span>
<a name="l02157"></a>02157 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; 
<a name="l02158"></a><a class="code" href="a00119.html#ga1dd58e3576239c49010b62a3add42417">02158</a> <span class="keywordtype">void</span> <a class="code" href="a00119.html#ga1dd58e3576239c49010b62a3add42417" title="GAP block to bitblock conversion.">gap_convert_to_bitset_l</a>(<span class="keywordtype">unsigned</span>* dest, <span class="keyword">const</span> T*  buf, <span class="keywordtype">unsigned</span> buf_len)
<a name="l02159"></a>02159 {
<a name="l02160"></a>02160     <a class="code" href="a00120.html#gaada8b13c35acd8df90129b45edcfc5de" title="Bitblock memset operation.">bit_block_set</a>(dest, 0);
<a name="l02161"></a>02161     <a class="code" href="a00119.html#ga78510a39b6e8c6b8904ecbffb6ab215b" title="Adds(OR) GAP block to bitblock.">gap_add_to_bitset_l</a>(dest, buf, buf_len ? buf_len : *buf &gt;&gt; 3);
<a name="l02162"></a>02162 }
<a name="l02163"></a>02163 
<a name="l02164"></a>02164 
<a name="l02165"></a>02165 <span class="comment"></span>
<a name="l02166"></a>02166 <span class="comment">/*!</span>
<a name="l02167"></a>02167 <span class="comment">   \brief GAP block to bitblock conversion.</span>
<a name="l02168"></a>02168 <span class="comment">   \param dest - bitblock buffer pointer.</span>
<a name="l02169"></a>02169 <span class="comment">   \param buf  - GAP buffer pointer.</span>
<a name="l02170"></a>02170 <span class="comment">   \param dest_size - length of the destination buffer.</span>
<a name="l02171"></a>02171 <span class="comment"></span>
<a name="l02172"></a>02172 <span class="comment">   @ingroup gapfunc</span>
<a name="l02173"></a>02173 <span class="comment">*/</span>
<a name="l02174"></a>02174 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; 
<a name="l02175"></a><a class="code" href="a00119.html#ga9bb80c42ee0ecf8f2af8250d7f5d327b">02175</a> <span class="keywordtype">void</span> <a class="code" href="a00119.html#ga4862f4dcdcb7c0575e2e2db9e5f2a849" title="GAP block to bitblock conversion.">gap_convert_to_bitset</a>(<span class="keywordtype">unsigned</span>* dest, <span class="keyword">const</span> T*  buf,  <span class="keywordtype">unsigned</span>  dest_len)
<a name="l02176"></a>02176 {
<a name="l02177"></a>02177    ::memset(dest, 0, dest_len * <span class="keyword">sizeof</span>(unsigned));
<a name="l02178"></a>02178     <a class="code" href="a00119.html#ga12615cd62f2e5367e1bc688d00a2188f" title="Adds(OR) GAP block to bitblock.">gap_add_to_bitset</a>(dest, buf);
<a name="l02179"></a>02179 }
<a name="l02180"></a>02180 
<a name="l02181"></a>02181 
<a name="l02182"></a>02182 <span class="comment"></span>
<a name="l02183"></a>02183 <span class="comment">/*!</span>
<a name="l02184"></a>02184 <span class="comment">   \brief Smart GAP block to bitblock conversion.</span>
<a name="l02185"></a>02185 <span class="comment"></span>
<a name="l02186"></a>02186 <span class="comment">    Checks if GAP block is ALL-ZERO or ALL-ON. In those cases returns </span>
<a name="l02187"></a>02187 <span class="comment">    pointer on special static bitblocks.</span>
<a name="l02188"></a>02188 <span class="comment"></span>
<a name="l02189"></a>02189 <span class="comment">   \param dest - bitblock buffer pointer.</span>
<a name="l02190"></a>02190 <span class="comment">   \param buf  - GAP buffer pointer.</span>
<a name="l02191"></a>02191 <span class="comment">   \param set_max - max possible bitset length</span>
<a name="l02192"></a>02192 <span class="comment"></span>
<a name="l02193"></a>02193 <span class="comment">   @ingroup gapfunc</span>
<a name="l02194"></a>02194 <span class="comment">*/</span>
<a name="l02195"></a>02195 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; 
<a name="l02196"></a><a class="code" href="a00119.html#ga3f01bb7c1ae7983aa8c4ba82e1e3f54c">02196</a>         <span class="keywordtype">unsigned</span>* <a class="code" href="a00119.html#ga3f01bb7c1ae7983aa8c4ba82e1e3f54c" title="Smart GAP block to bitblock conversion.">gap_convert_to_bitset_smart</a>(<span class="keywordtype">unsigned</span>* dest,
<a name="l02197"></a>02197                                               <span class="keyword">const</span> T* buf, 
<a name="l02198"></a>02198                                               <a class="code" href="a00115.html#aa3824d882a037396370b16f2f0a8bf37">id_t</a> set_max)
<a name="l02199"></a>02199 {
<a name="l02200"></a>02200     <span class="keywordflow">if</span> (buf[1] == set_max - 1)
<a name="l02201"></a>02201     {
<a name="l02202"></a>02202         <span class="keywordflow">return</span> (buf[0] &amp; 1) ? <a class="code" href="a00092.html#a1365569f85f442c4914a3579f55df99b">FULL_BLOCK_ADDR</a> : 0;
<a name="l02203"></a>02203     }
<a name="l02204"></a>02204 
<a name="l02205"></a>02205     <a class="code" href="a00119.html#ga4862f4dcdcb7c0575e2e2db9e5f2a849" title="GAP block to bitblock conversion.">gap_convert_to_bitset</a>(dest, buf);
<a name="l02206"></a>02206     <span class="keywordflow">return</span> dest;
<a name="l02207"></a>02207 }
<a name="l02208"></a>02208 
<a name="l02209"></a>02209 <span class="comment"></span>
<a name="l02210"></a>02210 <span class="comment">/*!</span>
<a name="l02211"></a>02211 <span class="comment">   \brief Calculates sum of all words in GAP block. (For debugging purposes)</span>
<a name="l02212"></a>02212 <span class="comment">   \note For debugging and testing ONLY.</span>
<a name="l02213"></a>02213 <span class="comment">   \param buf - GAP buffer pointer.</span>
<a name="l02214"></a>02214 <span class="comment">   \return Sum of all words.</span>
<a name="l02215"></a>02215 <span class="comment"></span>
<a name="l02216"></a>02216 <span class="comment">   @ingroup gapfunc</span>
<a name="l02217"></a>02217 <span class="comment">*/</span>
<a name="l02218"></a><a class="code" href="a00119.html#ga14d29338ffd1387758810b3f9e3a72c6">02218</a> <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keywordtype">unsigned</span> <a class="code" href="a00119.html#ga14d29338ffd1387758810b3f9e3a72c6" title="Calculates sum of all words in GAP block. (For debugging purposes).">gap_control_sum</a>(<span class="keyword">const</span> T* buf)
<a name="l02219"></a>02219 {
<a name="l02220"></a>02220     <span class="keywordtype">unsigned</span> end = *buf &gt;&gt; 3;
<a name="l02221"></a>02221 
<a name="l02222"></a>02222     <span class="keyword">register</span> <span class="keyword">const</span> T* pcurr = buf;    
<a name="l02223"></a>02223     <span class="keyword">register</span> <span class="keyword">const</span> T* pend = pcurr + (*pcurr &gt;&gt; 3);
<a name="l02224"></a>02224     ++pcurr;
<a name="l02225"></a>02225 
<a name="l02226"></a>02226     <span class="keywordflow">if</span> (*buf &amp; 1)  <span class="comment">// Starts with 1</span>
<a name="l02227"></a>02227     {
<a name="l02228"></a>02228         ++pcurr;
<a name="l02229"></a>02229     }
<a name="l02230"></a>02230     ++pcurr; <span class="comment">// now we are in GAP &quot;1&quot; again</span>
<a name="l02231"></a>02231 
<a name="l02232"></a>02232     <span class="keywordflow">while</span> (pcurr &lt;= pend)
<a name="l02233"></a>02233     {
<a name="l02234"></a>02234         <a class="code" href="a00092.html#aa44515fab0ace8928d1cb82009a95bf8">BM_ASSERT</a>(*pcurr &gt; *(pcurr-1));
<a name="l02235"></a>02235         pcurr += 2;
<a name="l02236"></a>02236     }
<a name="l02237"></a>02237     <span class="keywordflow">return</span> buf[end];
<a name="l02238"></a>02238 
<a name="l02239"></a>02239 }
<a name="l02240"></a>02240 
<a name="l02241"></a>02241 <span class="comment"></span>
<a name="l02242"></a>02242 <span class="comment">/*! </span>
<a name="l02243"></a>02243 <span class="comment">   \brief Sets all bits to 0 or 1 (GAP)</span>
<a name="l02244"></a>02244 <span class="comment">   \param buf - GAP buffer pointer.</span>
<a name="l02245"></a>02245 <span class="comment">   \param set_max - max possible bitset length</span>
<a name="l02246"></a>02246 <span class="comment"></span>
<a name="l02247"></a>02247 <span class="comment">   @ingroup gapfunc</span>
<a name="l02248"></a>02248 <span class="comment">*/</span>
<a name="l02249"></a><a class="code" href="a00119.html#gaef53b2877ff369badd7bb25b26bb9029">02249</a> <span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt; <span class="keywordtype">void</span> <a class="code" href="a00119.html#gaef53b2877ff369badd7bb25b26bb9029" title="Sets all bits to 0 or 1 (GAP).">gap_set_all</a>(T* buf, 
<a name="l02250"></a>02250                                    <span class="keywordtype">unsigned</span> set_max,
<a name="l02251"></a>02251                                    <span class="keywordtype">unsigned</span> value)
<a name="l02252"></a>02252 {
<a name="l02253"></a>02253     <a class="code" href="a00092.html#aa44515fab0ace8928d1cb82009a95bf8">BM_ASSERT</a>(value == 0 || value == 1);
<a name="l02254"></a>02254     *buf = (T)((*buf &amp; 6u) + (1u &lt;&lt; 3) + value);
<a name="l02255"></a>02255     *(++buf) = (T)(set_max - 1);
<a name="l02256"></a>02256 }
<a name="l02257"></a>02257 
<a name="l02258"></a>02258 <span class="comment"></span>
<a name="l02259"></a>02259 <span class="comment">/*!</span>
<a name="l02260"></a>02260 <span class="comment">    \brief Init gap block so it has block in it (can be whole block)</span>
<a name="l02261"></a>02261 <span class="comment">    \param buf  - GAP buffer pointer.</span>
<a name="l02262"></a>02262 <span class="comment">    \param from - one block start</span>
<a name="l02263"></a>02263 <span class="comment">    \param to   - one block end</span>
<a name="l02264"></a>02264 <span class="comment">    \param value - (block value)1 or 0</span>
<a name="l02265"></a>02265 <span class="comment">    \param set_max - max possible bitset length</span>
<a name="l02266"></a>02266 <span class="comment">    </span>
<a name="l02267"></a>02267 <span class="comment">   @ingroup gapfunc</span>
<a name="l02268"></a>02268 <span class="comment">*/</span>
<a name="l02269"></a>02269 <span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt; 
<a name="l02270"></a><a class="code" href="a00119.html#ga510ab7feb60c19f7d7811cc304fdf649">02270</a> <span class="keywordtype">void</span> <a class="code" href="a00119.html#ga510ab7feb60c19f7d7811cc304fdf649" title="Init gap block so it has block in it (can be whole block).">gap_init_range_block</a>(T* buf,
<a name="l02271"></a>02271                           T  from,
<a name="l02272"></a>02272                           T  to,
<a name="l02273"></a>02273                           T  value,
<a name="l02274"></a>02274                           <span class="keywordtype">unsigned</span> set_max)
<a name="l02275"></a>02275 {
<a name="l02276"></a>02276     <a class="code" href="a00092.html#aa44515fab0ace8928d1cb82009a95bf8">BM_ASSERT</a>(value == 0 || value == 1);
<a name="l02277"></a>02277 
<a name="l02278"></a>02278     <span class="keywordtype">unsigned</span> gap_len;
<a name="l02279"></a>02279     <span class="keywordflow">if</span> (from == 0)
<a name="l02280"></a>02280     {
<a name="l02281"></a>02281         <span class="keywordflow">if</span> (to == set_max - 1)
<a name="l02282"></a>02282         {
<a name="l02283"></a>02283             <a class="code" href="a00119.html#gaef53b2877ff369badd7bb25b26bb9029" title="Sets all bits to 0 or 1 (GAP).">gap_set_all</a>(buf, set_max, value);
<a name="l02284"></a>02284         }
<a name="l02285"></a>02285         <span class="keywordflow">else</span>
<a name="l02286"></a>02286         {
<a name="l02287"></a>02287             gap_len = 2;
<a name="l02288"></a>02288             buf[1] = to;
<a name="l02289"></a>02289             buf[2] = (T)(set_max - 1);
<a name="l02290"></a>02290             buf[0] = (T)((*buf &amp; 6u) + (gap_len &lt;&lt; 3) + value);
<a name="l02291"></a>02291         }
<a name="l02292"></a>02292         <span class="keywordflow">return</span>;
<a name="l02293"></a>02293     }
<a name="l02294"></a>02294     <span class="comment">// from != 0</span>
<a name="l02295"></a>02295 
<a name="l02296"></a>02296     value = !value;
<a name="l02297"></a>02297     <span class="keywordflow">if</span> (to == set_max - 1)
<a name="l02298"></a>02298     {
<a name="l02299"></a>02299         gap_len = 2;
<a name="l02300"></a>02300         buf[1] = (T)(from - 1);
<a name="l02301"></a>02301         buf[2] = (T)(set_max - 1);
<a name="l02302"></a>02302     }
<a name="l02303"></a>02303     <span class="keywordflow">else</span>
<a name="l02304"></a>02304     {
<a name="l02305"></a>02305         gap_len = 3;
<a name="l02306"></a>02306         buf[1] = from - 1;
<a name="l02307"></a>02307         buf[2] = (T) to;
<a name="l02308"></a>02308         buf[3] = (T)(set_max - 1);
<a name="l02309"></a>02309     }
<a name="l02310"></a>02310     buf[0] =  (T)((*buf &amp; 6u) + (gap_len &lt;&lt; 3) + value);
<a name="l02311"></a>02311 }
<a name="l02312"></a>02312 
<a name="l02313"></a>02313 <span class="comment"></span>
<a name="l02314"></a>02314 <span class="comment">/*! </span>
<a name="l02315"></a>02315 <span class="comment">   \brief Inverts all bits in the GAP buffer.</span>
<a name="l02316"></a>02316 <span class="comment">   \param buf - GAP buffer pointer.</span>
<a name="l02317"></a>02317 <span class="comment"></span>
<a name="l02318"></a>02318 <span class="comment">   @ingroup gapfunc</span>
<a name="l02319"></a>02319 <span class="comment">*/</span>
<a name="l02320"></a><a class="code" href="a00119.html#ga3f22bfde5dfe06d6d77dc2598b8c0845">02320</a> <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keywordtype">void</span> <a class="code" href="a00119.html#ga3f22bfde5dfe06d6d77dc2598b8c0845" title="Inverts all bits in the GAP buffer.">gap_invert</a>(T* buf)
<a name="l02321"></a>02321 { 
<a name="l02322"></a>02322     *buf ^= 1;
<a name="l02323"></a>02323 }
<a name="l02324"></a>02324 <span class="comment"></span>
<a name="l02325"></a>02325 <span class="comment">/*! </span>
<a name="l02326"></a>02326 <span class="comment">   \brief Temporary inverts all bits in the GAP buffer.</span>
<a name="l02327"></a>02327 <span class="comment">   </span>
<a name="l02328"></a>02328 <span class="comment">   In this function const-ness of the buffer means nothing.</span>
<a name="l02329"></a>02329 <span class="comment">   Calling this function again restores the status of the buffer.</span>
<a name="l02330"></a>02330 <span class="comment"></span>
<a name="l02331"></a>02331 <span class="comment">   \param buf - GAP buffer pointer. (Buffer IS changed) </span>
<a name="l02332"></a>02332 <span class="comment"></span>
<a name="l02333"></a>02333 <span class="comment">   @ingroup gapfunc</span>
<a name="l02334"></a>02334 <span class="comment">*/</span>
<a name="l02335"></a>02335 <span class="comment">/*</span>
<a name="l02336"></a>02336 <span class="comment">template&lt;typename T&gt; void gap_temp_invert(const T* buf)</span>
<a name="l02337"></a>02337 <span class="comment">{</span>
<a name="l02338"></a>02338 <span class="comment">    T* buftmp = const_cast&lt;T*&gt;(buf);</span>
<a name="l02339"></a>02339 <span class="comment">    *buftmp ^= 1;</span>
<a name="l02340"></a>02340 <span class="comment">}</span>
<a name="l02341"></a>02341 <span class="comment">*/</span>
<a name="l02342"></a>02342 <span class="comment"></span>
<a name="l02343"></a>02343 <span class="comment">/*!</span>
<a name="l02344"></a>02344 <span class="comment">   \brief Checks if GAP block is all-zero.</span>
<a name="l02345"></a>02345 <span class="comment">   \param buf - GAP buffer pointer.</span>
<a name="l02346"></a>02346 <span class="comment">   \param set_max - max possible bitset length</span>
<a name="l02347"></a>02347 <span class="comment">   \returns true if all-zero.</span>
<a name="l02348"></a>02348 <span class="comment"></span>
<a name="l02349"></a>02349 <span class="comment">   @ingroup gapfunc</span>
<a name="l02350"></a>02350 <span class="comment">*/</span>
<a name="l02351"></a>02351 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; 
<a name="l02352"></a><a class="code" href="a00119.html#ga690ff7c8b16e1821a77663b7194267e7">02352</a>              <span class="keywordtype">bool</span> <a class="code" href="a00119.html#ga690ff7c8b16e1821a77663b7194267e7" title="Temporary inverts all bits in the GAP buffer.">gap_is_all_zero</a>(<span class="keyword">const</span> T* buf, <span class="keywordtype">unsigned</span> set_max)
<a name="l02353"></a>02353 {
<a name="l02354"></a>02354     <span class="keywordflow">return</span> (((*buf &amp; 1)==0)  &amp;&amp; (*(++buf) == set_max - 1));
<a name="l02355"></a>02355 }
<a name="l02356"></a>02356 <span class="comment"></span>
<a name="l02357"></a>02357 <span class="comment">/*!</span>
<a name="l02358"></a>02358 <span class="comment">   \brief Checks if GAP block is all-one.</span>
<a name="l02359"></a>02359 <span class="comment">   \param buf - GAP buffer pointer.</span>
<a name="l02360"></a>02360 <span class="comment">   \param set_max - max possible bitset length</span>
<a name="l02361"></a>02361 <span class="comment">   \returns true if all-one.</span>
<a name="l02362"></a>02362 <span class="comment"></span>
<a name="l02363"></a>02363 <span class="comment">   @ingroup gapfunc</span>
<a name="l02364"></a>02364 <span class="comment">*/</span>
<a name="l02365"></a>02365 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; 
<a name="l02366"></a><a class="code" href="a00119.html#ga1427d43e91872f981c6311fa76ab5633">02366</a>          <span class="keywordtype">bool</span> <a class="code" href="a00119.html#ga1427d43e91872f981c6311fa76ab5633" title="Checks if GAP block is all-one.">gap_is_all_one</a>(<span class="keyword">const</span> T* buf, <span class="keywordtype">unsigned</span> set_max)
<a name="l02367"></a>02367 {
<a name="l02368"></a>02368     <span class="keywordflow">return</span> ((*buf &amp; 1)  &amp;&amp; (*(++buf) == set_max - 1));
<a name="l02369"></a>02369 }
<a name="l02370"></a>02370 <span class="comment"></span>
<a name="l02371"></a>02371 <span class="comment">/*!</span>
<a name="l02372"></a>02372 <span class="comment">   \brief Returs GAP block length.</span>
<a name="l02373"></a>02373 <span class="comment">   \param buf - GAP buffer pointer.</span>
<a name="l02374"></a>02374 <span class="comment">   \returns GAP block length.</span>
<a name="l02375"></a>02375 <span class="comment"></span>
<a name="l02376"></a>02376 <span class="comment">   @ingroup gapfunc</span>
<a name="l02377"></a>02377 <span class="comment">*/</span>
<a name="l02378"></a><a class="code" href="a00119.html#ga02541ec6c2930c292eda4313b78e874c">02378</a> <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; T <a class="code" href="a00119.html#ga02541ec6c2930c292eda4313b78e874c" title="Returs GAP block length.">gap_length</a>(<span class="keyword">const</span> T* buf)
<a name="l02379"></a>02379 {
<a name="l02380"></a>02380     <span class="keywordflow">return</span> (*buf &gt;&gt; 3) + 1;
<a name="l02381"></a>02381 }
<a name="l02382"></a>02382 
<a name="l02383"></a>02383 <span class="comment"></span>
<a name="l02384"></a>02384 <span class="comment">/*!</span>
<a name="l02385"></a>02385 <span class="comment">   \brief Returs GAP block capacity.</span>
<a name="l02386"></a>02386 <span class="comment">   \param buf - GAP buffer pointer.</span>
<a name="l02387"></a>02387 <span class="comment">   \returns GAP block capacity.</span>
<a name="l02388"></a>02388 <span class="comment"></span>
<a name="l02389"></a>02389 <span class="comment">   @ingroup gapfunc</span>
<a name="l02390"></a>02390 <span class="comment">*/</span>
<a name="l02391"></a>02391 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; 
<a name="l02392"></a><a class="code" href="a00119.html#ga0419ed06e2f0b7891e7d721546f5fb45">02392</a> <span class="keywordtype">unsigned</span> <a class="code" href="a00119.html#ga0419ed06e2f0b7891e7d721546f5fb45" title="Returs GAP block capacity.">gap_capacity</a>(<span class="keyword">const</span> T* buf, <span class="keyword">const</span> T* glevel_len)
<a name="l02393"></a>02393 {
<a name="l02394"></a>02394     <span class="keywordflow">return</span> glevel_len[(*buf &gt;&gt; 1) &amp; 3];
<a name="l02395"></a>02395 }
<a name="l02396"></a>02396 
<a name="l02397"></a>02397 <span class="comment"></span>
<a name="l02398"></a>02398 <span class="comment">/*!</span>
<a name="l02399"></a>02399 <span class="comment">   \brief Returs GAP block capacity limit.</span>
<a name="l02400"></a>02400 <span class="comment">   \param buf - GAP buffer pointer.</span>
<a name="l02401"></a>02401 <span class="comment">   \param glevel_len - GAP lengths table (gap_len_table)</span>
<a name="l02402"></a>02402 <span class="comment">   \returns GAP block limit.</span>
<a name="l02403"></a>02403 <span class="comment"></span>
<a name="l02404"></a>02404 <span class="comment">   @ingroup gapfunc</span>
<a name="l02405"></a>02405 <span class="comment">*/</span>
<a name="l02406"></a>02406 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; 
<a name="l02407"></a><a class="code" href="a00119.html#ga94a5371b5dc6a1560d95d7c2dde88815">02407</a> <span class="keywordtype">unsigned</span> <a class="code" href="a00119.html#ga94a5371b5dc6a1560d95d7c2dde88815" title="Returs GAP block capacity limit.">gap_limit</a>(<span class="keyword">const</span> T* buf, <span class="keyword">const</span> T* glevel_len)
<a name="l02408"></a>02408 {
<a name="l02409"></a>02409     <span class="keywordflow">return</span> glevel_len[(*buf &gt;&gt; 1) &amp; 3]-4;
<a name="l02410"></a>02410 }
<a name="l02411"></a>02411 
<a name="l02412"></a>02412 <span class="comment"></span>
<a name="l02413"></a>02413 <span class="comment">/*!</span>
<a name="l02414"></a>02414 <span class="comment">   \brief Returs GAP blocks capacity level.</span>
<a name="l02415"></a>02415 <span class="comment">   \param buf - GAP buffer pointer.</span>
<a name="l02416"></a>02416 <span class="comment">   \returns GAP block capacity level.</span>
<a name="l02417"></a>02417 <span class="comment"></span>
<a name="l02418"></a>02418 <span class="comment">   @ingroup gapfunc</span>
<a name="l02419"></a>02419 <span class="comment">*/</span>
<a name="l02420"></a><a class="code" href="a00119.html#ga1defe73aa4227a0e7204363ac6bb1ac1">02420</a> <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keywordtype">unsigned</span> <a class="code" href="a00119.html#ga1defe73aa4227a0e7204363ac6bb1ac1" title="Returs GAP blocks capacity level.">gap_level</a>(<span class="keyword">const</span> T* buf)
<a name="l02421"></a>02421 {
<a name="l02422"></a>02422     <span class="keywordflow">return</span> (*buf &gt;&gt; 1) &amp; 3;
<a name="l02423"></a>02423 }
<a name="l02424"></a>02424 
<a name="l02425"></a>02425 <span class="comment"></span>
<a name="l02426"></a>02426 <span class="comment">/*!</span>
<a name="l02427"></a>02427 <span class="comment">   \brief Sets GAP block capacity level.</span>
<a name="l02428"></a>02428 <span class="comment">   \param buf - GAP buffer pointer.</span>
<a name="l02429"></a>02429 <span class="comment">   \param level new GAP block capacity level.</span>
<a name="l02430"></a>02430 <span class="comment"></span>
<a name="l02431"></a>02431 <span class="comment">   @ingroup gapfunc</span>
<a name="l02432"></a>02432 <span class="comment">*/</span>
<a name="l02433"></a>02433 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; 
<a name="l02434"></a><a class="code" href="a00119.html#ga501aa9bf029e7f9ea9518e7003fe5549">02434</a> <span class="keywordtype">void</span> <a class="code" href="a00119.html#ga501aa9bf029e7f9ea9518e7003fe5549" title="Sets GAP block capacity level.">set_gap_level</a>(T* buf, <span class="keywordtype">unsigned</span> level)
<a name="l02435"></a>02435 {
<a name="l02436"></a>02436     <a class="code" href="a00092.html#aa44515fab0ace8928d1cb82009a95bf8">BM_ASSERT</a>(level &lt; <a class="code" href="a00115.html#a773e9f5341919d58000bd54d50038733">bm::gap_levels</a>);
<a name="l02437"></a>02437     *buf = ((level &amp; 3) &lt;&lt; 1) | (*buf &amp; 1) | (*buf &amp; ~7); 
<a name="l02438"></a>02438 }
<a name="l02439"></a>02439 
<a name="l02440"></a>02440 <span class="comment"></span>
<a name="l02441"></a>02441 <span class="comment">/*!</span>
<a name="l02442"></a>02442 <span class="comment">   \brief Calculates GAP block capacity level.</span>
<a name="l02443"></a>02443 <span class="comment">   \param len - GAP buffer length.</span>
<a name="l02444"></a>02444 <span class="comment">   \param glevel_len - GAP lengths table</span>
<a name="l02445"></a>02445 <span class="comment">   \return GAP block capacity level. </span>
<a name="l02446"></a>02446 <span class="comment">            -1 if block does not fit any level.</span>
<a name="l02447"></a>02447 <span class="comment">   @ingroup gapfunc</span>
<a name="l02448"></a>02448 <span class="comment">*/</span>
<a name="l02449"></a>02449 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;
<a name="l02450"></a><a class="code" href="a00119.html#ga3bfaebeeb4b2d479c5a9ac9d57607165">02450</a> <span class="keyword">inline</span> <span class="keywordtype">int</span> <a class="code" href="a00119.html#ga3bfaebeeb4b2d479c5a9ac9d57607165" title="Calculates GAP block capacity level.">gap_calc_level</a>(<span class="keywordtype">int</span> len, <span class="keyword">const</span> T* glevel_len)
<a name="l02451"></a>02451 {
<a name="l02452"></a>02452     <span class="keywordflow">if</span> (len &lt;= (glevel_len[0]-4)) <span class="keywordflow">return</span> 0;
<a name="l02453"></a>02453     <span class="keywordflow">if</span> (len &lt;= (glevel_len[1]-4)) <span class="keywordflow">return</span> 1;
<a name="l02454"></a>02454     <span class="keywordflow">if</span> (len &lt;= (glevel_len[2]-4)) <span class="keywordflow">return</span> 2;
<a name="l02455"></a>02455     <span class="keywordflow">if</span> (len &lt;= (glevel_len[3]-4)) <span class="keywordflow">return</span> 3;
<a name="l02456"></a>02456 
<a name="l02457"></a>02457     <a class="code" href="a00092.html#aa44515fab0ace8928d1cb82009a95bf8">BM_ASSERT</a>(<a class="code" href="a00115.html#a773e9f5341919d58000bd54d50038733">bm::gap_levels</a> == 4);
<a name="l02458"></a>02458     <span class="keywordflow">return</span> -1;
<a name="l02459"></a>02459 }
<a name="l02460"></a>02460 <span class="comment"></span>
<a name="l02461"></a>02461 <span class="comment">/*! @brief Returns number of free elements in GAP block array. </span>
<a name="l02462"></a>02462 <span class="comment">    Difference between GAP block capacity on this level and actual GAP length.</span>
<a name="l02463"></a>02463 <span class="comment">    </span>
<a name="l02464"></a>02464 <span class="comment">    @param buf - GAP buffer pointer</span>
<a name="l02465"></a>02465 <span class="comment">    @parma glevel_len - GAP lengths table</span>
<a name="l02466"></a>02466 <span class="comment">    </span>
<a name="l02467"></a>02467 <span class="comment">    @return Number of free GAP elements</span>
<a name="l02468"></a>02468 <span class="comment">    @ingroup gapfunc</span>
<a name="l02469"></a>02469 <span class="comment">*/</span>
<a name="l02470"></a>02470 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;
<a name="l02471"></a><a class="code" href="a00119.html#gafd76869eb44fac688da5e26e0e74f41f">02471</a> <span class="keyword">inline</span> <span class="keywordtype">unsigned</span> <a class="code" href="a00119.html#gafd76869eb44fac688da5e26e0e74f41f" title="Returns number of free elements in GAP block array. Difference between GAP block...">gap_free_elements</a>(<span class="keyword">const</span> T* buf, <span class="keyword">const</span> T* glevel_len)
<a name="l02472"></a>02472 {
<a name="l02473"></a>02473     <span class="keywordtype">unsigned</span> len = <a class="code" href="a00119.html#ga02541ec6c2930c292eda4313b78e874c" title="Returs GAP block length.">gap_length</a>(buf);
<a name="l02474"></a>02474     <span class="keywordtype">unsigned</span> capacity = <a class="code" href="a00119.html#ga0419ed06e2f0b7891e7d721546f5fb45" title="Returs GAP block capacity.">gap_capacity</a>(buf, glevel_len);
<a name="l02475"></a>02475     <span class="keywordflow">return</span> capacity - len;
<a name="l02476"></a>02476 }
<a name="l02477"></a>02477 
<a name="l02478"></a>02478 <span class="comment"></span>
<a name="l02479"></a>02479 <span class="comment">/*! </span>
<a name="l02480"></a>02480 <span class="comment">   \brief Lexicographical comparison of BIT buffers.</span>
<a name="l02481"></a>02481 <span class="comment">   \param buf1 - First buffer pointer.</span>
<a name="l02482"></a>02482 <span class="comment">   \param buf2 - Second buffer pointer.</span>
<a name="l02483"></a>02483 <span class="comment">   \param len - Buffer length in elements (T).</span>
<a name="l02484"></a>02484 <span class="comment">   \return  &lt;0 - less, =0 - equal,  &gt;0 - greater.</span>
<a name="l02485"></a>02485 <span class="comment"></span>
<a name="l02486"></a>02486 <span class="comment">   @ingroup bitfunc </span>
<a name="l02487"></a>02487 <span class="comment">*/</span>
<a name="l02488"></a>02488 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; 
<a name="l02489"></a><a class="code" href="a00120.html#ga91fe9566575d9d66e1bb9d030b3d29a0">02489</a> <span class="keywordtype">int</span> <a class="code" href="a00120.html#ga91fe9566575d9d66e1bb9d030b3d29a0" title="Lexicographical comparison of BIT buffers.">bitcmp</a>(<span class="keyword">const</span> T* buf1, <span class="keyword">const</span> T* buf2, <span class="keywordtype">unsigned</span> len)
<a name="l02490"></a>02490 {
<a name="l02491"></a>02491     <a class="code" href="a00092.html#aa44515fab0ace8928d1cb82009a95bf8">BM_ASSERT</a>(len);
<a name="l02492"></a>02492     <span class="keyword">const</span> T* pend1 = buf1 + len; 
<a name="l02493"></a>02493     <span class="keywordflow">do</span>
<a name="l02494"></a>02494     {
<a name="l02495"></a>02495         T w1 = *buf1++;
<a name="l02496"></a>02496         T w2 = *buf2++;
<a name="l02497"></a>02497         T diff = w1 ^ w2;
<a name="l02498"></a>02498     
<a name="l02499"></a>02499         <span class="keywordflow">if</span> (diff)
<a name="l02500"></a>02500         { 
<a name="l02501"></a>02501             <span class="keywordflow">return</span> (w1 &amp; diff &amp; -diff) ? 1 : -1;
<a name="l02502"></a>02502         }
<a name="l02503"></a>02503 
<a name="l02504"></a>02504     } <span class="keywordflow">while</span> (buf1 &lt; pend1);
<a name="l02505"></a>02505 
<a name="l02506"></a>02506     <span class="keywordflow">return</span> 0;
<a name="l02507"></a>02507 }
<a name="l02508"></a>02508 
<a name="l02509"></a>02509 <span class="comment"></span>
<a name="l02510"></a>02510 <span class="comment">/*! </span>
<a name="l02511"></a>02511 <span class="comment">   \brief Converts bit block to GAP. </span>
<a name="l02512"></a>02512 <span class="comment">   \param dest - Destinatio GAP buffer.</span>
<a name="l02513"></a>02513 <span class="comment">   \param src - Source bitblock buffer.</span>
<a name="l02514"></a>02514 <span class="comment">   \param bits - Number of bits to convert.</span>
<a name="l02515"></a>02515 <span class="comment">   \param dest_len - length of the dest. buffer.</span>
<a name="l02516"></a>02516 <span class="comment">   \return  New length of GAP block or 0 if conversion failed </span>
<a name="l02517"></a>02517 <span class="comment">   (insufficicent space).</span>
<a name="l02518"></a>02518 <span class="comment"></span>
<a name="l02519"></a>02519 <span class="comment">   @ingroup gapfunc</span>
<a name="l02520"></a>02520 <span class="comment">*/</span>
<a name="l02521"></a>02521 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; 
<a name="l02522"></a><a class="code" href="a00119.html#ga80d09bb6ab244e68ab0c1fdccc17b95b">02522</a>     <span class="keywordtype">unsigned</span> <a class="code" href="a00119.html#ga80d09bb6ab244e68ab0c1fdccc17b95b" title="Converts bit block to GAP.">bit_convert_to_gap</a>(T* BMRESTRICT dest, 
<a name="l02523"></a>02523                                 <span class="keyword">const</span> <span class="keywordtype">unsigned</span>* BMRESTRICT src, 
<a name="l02524"></a>02524                                 <a class="code" href="a00115.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a> bits, 
<a name="l02525"></a>02525                                 <span class="keywordtype">unsigned</span> dest_len)
<a name="l02526"></a>02526 {
<a name="l02527"></a>02527     <span class="keyword">register</span> T* BMRESTRICT pcurr = dest;
<a name="l02528"></a>02528     T* BMRESTRICT end = dest + dest_len; 
<a name="l02529"></a>02529     <span class="keyword">register</span> <span class="keywordtype">int</span> bitval = (*src) &amp; 1;
<a name="l02530"></a>02530 <span class="comment">//    *pcurr |= bitval;</span>
<a name="l02531"></a>02531     *pcurr = (T)bitval;
<a name="l02532"></a>02532 
<a name="l02533"></a>02533     ++pcurr;
<a name="l02534"></a>02534     *pcurr = 0;
<a name="l02535"></a>02535     <span class="keyword">register</span> <span class="keywordtype">unsigned</span> bit_idx = 0;
<a name="l02536"></a>02536     <span class="keyword">register</span> <span class="keywordtype">int</span> bitval_next;
<a name="l02537"></a>02537 
<a name="l02538"></a>02538     <span class="keywordtype">unsigned</span> val = *src;
<a name="l02539"></a>02539 
<a name="l02540"></a>02540     <span class="keywordflow">do</span>
<a name="l02541"></a>02541     {
<a name="l02542"></a>02542         <span class="comment">// We can fast pace if *src == 0 or *src = 0xffffffff</span>
<a name="l02543"></a>02543 
<a name="l02544"></a>02544         <span class="keywordflow">while</span> (val == 0 || val == 0xffffffff)
<a name="l02545"></a>02545         {
<a name="l02546"></a>02546            bitval_next = val ? 1 : 0;
<a name="l02547"></a>02547            <span class="keywordflow">if</span> (bitval != bitval_next)
<a name="l02548"></a>02548            {
<a name="l02549"></a>02549                *pcurr++ = (T)(bit_idx-1); 
<a name="l02550"></a>02550                <a class="code" href="a00092.html#aa44515fab0ace8928d1cb82009a95bf8">BM_ASSERT</a>((pcurr-1) == (dest+1) || *(pcurr-1) &gt; *(pcurr-2));
<a name="l02551"></a>02551                <span class="keywordflow">if</span> (pcurr &gt;= end)
<a name="l02552"></a>02552                {
<a name="l02553"></a>02553                    <span class="keywordflow">return</span> 0; <span class="comment">// OUT of memory</span>
<a name="l02554"></a>02554                }
<a name="l02555"></a>02555                bitval = bitval_next;
<a name="l02556"></a>02556            }
<a name="l02557"></a>02557            bit_idx += <span class="keyword">sizeof</span>(*src) * 8;
<a name="l02558"></a>02558            <span class="keywordflow">if</span> (bit_idx &gt;= bits)
<a name="l02559"></a>02559            {
<a name="l02560"></a>02560                <span class="keywordflow">goto</span> complete;
<a name="l02561"></a>02561            }
<a name="l02562"></a>02562            ++src;
<a name="l02563"></a>02563            val = *src;
<a name="l02564"></a>02564         }
<a name="l02565"></a>02565 
<a name="l02566"></a>02566 
<a name="l02567"></a>02567         <span class="keyword">register</span> <span class="keywordtype">unsigned</span> mask = 1;
<a name="l02568"></a>02568         <span class="keywordflow">while</span> (mask)
<a name="l02569"></a>02569         {
<a name="l02570"></a>02570             <span class="comment">// Now plain bitshifting. TODO: Optimization wanted.</span>
<a name="l02571"></a>02571 
<a name="l02572"></a>02572             bitval_next = val &amp; mask ? 1 : 0;
<a name="l02573"></a>02573             <span class="keywordflow">if</span> (bitval != bitval_next)
<a name="l02574"></a>02574             {
<a name="l02575"></a>02575                 *pcurr++ = (T)(bit_idx-1);
<a name="l02576"></a>02576                 <a class="code" href="a00092.html#aa44515fab0ace8928d1cb82009a95bf8">BM_ASSERT</a>((pcurr-1) == (dest+1) || *(pcurr-1) &gt; *(pcurr-2));
<a name="l02577"></a>02577                 bitval = bitval_next;
<a name="l02578"></a>02578                 <span class="keywordflow">if</span> (pcurr &gt;= end)
<a name="l02579"></a>02579                 {
<a name="l02580"></a>02580                     <span class="keywordflow">return</span> 0; <span class="comment">// OUT of memory</span>
<a name="l02581"></a>02581                 }
<a name="l02582"></a>02582             }
<a name="l02583"></a>02583 
<a name="l02584"></a>02584             mask &lt;&lt;= 1;
<a name="l02585"></a>02585             ++bit_idx;
<a name="l02586"></a>02586 
<a name="l02587"></a>02587         } <span class="comment">// while mask</span>
<a name="l02588"></a>02588 
<a name="l02589"></a>02589         <span class="keywordflow">if</span> (bit_idx &gt;= bits)
<a name="l02590"></a>02590         {
<a name="l02591"></a>02591             <span class="keywordflow">goto</span> complete;
<a name="l02592"></a>02592         }
<a name="l02593"></a>02593 
<a name="l02594"></a>02594         ++src;
<a name="l02595"></a>02595         val = *src;
<a name="l02596"></a>02596 
<a name="l02597"></a>02597     } <span class="keywordflow">while</span>(1);
<a name="l02598"></a>02598 
<a name="l02599"></a>02599 complete:
<a name="l02600"></a>02600     *pcurr = (T)(bit_idx-1);
<a name="l02601"></a>02601     <span class="keywordtype">unsigned</span> len = (unsigned)(pcurr - dest);
<a name="l02602"></a>02602     *dest = (T)((*dest &amp; 7) + (len &lt;&lt; 3));
<a name="l02603"></a>02603     <span class="keywordflow">return</span> len;
<a name="l02604"></a>02604 }
<a name="l02605"></a>02605 
<a name="l02606"></a>02606 <span class="comment"></span>
<a name="l02607"></a>02607 <span class="comment">/*!</span>
<a name="l02608"></a>02608 <span class="comment">   \brief Iterate gap block as delta-bits with a functor </span>
<a name="l02609"></a>02609 <span class="comment">   @ingroup gapfunc</span>
<a name="l02610"></a>02610 <span class="comment">*/</span>
<a name="l02611"></a>02611 <span class="keyword">template</span>&lt;<span class="keyword">class</span> T, <span class="keyword">class</span> F&gt;
<a name="l02612"></a><a class="code" href="a00119.html#ga11bc26da8533752bb23756632fd30a00">02612</a> <span class="keywordtype">void</span> <a class="code" href="a00119.html#ga11bc26da8533752bb23756632fd30a00" title="Iterate gap block as delta-bits with a functor.">for_each_gap_dbit</a>(<span class="keyword">const</span> T* buf, F&amp; func)
<a name="l02613"></a>02613 {
<a name="l02614"></a>02614     <span class="keyword">const</span> T* pcurr = buf;
<a name="l02615"></a>02615     <span class="keyword">const</span> T* pend = pcurr + (*pcurr &gt;&gt; 3);
<a name="l02616"></a>02616 
<a name="l02617"></a>02617     ++pcurr;
<a name="l02618"></a>02618 
<a name="l02619"></a>02619     <span class="keywordtype">unsigned</span> prev = 0;
<a name="l02620"></a>02620     <span class="keywordtype">unsigned</span> first_inc;
<a name="l02621"></a>02621 
<a name="l02622"></a>02622     <span class="keywordflow">if</span> (*buf &amp; 1)
<a name="l02623"></a>02623     {
<a name="l02624"></a>02624         first_inc = 0;
<a name="l02625"></a>02625         <span class="keywordtype">unsigned</span> to = *pcurr;
<a name="l02626"></a>02626         <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i = 0; i &lt;= to; ++i) 
<a name="l02627"></a>02627         {
<a name="l02628"></a>02628             func(1);
<a name="l02629"></a>02629         }
<a name="l02630"></a>02630         prev = to;
<a name="l02631"></a>02631         ++pcurr;
<a name="l02632"></a>02632     }
<a name="l02633"></a>02633     <span class="keywordflow">else</span>
<a name="l02634"></a>02634     {
<a name="l02635"></a>02635         first_inc = 1;
<a name="l02636"></a>02636     }
<a name="l02637"></a>02637     ++pcurr;  <span class="comment">// set GAP to 1</span>
<a name="l02638"></a>02638 
<a name="l02639"></a>02639     <span class="keywordflow">while</span> (pcurr &lt;= pend)
<a name="l02640"></a>02640     {
<a name="l02641"></a>02641         <span class="keywordtype">unsigned</span> from = *(pcurr-1)+1;
<a name="l02642"></a>02642         <span class="keywordtype">unsigned</span> to = *pcurr;
<a name="l02643"></a>02643         <span class="keywordflow">if</span> (first_inc)
<a name="l02644"></a>02644         {
<a name="l02645"></a>02645             func(from - prev + first_inc);
<a name="l02646"></a>02646             first_inc = 0;
<a name="l02647"></a>02647         }
<a name="l02648"></a>02648         <span class="keywordflow">else</span>
<a name="l02649"></a>02649         {
<a name="l02650"></a>02650             func(from - prev);
<a name="l02651"></a>02651         }
<a name="l02652"></a>02652 
<a name="l02653"></a>02653         <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i = from+1; i &lt;= to; ++i) 
<a name="l02654"></a>02654         {
<a name="l02655"></a>02655             func(1);
<a name="l02656"></a>02656         }
<a name="l02657"></a>02657         prev = to;
<a name="l02658"></a>02658         pcurr += 2; <span class="comment">// jump to the next positive GAP</span>
<a name="l02659"></a>02659     }
<a name="l02660"></a>02660 }
<a name="l02661"></a>02661 <span class="comment"></span>
<a name="l02662"></a>02662 <span class="comment">/*!</span>
<a name="l02663"></a>02663 <span class="comment">   \brief Convert gap block into array of ints corresponding to 1 bits</span>
<a name="l02664"></a>02664 <span class="comment">   @ingroup gapfunc</span>
<a name="l02665"></a>02665 <span class="comment">*/</span>
<a name="l02666"></a>02666 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> D, <span class="keyword">typename</span> T&gt;
<a name="l02667"></a><a class="code" href="a00119.html#ga5cd7e0cfee401da1b8f702151c083b27">02667</a> D <a class="code" href="a00119.html#ga5cd7e0cfee401da1b8f702151c083b27" title="Convert gap block into array of ints corresponding to 1 bits.">gap_convert_to_arr</a>(D* BMRESTRICT       dest, 
<a name="l02668"></a>02668                      <span class="keyword">const</span> T* BMRESTRICT buf,
<a name="l02669"></a>02669                      <span class="keywordtype">unsigned</span>            dest_len,
<a name="l02670"></a>02670                      <span class="keywordtype">bool</span>                invert = <span class="keyword">false</span>)
<a name="l02671"></a>02671 {
<a name="l02672"></a>02672     <span class="keyword">register</span> <span class="keyword">const</span> T* BMRESTRICT pcurr = buf;
<a name="l02673"></a>02673     <span class="keyword">register</span> <span class="keyword">const</span> T* pend = pcurr + (*pcurr &gt;&gt; 3);
<a name="l02674"></a>02674 
<a name="l02675"></a>02675     D* BMRESTRICT dest_curr = dest;
<a name="l02676"></a>02676     ++pcurr;
<a name="l02677"></a>02677 
<a name="l02678"></a>02678     <span class="keywordtype">int</span> bitval = (*buf) &amp; 1;
<a name="l02679"></a>02679     <span class="keywordflow">if</span> (invert) 
<a name="l02680"></a>02680         bitval = !bitval; <span class="comment">// invert the GAP buffer</span>
<a name="l02681"></a>02681 
<a name="l02682"></a>02682     <span class="keywordflow">if</span> (bitval)
<a name="l02683"></a>02683     {
<a name="l02684"></a>02684         <span class="keywordflow">if</span> (<span class="keywordtype">unsigned</span>(*pcurr + 1) &gt;= dest_len)
<a name="l02685"></a>02685             <span class="keywordflow">return</span> 0; <span class="comment">// insufficient space</span>
<a name="l02686"></a>02686         dest_len -= *pcurr;
<a name="l02687"></a>02687         T to = *pcurr;
<a name="l02688"></a>02688         <span class="keywordflow">for</span> (T i = 0; ;++i) 
<a name="l02689"></a>02689         {
<a name="l02690"></a>02690             *dest_curr++ = i;
<a name="l02691"></a>02691             <span class="keywordflow">if</span> (i == to) <span class="keywordflow">break</span>;
<a name="l02692"></a>02692         }
<a name="l02693"></a>02693         ++pcurr;
<a name="l02694"></a>02694     }
<a name="l02695"></a>02695     ++pcurr;  <span class="comment">// set GAP to 1</span>
<a name="l02696"></a>02696 
<a name="l02697"></a>02697     <span class="keywordflow">while</span> (pcurr &lt;= pend)
<a name="l02698"></a>02698     {
<a name="l02699"></a>02699         <span class="keywordtype">unsigned</span> pending = *pcurr - *(pcurr-1);
<a name="l02700"></a>02700         <span class="keywordflow">if</span> (pending &gt;= dest_len)
<a name="l02701"></a>02701             <span class="keywordflow">return</span> 0;
<a name="l02702"></a>02702         dest_len -= pending;
<a name="l02703"></a>02703         T from = *(pcurr-1)+1;
<a name="l02704"></a>02704         T to = *pcurr;
<a name="l02705"></a>02705         <span class="keywordflow">for</span> (T i = from; ;++i) 
<a name="l02706"></a>02706         {
<a name="l02707"></a>02707             *dest_curr++ = i;
<a name="l02708"></a>02708             <span class="keywordflow">if</span> (i == to) <span class="keywordflow">break</span>;
<a name="l02709"></a>02709         }
<a name="l02710"></a>02710         pcurr += 2; <span class="comment">// jump to the next positive GAP</span>
<a name="l02711"></a>02711     }
<a name="l02712"></a>02712     <span class="keywordflow">return</span> (D) (dest_curr - dest);
<a name="l02713"></a>02713 }
<a name="l02714"></a>02714 
<a name="l02715"></a>02715 
<a name="l02716"></a>02716 <span class="comment"></span>
<a name="l02717"></a>02717 <span class="comment">/*! </span>
<a name="l02718"></a>02718 <span class="comment">    @brief Bitcount for bit string</span>
<a name="l02719"></a>02719 <span class="comment">    </span>
<a name="l02720"></a>02720 <span class="comment">    Function calculates number of 1 bits in the given array of words.</span>
<a name="l02721"></a>02721 <span class="comment">    Make sure the addresses are aligned.</span>
<a name="l02722"></a>02722 <span class="comment"></span>
<a name="l02723"></a>02723 <span class="comment">    @ingroup bitfunc </span>
<a name="l02724"></a>02724 <span class="comment">*/</span>
<a name="l02725"></a>02725 <span class="keyword">inline</span> 
<a name="l02726"></a><a class="code" href="a00120.html#gab30df14a61f036d690c091878feaff1c">02726</a> <a class="code" href="a00115.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a> <a class="code" href="a00120.html#gab30df14a61f036d690c091878feaff1c" title="Bitcount for bit string.">bit_block_calc_count</a>(<span class="keyword">const</span> <a class="code" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a>* block, 
<a name="l02727"></a>02727                               <span class="keyword">const</span> <a class="code" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a>* block_end)
<a name="l02728"></a>02728 {
<a name="l02729"></a>02729     <a class="code" href="a00092.html#aa44515fab0ace8928d1cb82009a95bf8">BM_ASSERT</a>(block &lt; block_end);
<a name="l02730"></a>02730     <a class="code" href="a00115.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a> count = 0;
<a name="l02731"></a>02731 
<a name="l02732"></a>02732 <span class="preprocessor">#ifdef BMVECTOPT</span>
<a name="l02733"></a>02733 <span class="preprocessor"></span>    count = <a class="code" href="a00098.html#ae022e7bc509d97359a348393a6b25b99">VECT_BITCOUNT</a>(block, block_end);
<a name="l02734"></a>02734 <span class="preprocessor">#else  </span>
<a name="l02735"></a>02735 <span class="preprocessor"></span><span class="preprocessor">#ifdef BM64OPT</span>
<a name="l02736"></a>02736 <span class="preprocessor"></span>    <span class="comment">// 64-bit optimized algorithm. No sparse vect opt.</span>
<a name="l02737"></a>02737     <span class="comment">// instead it uses 4-way parallel pipelined version</span>
<a name="l02738"></a>02738 
<a name="l02739"></a>02739     <span class="keyword">const</span> <a class="code" href="a00115.html#a1f6a6dd108cd9e9f4fb284043ef518fe">bm::id64_t</a>* b1 = (<a class="code" href="a00115.html#a1f6a6dd108cd9e9f4fb284043ef518fe">bm::id64_t</a>*) block;
<a name="l02740"></a>02740     <span class="keyword">const</span> <a class="code" href="a00115.html#a1f6a6dd108cd9e9f4fb284043ef518fe">bm::id64_t</a>* b2 = (<a class="code" href="a00115.html#a1f6a6dd108cd9e9f4fb284043ef518fe">bm::id64_t</a>*) block_end;
<a name="l02741"></a>02741     <span class="keywordflow">do</span> 
<a name="l02742"></a>02742     {
<a name="l02743"></a>02743         count += bitcount64_4way(b1[0], b1[1], b1[2], b1[3]);
<a name="l02744"></a>02744         b1 += 4;
<a name="l02745"></a>02745     } <span class="keywordflow">while</span> (b1 &lt; b2);
<a name="l02746"></a>02746 <span class="preprocessor">#else</span>
<a name="l02747"></a>02747 <span class="preprocessor"></span>    <span class="comment">// For 32 bit code the fastest method is</span>
<a name="l02748"></a>02748     <span class="comment">// to use bitcount table for each byte in the block.</span>
<a name="l02749"></a>02749     <span class="comment">// As optimization for sparse bitsets used bits accumulator</span>
<a name="l02750"></a>02750     <span class="comment">// to collect ON bits using bitwise OR. </span>
<a name="l02751"></a>02751     <a class="code" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a>  acc = *block++;
<a name="l02752"></a>02752     <span class="keywordflow">do</span>
<a name="l02753"></a>02753     {
<a name="l02754"></a>02754         <a class="code" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> in = *block++;
<a name="l02755"></a>02755         <a class="code" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> acc_prev = acc;
<a name="l02756"></a>02756         acc |= in;
<a name="l02757"></a>02757         <span class="keywordflow">if</span> (acc_prev &amp;= in)  <span class="comment">// accumulator miss: counting bits</span>
<a name="l02758"></a>02758         {
<a name="l02759"></a>02759             <a class="code" href="a00120.html#ga967f6a5264f47d8adb93f6bdf8cdc129">BM_INCWORD_BITCOUNT</a>(count, acc);
<a name="l02760"></a>02760             acc = acc_prev;
<a name="l02761"></a>02761         }
<a name="l02762"></a>02762     } <span class="keywordflow">while</span> (block &lt; block_end);
<a name="l02763"></a>02763 
<a name="l02764"></a>02764     <a class="code" href="a00120.html#ga967f6a5264f47d8adb93f6bdf8cdc129">BM_INCWORD_BITCOUNT</a>(count, acc); <span class="comment">// count-in remaining accumulator </span>
<a name="l02765"></a>02765 
<a name="l02766"></a>02766 <span class="preprocessor">#endif</span>
<a name="l02767"></a>02767 <span class="preprocessor"></span><span class="preprocessor">#endif  </span>
<a name="l02768"></a>02768 <span class="preprocessor"></span>    <span class="keywordflow">return</span> count;
<a name="l02769"></a>02769 }
<a name="l02770"></a>02770 
<a name="l02771"></a>02771 
<a name="l02772"></a>02772 <span class="comment"></span>
<a name="l02773"></a>02773 <span class="comment">/*!</span>
<a name="l02774"></a>02774 <span class="comment">    Function calculates number of times when bit value changed </span>
<a name="l02775"></a>02775 <span class="comment">    (1-0 or 0-1).</span>
<a name="l02776"></a>02776 <span class="comment">    </span>
<a name="l02777"></a>02777 <span class="comment">    For 001 result is 2</span>
<a name="l02778"></a>02778 <span class="comment">        010 - 3</span>
<a name="l02779"></a>02779 <span class="comment">        011 - 2</span>
<a name="l02780"></a>02780 <span class="comment">        111 - 1</span>
<a name="l02781"></a>02781 <span class="comment">    </span>
<a name="l02782"></a>02782 <span class="comment">    @ingroup bitfunc </span>
<a name="l02783"></a>02783 <span class="comment">*/</span>
<a name="l02784"></a>02784 
<a name="l02785"></a>02785 <span class="keyword">inline</span> 
<a name="l02786"></a><a class="code" href="a00120.html#gaafc87c4764bb30d95ba4088064a404e3">02786</a> <a class="code" href="a00115.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a> <a class="code" href="a00120.html#gaafc87c4764bb30d95ba4088064a404e3">bit_count_change</a>(<a class="code" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> w)
<a name="l02787"></a>02787 {
<a name="l02788"></a>02788     <span class="keywordtype">unsigned</span> count = 1;
<a name="l02789"></a>02789     w ^= (w &gt;&gt; 1);
<a name="l02790"></a>02790 
<a name="l02791"></a>02791     <a class="code" href="a00120.html#ga967f6a5264f47d8adb93f6bdf8cdc129">BM_INCWORD_BITCOUNT</a>(count, w);
<a name="l02792"></a>02792     count -= (w &gt;&gt; ((<span class="keyword">sizeof</span>(w) * 8) - 1));
<a name="l02793"></a>02793     <span class="keywordflow">return</span> count;
<a name="l02794"></a>02794 }
<a name="l02795"></a>02795 
<a name="l02796"></a>02796 <span class="comment"></span>
<a name="l02797"></a>02797 <span class="comment">/*!</span>
<a name="l02798"></a>02798 <span class="comment">    Function calculates number of times when bit value changed </span>
<a name="l02799"></a>02799 <span class="comment">    @internal</span>
<a name="l02800"></a>02800 <span class="comment">*/</span>
<a name="l02801"></a>02801 <span class="keyword">inline</span>
<a name="l02802"></a><a class="code" href="a00115.html#ae2222be6fd45b4bab5100ce70e3b4f88">02802</a> <span class="keywordtype">void</span> <a class="code" href="a00115.html#ae2222be6fd45b4bab5100ce70e3b4f88">bit_count_change32</a>(<span class="keyword">const</span> <a class="code" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a>* block, 
<a name="l02803"></a>02803                         <span class="keyword">const</span> <a class="code" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a>* block_end,
<a name="l02804"></a>02804                         <span class="keywordtype">unsigned</span>*         bit_count,
<a name="l02805"></a>02805                         <span class="keywordtype">unsigned</span>*         gap_count)
<a name="l02806"></a>02806 {
<a name="l02807"></a>02807     <a class="code" href="a00092.html#aa44515fab0ace8928d1cb82009a95bf8">BM_ASSERT</a>(block &lt; block_end);
<a name="l02808"></a>02808     <a class="code" href="a00092.html#aa44515fab0ace8928d1cb82009a95bf8">BM_ASSERT</a>(bit_count);
<a name="l02809"></a>02809     <a class="code" href="a00092.html#aa44515fab0ace8928d1cb82009a95bf8">BM_ASSERT</a>(gap_count);
<a name="l02810"></a>02810     
<a name="l02811"></a>02811     *gap_count = 1;
<a name="l02812"></a>02812     *bit_count = 0;
<a name="l02813"></a>02813 
<a name="l02814"></a>02814     <a class="code" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a>  w, w0, w_prev, w_l;     
<a name="l02815"></a>02815     w = w0 = *block;
<a name="l02816"></a>02816     
<a name="l02817"></a>02817     <a class="code" href="a00120.html#ga967f6a5264f47d8adb93f6bdf8cdc129">BM_INCWORD_BITCOUNT</a>(*bit_count, w);
<a name="l02818"></a>02818     
<a name="l02819"></a>02819     <span class="keyword">const</span> <span class="keywordtype">int</span> w_shift = <span class="keyword">sizeof</span>(w) * 8 - 1;    
<a name="l02820"></a>02820     w ^= (w &gt;&gt; 1);
<a name="l02821"></a>02821     <a class="code" href="a00120.html#ga967f6a5264f47d8adb93f6bdf8cdc129">BM_INCWORD_BITCOUNT</a>(*gap_count, w);
<a name="l02822"></a>02822     *gap_count -= (w_prev = (w0 &gt;&gt; w_shift)); <span class="comment">// negative value correction</span>
<a name="l02823"></a>02823 
<a name="l02824"></a>02824     <span class="keywordflow">for</span> (++block ;block &lt; block_end; ++block)
<a name="l02825"></a>02825     {
<a name="l02826"></a>02826         w = w0 = *block;
<a name="l02827"></a>02827         ++(*gap_count);
<a name="l02828"></a>02828 
<a name="l02829"></a>02829         <span class="keywordflow">if</span> (!w)
<a name="l02830"></a>02830         {       
<a name="l02831"></a>02831             *gap_count -= !w_prev;
<a name="l02832"></a>02832             w_prev = 0;
<a name="l02833"></a>02833         }
<a name="l02834"></a>02834         <span class="keywordflow">else</span>
<a name="l02835"></a>02835         {
<a name="l02836"></a>02836             <a class="code" href="a00120.html#ga967f6a5264f47d8adb93f6bdf8cdc129">BM_INCWORD_BITCOUNT</a>(*bit_count, w);
<a name="l02837"></a>02837         
<a name="l02838"></a>02838             w ^= (w &gt;&gt; 1);
<a name="l02839"></a>02839             <a class="code" href="a00120.html#ga967f6a5264f47d8adb93f6bdf8cdc129">BM_INCWORD_BITCOUNT</a>(*gap_count, w);
<a name="l02840"></a>02840             
<a name="l02841"></a>02841             w_l = w0 &amp; 1;
<a name="l02842"></a>02842             *gap_count -= (w0 &gt;&gt; w_shift);  <span class="comment">// negative value correction</span>
<a name="l02843"></a>02843             *gap_count -= !(w_prev ^ w_l);  <span class="comment">// word border correction</span>
<a name="l02844"></a>02844             
<a name="l02845"></a>02845             w_prev = (w0 &gt;&gt; w_shift);
<a name="l02846"></a>02846         }
<a name="l02847"></a>02847     } <span class="comment">// for</span>
<a name="l02848"></a>02848 
<a name="l02849"></a>02849 }
<a name="l02850"></a>02850 
<a name="l02851"></a>02851 <span class="comment"></span>
<a name="l02852"></a>02852 <span class="comment">/*!</span>
<a name="l02853"></a>02853 <span class="comment">    Function calculates number of times when bit value changed </span>
<a name="l02854"></a>02854 <span class="comment">    (1-0 or 0-1) in the bit block.</span>
<a name="l02855"></a>02855 <span class="comment">    Also calulates number of bits ON.</span>
<a name="l02856"></a>02856 <span class="comment">    </span>
<a name="l02857"></a>02857 <span class="comment">    @param bit_count - OUT total number of bits ON</span>
<a name="l02858"></a>02858 <span class="comment">    </span>
<a name="l02859"></a>02859 <span class="comment">    @return number of 1-0, 0-1 transitions</span>
<a name="l02860"></a>02860 <span class="comment">        </span>
<a name="l02861"></a>02861 <span class="comment">    @ingroup bitfunc </span>
<a name="l02862"></a>02862 <span class="comment">*/</span>
<a name="l02863"></a>02863 <span class="keyword">inline</span> 
<a name="l02864"></a><a class="code" href="a00120.html#gaca91016aeb08ae1b610d6d407aae0e4c">02864</a> <a class="code" href="a00115.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a> <a class="code" href="a00120.html#gaca91016aeb08ae1b610d6d407aae0e4c">bit_block_calc_count_change</a>(<span class="keyword">const</span> <a class="code" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a>* block, 
<a name="l02865"></a>02865                                      <span class="keyword">const</span> <a class="code" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a>* block_end,
<a name="l02866"></a>02866                                      <span class="keywordtype">unsigned</span>*         bit_count)
<a name="l02867"></a>02867 {
<a name="l02868"></a>02868 <span class="preprocessor">#if defined(BMSSE2OPT) || defined(BMSSE42OPT)</span>
<a name="l02869"></a>02869 <span class="preprocessor"></span>
<a name="l02870"></a>02870 <span class="preprocessor">#ifdef BMSSE42OPT</span>
<a name="l02871"></a>02871 <span class="preprocessor"></span>    <span class="keywordflow">return</span> <a class="code" href="a00123.html#gad686391db4cdc6382ae6785f62981474">sse4_bit_block_calc_count_change</a>(
<a name="l02872"></a>02872         (<span class="keyword">const</span> __m128i*)block, (<span class="keyword">const</span> __m128i*)block_end, bit_count);
<a name="l02873"></a>02873 <span class="preprocessor">#else</span>
<a name="l02874"></a>02874 <span class="preprocessor"></span><span class="preprocessor"># ifdef BMSSE2OPT</span>
<a name="l02875"></a>02875 <span class="preprocessor"></span>    <span class="keywordflow">return</span> <a class="code" href="a00115.html#a0479b7b6704c6ab64396e2365b8b5fa7">sse2_bit_block_calc_count_change</a>(
<a name="l02876"></a>02876         (<span class="keyword">const</span> __m128i*)block, (<span class="keyword">const</span> __m128i*)block_end, bit_count);
<a name="l02877"></a>02877 <span class="preprocessor"># endif</span>
<a name="l02878"></a>02878 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l02879"></a>02879 <span class="preprocessor"></span>
<a name="l02880"></a>02880 <span class="preprocessor">#else // non-SSE code</span>
<a name="l02881"></a>02881 <span class="preprocessor"></span>
<a name="l02882"></a>02882     <a class="code" href="a00092.html#aa44515fab0ace8928d1cb82009a95bf8">BM_ASSERT</a>(block &lt; block_end);
<a name="l02883"></a>02883     <a class="code" href="a00092.html#aa44515fab0ace8928d1cb82009a95bf8">BM_ASSERT</a>(bit_count);
<a name="l02884"></a>02884     
<a name="l02885"></a>02885     
<a name="l02886"></a>02886 <span class="preprocessor">#ifdef BM64OPT</span>
<a name="l02887"></a>02887 <span class="preprocessor"></span>    <a class="code" href="a00115.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a> count = 1;
<a name="l02888"></a>02888     *bit_count = 0;
<a name="l02889"></a>02889 
<a name="l02890"></a>02890     <span class="comment">// 64-bit optimized algorithm.</span>
<a name="l02891"></a>02891 
<a name="l02892"></a>02892     <span class="keyword">const</span> <a class="code" href="a00115.html#a1f6a6dd108cd9e9f4fb284043ef518fe">bm::id64_t</a>* b1 = (<a class="code" href="a00115.html#a1f6a6dd108cd9e9f4fb284043ef518fe">bm::id64_t</a>*) block;
<a name="l02893"></a>02893     <span class="keyword">const</span> <a class="code" href="a00115.html#a1f6a6dd108cd9e9f4fb284043ef518fe">bm::id64_t</a>* b2 = (<a class="code" href="a00115.html#a1f6a6dd108cd9e9f4fb284043ef518fe">bm::id64_t</a>*) block_end;
<a name="l02894"></a>02894 
<a name="l02895"></a>02895     <a class="code" href="a00115.html#a1f6a6dd108cd9e9f4fb284043ef518fe">bm::id64_t</a> w, w0, w_prev, w_l;
<a name="l02896"></a>02896     w = w0 = *b1;
<a name="l02897"></a>02897     
<a name="l02898"></a>02898     *bit_count = word_bitcount64(w);
<a name="l02899"></a>02899     
<a name="l02900"></a>02900     <span class="keyword">const</span> <span class="keywordtype">int</span> w_shift = <span class="keyword">sizeof</span>(w) * 8 - 1;
<a name="l02901"></a>02901     w ^= (w &gt;&gt; 1);
<a name="l02902"></a>02902     count += word_bitcount64(w);
<a name="l02903"></a>02903     count -= (w_prev = (w0 &gt;&gt; w_shift)); <span class="comment">// negative value correction</span>
<a name="l02904"></a>02904 
<a name="l02905"></a>02905     
<a name="l02906"></a>02906     <span class="keywordflow">for</span> (++b1 ;b1 &lt; b2; ++b1)
<a name="l02907"></a>02907     {
<a name="l02908"></a>02908         w = w0 = *b1;
<a name="l02909"></a>02909         
<a name="l02910"></a>02910         ++count;
<a name="l02911"></a>02911         
<a name="l02912"></a>02912         <span class="keywordflow">if</span> (!w)
<a name="l02913"></a>02913         {
<a name="l02914"></a>02914             count -= !w_prev;
<a name="l02915"></a>02915             w_prev = 0;
<a name="l02916"></a>02916         }
<a name="l02917"></a>02917         <span class="keywordflow">else</span>
<a name="l02918"></a>02918         {
<a name="l02919"></a>02919             *bit_count += word_bitcount64(w);
<a name="l02920"></a>02920             w ^= (w &gt;&gt; 1);
<a name="l02921"></a>02921             count += word_bitcount64(w);
<a name="l02922"></a>02922             
<a name="l02923"></a>02923             w_l = w0 &amp; 1;
<a name="l02924"></a>02924             count -= (w0 &gt;&gt; w_shift);  <span class="comment">// negative value correction</span>
<a name="l02925"></a>02925             count -= !(w_prev ^ w_l);  <span class="comment">// word border correction</span>
<a name="l02926"></a>02926             
<a name="l02927"></a>02927             w_prev = (w0 &gt;&gt; w_shift);
<a name="l02928"></a>02928         }
<a name="l02929"></a>02929     } <span class="comment">// for</span>
<a name="l02930"></a>02930     <span class="keywordflow">return</span> count;
<a name="l02931"></a>02931 
<a name="l02932"></a>02932 <span class="preprocessor">#else</span>
<a name="l02933"></a>02933 <span class="preprocessor"></span>    <span class="keywordtype">unsigned</span> gap_count;
<a name="l02934"></a>02934     <a class="code" href="a00115.html#ae2222be6fd45b4bab5100ce70e3b4f88">bit_count_change32</a>(block, block_end, bit_count, &amp;gap_count);
<a name="l02935"></a>02935     <span class="keywordflow">return</span> gap_count;
<a name="l02936"></a>02936 <span class="preprocessor">#endif</span>
<a name="l02937"></a>02937 <span class="preprocessor"></span>
<a name="l02938"></a>02938 <span class="preprocessor">#endif</span>
<a name="l02939"></a>02939 <span class="preprocessor"></span>}
<a name="l02940"></a>02940 
<a name="l02941"></a>02941 <span class="comment"></span>
<a name="l02942"></a>02942 <span class="comment">/*!</span>
<a name="l02943"></a>02943 <span class="comment">    Function calculates number of 1 bits in the given array of words in</span>
<a name="l02944"></a>02944 <span class="comment">    the range between left anf right bits (borders included)</span>
<a name="l02945"></a>02945 <span class="comment">    Make sure the addresses are aligned.</span>
<a name="l02946"></a>02946 <span class="comment"></span>
<a name="l02947"></a>02947 <span class="comment">    @ingroup bitfunc</span>
<a name="l02948"></a>02948 <span class="comment">*/</span>
<a name="l02949"></a>02949 <span class="keyword">inline</span> 
<a name="l02950"></a><a class="code" href="a00120.html#ga2485f707b2629c5ce7681cf9fe385b91">02950</a> <a class="code" href="a00115.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a> <a class="code" href="a00120.html#ga2485f707b2629c5ce7681cf9fe385b91">bit_block_calc_count_range</a>(<span class="keyword">const</span> <a class="code" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a>* block,
<a name="l02951"></a>02951                                     <a class="code" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> left,
<a name="l02952"></a>02952                                     <a class="code" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> right)
<a name="l02953"></a>02953 {
<a name="l02954"></a>02954     <a class="code" href="a00092.html#aa44515fab0ace8928d1cb82009a95bf8">BM_ASSERT</a>(left &lt;= right);
<a name="l02955"></a>02955     <span class="keywordtype">unsigned</span> nword, nbit;    
<a name="l02956"></a>02956     nbit = left &amp; <a class="code" href="a00115.html#addbf345be3733d5e4575d71733ed1da8">bm::set_word_mask</a>;
<a name="l02957"></a>02957     <span class="keyword">const</span> <a class="code" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a>* word = 
<a name="l02958"></a>02958         block + (nword = unsigned(left &gt;&gt; <a class="code" href="a00115.html#a83d76bccf6fe3770f32d5ba11d2a37ad">bm::set_word_shift</a>));
<a name="l02959"></a>02959     <span class="keywordflow">if</span> (left == right)  <span class="comment">// special case (only 1 bit to check)</span>
<a name="l02960"></a>02960     {
<a name="l02961"></a>02961         <span class="keywordflow">return</span> (*word &gt;&gt; nbit) &amp; 1;
<a name="l02962"></a>02962     }
<a name="l02963"></a>02963     <a class="code" href="a00115.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a> count = 0;
<a name="l02964"></a>02964 
<a name="l02965"></a>02965     <span class="keywordtype">unsigned</span> acc;
<a name="l02966"></a>02966     <span class="keywordtype">unsigned</span> bitcount = right - left + 1;
<a name="l02967"></a>02967 
<a name="l02968"></a>02968     <span class="keywordflow">if</span> (nbit) <span class="comment">// starting position is not aligned</span>
<a name="l02969"></a>02969     {
<a name="l02970"></a>02970         <span class="keywordtype">unsigned</span> right_margin = nbit + (right - left);
<a name="l02971"></a>02971 
<a name="l02972"></a>02972         <span class="keywordflow">if</span> (right_margin &lt; 32)
<a name="l02973"></a>02973         {
<a name="l02974"></a>02974             <span class="keywordtype">unsigned</span> mask =
<a name="l02975"></a>02975                 <a class="code" href="a00040.html" title="Structure keeps all-left/right ON bits masks.">block_set_table&lt;true&gt;::_right</a>[nbit] &amp;
<a name="l02976"></a>02976                 <a class="code" href="a00040.html" title="Structure keeps all-left/right ON bits masks.">block_set_table&lt;true&gt;::_left</a>[right_margin];
<a name="l02977"></a>02977             acc = *word &amp; mask;
<a name="l02978"></a>02978             
<a name="l02979"></a>02979             <a class="code" href="a00120.html#ga967f6a5264f47d8adb93f6bdf8cdc129">BM_INCWORD_BITCOUNT</a>(count, acc);
<a name="l02980"></a>02980             <span class="keywordflow">return</span> count;
<a name="l02981"></a>02981         }
<a name="l02982"></a>02982         <span class="keywordflow">else</span>
<a name="l02983"></a>02983         {
<a name="l02984"></a>02984             acc = *word &amp; <a class="code" href="a00040.html" title="Structure keeps all-left/right ON bits masks.">block_set_table&lt;true&gt;::_right</a>[nbit];
<a name="l02985"></a>02985             <a class="code" href="a00120.html#ga967f6a5264f47d8adb93f6bdf8cdc129">BM_INCWORD_BITCOUNT</a>(count, acc);
<a name="l02986"></a>02986             bitcount -= 32 - nbit;
<a name="l02987"></a>02987         }
<a name="l02988"></a>02988         ++word;
<a name="l02989"></a>02989     }
<a name="l02990"></a>02990 
<a name="l02991"></a>02991     <span class="comment">// now when we are word aligned, we can count bits the usual way</span>
<a name="l02992"></a>02992     <span class="keywordflow">for</span> ( ;bitcount &gt;= 32; bitcount -= 32)
<a name="l02993"></a>02993     {
<a name="l02994"></a>02994         acc = *word++;
<a name="l02995"></a>02995         <a class="code" href="a00120.html#ga967f6a5264f47d8adb93f6bdf8cdc129">BM_INCWORD_BITCOUNT</a>(count, acc);
<a name="l02996"></a>02996     }
<a name="l02997"></a>02997 
<a name="l02998"></a>02998     <span class="keywordflow">if</span> (bitcount)  <span class="comment">// we have a tail to count</span>
<a name="l02999"></a>02999     {
<a name="l03000"></a>03000         acc = (*word) &amp; <a class="code" href="a00040.html" title="Structure keeps all-left/right ON bits masks.">block_set_table&lt;true&gt;::_left</a>[bitcount-1];
<a name="l03001"></a>03001         <a class="code" href="a00120.html#ga967f6a5264f47d8adb93f6bdf8cdc129">BM_INCWORD_BITCOUNT</a>(count, acc);
<a name="l03002"></a>03002     }
<a name="l03003"></a>03003 
<a name="l03004"></a>03004     <span class="keywordflow">return</span> count;
<a name="l03005"></a>03005 }
<a name="l03006"></a>03006 
<a name="l03007"></a>03007 <span class="comment"></span>
<a name="l03008"></a>03008 <span class="comment">/*!</span>
<a name="l03009"></a>03009 <span class="comment">    Function calculates if there is any number of 1 bits </span>
<a name="l03010"></a>03010 <span class="comment">    in the given array of words in the range between left anf right bits </span>
<a name="l03011"></a>03011 <span class="comment">    (borders included). Make sure the addresses are aligned.</span>
<a name="l03012"></a>03012 <span class="comment"></span>
<a name="l03013"></a>03013 <span class="comment">    @ingroup bitfunc</span>
<a name="l03014"></a>03014 <span class="comment">*/</span>
<a name="l03015"></a>03015 <span class="keyword">inline</span> 
<a name="l03016"></a><a class="code" href="a00120.html#ga503e0f3e79f819d9b58e4b0e905be116">03016</a> <a class="code" href="a00115.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a> <a class="code" href="a00120.html#ga503e0f3e79f819d9b58e4b0e905be116">bit_block_any_range</a>(<span class="keyword">const</span> <a class="code" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a>* block,
<a name="l03017"></a>03017                              <a class="code" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> left,
<a name="l03018"></a>03018                              <a class="code" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> right)
<a name="l03019"></a>03019 {
<a name="l03020"></a>03020     <a class="code" href="a00092.html#aa44515fab0ace8928d1cb82009a95bf8">BM_ASSERT</a>(left &lt;= right);
<a name="l03021"></a>03021     
<a name="l03022"></a>03022     <span class="keywordtype">unsigned</span> nbit  = left; <span class="comment">// unsigned(left &amp; bm::set_block_mask);</span>
<a name="l03023"></a>03023     <span class="keywordtype">unsigned</span> nword = unsigned(nbit &gt;&gt; <a class="code" href="a00115.html#a83d76bccf6fe3770f32d5ba11d2a37ad">bm::set_word_shift</a>);
<a name="l03024"></a>03024     nbit &amp;= <a class="code" href="a00115.html#addbf345be3733d5e4575d71733ed1da8">bm::set_word_mask</a>;
<a name="l03025"></a>03025 
<a name="l03026"></a>03026     <span class="keyword">const</span> <a class="code" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a>* word = block + nword;
<a name="l03027"></a>03027 
<a name="l03028"></a>03028     <span class="keywordflow">if</span> (left == right)  <span class="comment">// special case (only 1 bit to check)</span>
<a name="l03029"></a>03029     {
<a name="l03030"></a>03030         <span class="keywordflow">return</span> (*word &gt;&gt; nbit) &amp; 1;
<a name="l03031"></a>03031     }
<a name="l03032"></a>03032     <span class="keywordtype">unsigned</span> acc;
<a name="l03033"></a>03033     <span class="keywordtype">unsigned</span> bitcount = right - left + 1;
<a name="l03034"></a>03034 
<a name="l03035"></a>03035     <span class="keywordflow">if</span> (nbit) <span class="comment">// starting position is not aligned</span>
<a name="l03036"></a>03036     {
<a name="l03037"></a>03037         <span class="keywordtype">unsigned</span> right_margin = nbit + (right - left);
<a name="l03038"></a>03038         <span class="keywordflow">if</span> (right_margin &lt; 32)
<a name="l03039"></a>03039         {
<a name="l03040"></a>03040             <span class="keywordtype">unsigned</span> mask =
<a name="l03041"></a>03041                 <a class="code" href="a00040.html" title="Structure keeps all-left/right ON bits masks.">block_set_table&lt;true&gt;::_right</a>[nbit] &amp;
<a name="l03042"></a>03042                 <a class="code" href="a00040.html" title="Structure keeps all-left/right ON bits masks.">block_set_table&lt;true&gt;::_left</a>[right_margin];
<a name="l03043"></a>03043             acc = *word &amp; mask;
<a name="l03044"></a>03044             <span class="keywordflow">return</span> acc;
<a name="l03045"></a>03045         }
<a name="l03046"></a>03046         <span class="keywordflow">else</span>
<a name="l03047"></a>03047         {
<a name="l03048"></a>03048             acc = *word &amp; <a class="code" href="a00040.html" title="Structure keeps all-left/right ON bits masks.">block_set_table&lt;true&gt;::_right</a>[nbit];
<a name="l03049"></a>03049             <span class="keywordflow">if</span> (acc) 
<a name="l03050"></a>03050                 <span class="keywordflow">return</span> acc;
<a name="l03051"></a>03051             bitcount -= 32 - nbit;
<a name="l03052"></a>03052         }
<a name="l03053"></a>03053         ++word;
<a name="l03054"></a>03054     }
<a name="l03055"></a>03055 
<a name="l03056"></a>03056     <span class="comment">// now when we are word aligned, we can check bits the usual way</span>
<a name="l03057"></a>03057     <span class="keywordflow">for</span> ( ;bitcount &gt;= 32; bitcount -= 32)
<a name="l03058"></a>03058     {
<a name="l03059"></a>03059         acc = *word++;
<a name="l03060"></a>03060         <span class="keywordflow">if</span> (acc) 
<a name="l03061"></a>03061             <span class="keywordflow">return</span> acc;
<a name="l03062"></a>03062     }
<a name="l03063"></a>03063 
<a name="l03064"></a>03064     <span class="keywordflow">if</span> (bitcount)  <span class="comment">// we have a tail to count</span>
<a name="l03065"></a>03065     {
<a name="l03066"></a>03066         acc = (*word) &amp; <a class="code" href="a00040.html" title="Structure keeps all-left/right ON bits masks.">block_set_table&lt;true&gt;::_left</a>[bitcount-1];
<a name="l03067"></a>03067         <span class="keywordflow">if</span> (acc) 
<a name="l03068"></a>03068             <span class="keywordflow">return</span> acc;
<a name="l03069"></a>03069     }
<a name="l03070"></a>03070 
<a name="l03071"></a>03071     <span class="keywordflow">return</span> 0;
<a name="l03072"></a>03072 }
<a name="l03073"></a>03073 
<a name="l03074"></a>03074 
<a name="l03075"></a>03075 
<a name="l03076"></a>03076 <span class="comment">// ----------------------------------------------------------------------</span>
<a name="l03077"></a>03077 <span class="comment"></span>
<a name="l03078"></a>03078 <span class="comment">/*! Function inverts block of bits </span>
<a name="l03079"></a>03079 <span class="comment">    @ingroup bitfunc </span>
<a name="l03080"></a>03080 <span class="comment">*/</span>
<a name="l03081"></a><a class="code" href="a00120.html#ga95854f9969985254a0f58b928da0eec6">03081</a> <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keywordtype">void</span> <a class="code" href="a00120.html#ga95854f9969985254a0f58b928da0eec6">bit_invert</a>(T* start, T* end)
<a name="l03082"></a>03082 {
<a name="l03083"></a>03083 <span class="preprocessor">#ifdef BMVECTOPT</span>
<a name="l03084"></a>03084 <span class="preprocessor"></span>    <a class="code" href="a00098.html#aa31c7d6d7d4cd67e1cc86c08221446ce">VECT_INVERT_ARR</a>(start, end);
<a name="l03085"></a>03085 <span class="preprocessor">#else</span>
<a name="l03086"></a>03086 <span class="preprocessor"></span>    <span class="keywordflow">do</span>
<a name="l03087"></a>03087     {
<a name="l03088"></a>03088         start[0] = ~start[0];
<a name="l03089"></a>03089         start[1] = ~start[1];
<a name="l03090"></a>03090         start[2] = ~start[2];
<a name="l03091"></a>03091         start[3] = ~start[3];
<a name="l03092"></a>03092         start+=4;
<a name="l03093"></a>03093     } <span class="keywordflow">while</span> (start &lt; end);
<a name="l03094"></a>03094 <span class="preprocessor">#endif</span>
<a name="l03095"></a>03095 <span class="preprocessor"></span>}
<a name="l03096"></a>03096 
<a name="l03097"></a>03097 <span class="comment">// ----------------------------------------------------------------------</span>
<a name="l03098"></a>03098 <span class="comment"></span>
<a name="l03099"></a>03099 <span class="comment">/*! @brief Returns &quot;true&quot; if all bits in the block are 1</span>
<a name="l03100"></a>03100 <span class="comment">    @ingroup bitfunc </span>
<a name="l03101"></a>03101 <span class="comment">*/</span>
<a name="l03102"></a><a class="code" href="a00120.html#ga97b1075250d4bf10f596ff2fbc334ceb">03102</a> <span class="keyword">inline</span> <span class="keywordtype">bool</span> <a class="code" href="a00120.html#ga97b1075250d4bf10f596ff2fbc334ceb" title="Returns &amp;quot;true&amp;quot; if all bits in the block are 1.">is_bits_one</a>(<span class="keyword">const</span> <a class="code" href="a00115.html#a7176bf7817550ca24cb6612bd8d7957d">bm::wordop_t</a>* start, 
<a name="l03103"></a>03103                         <span class="keyword">const</span> <a class="code" href="a00115.html#a7176bf7817550ca24cb6612bd8d7957d">bm::wordop_t</a>* end)
<a name="l03104"></a>03104 {
<a name="l03105"></a>03105    <span class="keywordflow">do</span>
<a name="l03106"></a>03106    {
<a name="l03107"></a>03107         <a class="code" href="a00115.html#a7176bf7817550ca24cb6612bd8d7957d">bm::wordop_t</a> tmp = 
<a name="l03108"></a>03108             start[0] &amp; start[1] &amp; start[2] &amp; start[3];
<a name="l03109"></a>03109         <span class="keywordflow">if</span> (tmp != <a class="code" href="a00115.html#ad81dea46a256b93b2af3568ce409d40b">bm::all_bits_mask</a>) 
<a name="l03110"></a>03110             <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l03111"></a>03111         start += 4;
<a name="l03112"></a>03112    } <span class="keywordflow">while</span> (start &lt; end);
<a name="l03113"></a>03113 
<a name="l03114"></a>03114    <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l03115"></a>03115 }
<a name="l03116"></a>03116 
<a name="l03117"></a>03117 <span class="comment">// ----------------------------------------------------------------------</span>
<a name="l03118"></a>03118 
<a name="l03119"></a>03119 <span class="comment"></span>
<a name="l03120"></a>03120 <span class="comment">/*! @brief Returns &quot;true&quot; if all bits in the block are 0</span>
<a name="l03121"></a>03121 <span class="comment">    @ingroup bitfunc </span>
<a name="l03122"></a>03122 <span class="comment">*/</span>
<a name="l03123"></a><a class="code" href="a00120.html#gac6cfb9f92e4df6bb4c76f6efb2382860">03123</a> <span class="keyword">inline</span> <span class="keywordtype">bool</span> <a class="code" href="a00120.html#gac6cfb9f92e4df6bb4c76f6efb2382860" title="Returns &amp;quot;true&amp;quot; if all bits in the block are 0.">bit_is_all_zero</a>(<span class="keyword">const</span> <a class="code" href="a00115.html#a7176bf7817550ca24cb6612bd8d7957d">bm::wordop_t</a>* start, 
<a name="l03124"></a>03124                             <span class="keyword">const</span> <a class="code" href="a00115.html#a7176bf7817550ca24cb6612bd8d7957d">bm::wordop_t</a>* end)
<a name="l03125"></a>03125 {
<a name="l03126"></a>03126    <span class="keywordflow">do</span>
<a name="l03127"></a>03127    {
<a name="l03128"></a>03128         <a class="code" href="a00115.html#a7176bf7817550ca24cb6612bd8d7957d">bm::wordop_t</a> tmp = 
<a name="l03129"></a>03129             start[0] | start[1] | start[2] | start[3];
<a name="l03130"></a>03130        <span class="keywordflow">if</span> (tmp) 
<a name="l03131"></a>03131            <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l03132"></a>03132        start += 4;
<a name="l03133"></a>03133    } <span class="keywordflow">while</span> (start &lt; end);
<a name="l03134"></a>03134 
<a name="l03135"></a>03135    <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l03136"></a>03136 }
<a name="l03137"></a>03137 
<a name="l03138"></a>03138 <span class="comment">// ----------------------------------------------------------------------</span>
<a name="l03139"></a>03139 
<a name="l03140"></a>03140 <span class="comment">// GAP blocks manipulation functions:</span>
<a name="l03141"></a>03141 <span class="comment"></span>
<a name="l03142"></a>03142 <span class="comment">/*! \brief GAP and functor */</span>
<a name="l03143"></a><a class="code" href="a00115.html#a8d943cf66c4592e2baddf5bc0667adbd">03143</a> <a class="code" href="a00092.html#a938734d014fb68dd8b2251fe8ec2b025">BMFORCEINLINE</a> <span class="keywordtype">unsigned</span> <a class="code" href="a00115.html#a8d943cf66c4592e2baddf5bc0667adbd" title="GAP and functor.">and_op</a>(<span class="keywordtype">unsigned</span> v1, <span class="keywordtype">unsigned</span> v2)
<a name="l03144"></a>03144 {
<a name="l03145"></a>03145     <span class="keywordflow">return</span> v1 &amp; v2;
<a name="l03146"></a>03146 }
<a name="l03147"></a>03147 
<a name="l03148"></a>03148 <span class="comment"></span>
<a name="l03149"></a>03149 <span class="comment">/*! \brief GAP xor functor */</span>
<a name="l03150"></a><a class="code" href="a00115.html#a6e7085de3103a42f81c0d3d82903cd5f">03150</a> <a class="code" href="a00092.html#a938734d014fb68dd8b2251fe8ec2b025">BMFORCEINLINE</a> <span class="keywordtype">unsigned</span> <a class="code" href="a00115.html#a6e7085de3103a42f81c0d3d82903cd5f" title="GAP xor functor.">xor_op</a>(<span class="keywordtype">unsigned</span> v1, <span class="keywordtype">unsigned</span> v2)
<a name="l03151"></a>03151 {
<a name="l03152"></a>03152     <span class="keywordflow">return</span> v1 ^ v2;
<a name="l03153"></a>03153 }
<a name="l03154"></a>03154 
<a name="l03155"></a>03155 <span class="comment"></span>
<a name="l03156"></a>03156 <span class="comment">/*! \brief GAP or functor */</span>
<a name="l03157"></a><a class="code" href="a00115.html#ac330d13a0846ca89ff6fc6927e675a93">03157</a> <a class="code" href="a00092.html#a938734d014fb68dd8b2251fe8ec2b025">BMFORCEINLINE</a> <span class="keywordtype">unsigned</span> <a class="code" href="a00115.html#ac330d13a0846ca89ff6fc6927e675a93" title="GAP or functor.">or_op</a>(<span class="keywordtype">unsigned</span> v1, <span class="keywordtype">unsigned</span> v2)
<a name="l03158"></a>03158 {
<a name="l03159"></a>03159     <span class="keywordflow">return</span> v1 | v2;
<a name="l03160"></a>03160 }
<a name="l03161"></a>03161 <span class="comment"></span>
<a name="l03162"></a>03162 <span class="comment">/*! \brief GAP or functor */</span>
<a name="l03163"></a><a class="code" href="a00115.html#a35c5866395bfb88b68913b32539a2b96">03163</a> <a class="code" href="a00092.html#a938734d014fb68dd8b2251fe8ec2b025">BMFORCEINLINE</a> <span class="keywordtype">unsigned</span> <a class="code" href="a00115.html#a35c5866395bfb88b68913b32539a2b96" title="GAP or functor.">sub_op</a>(<span class="keywordtype">unsigned</span> v1, <span class="keywordtype">unsigned</span> v2)
<a name="l03164"></a>03164 {
<a name="l03165"></a>03165     <span class="keywordflow">return</span> v1 &amp; ~v2;
<a name="l03166"></a>03166 }
<a name="l03167"></a>03167 
<a name="l03168"></a>03168 <span class="comment"></span>
<a name="l03169"></a>03169 <span class="comment">/*!</span>
<a name="l03170"></a>03170 <span class="comment">   \brief GAP AND operation.</span>
<a name="l03171"></a>03171 <span class="comment">   </span>
<a name="l03172"></a>03172 <span class="comment">   Function performs AND logical operation on gap vectors.</span>
<a name="l03173"></a>03173 <span class="comment">   If possible function put the result into vect1 and returns this</span>
<a name="l03174"></a>03174 <span class="comment">   pointer.  Otherwise result is put into tmp_buf, which should be </span>
<a name="l03175"></a>03175 <span class="comment">   twice of the vector size.</span>
<a name="l03176"></a>03176 <span class="comment"></span>
<a name="l03177"></a>03177 <span class="comment">   \param vect1   - operand 1</span>
<a name="l03178"></a>03178 <span class="comment">   \param vect2   - operand 2</span>
<a name="l03179"></a>03179 <span class="comment">   \param tmp_buf - pointer on temporary buffer</span>
<a name="l03180"></a>03180 <span class="comment">   \param dsize   - out size of the destination</span>
<a name="l03181"></a>03181 <span class="comment">   \return Result pointer (tmp_buf OR vect1)</span>
<a name="l03182"></a>03182 <span class="comment"></span>
<a name="l03183"></a>03183 <span class="comment">   @ingroup gapfunc</span>
<a name="l03184"></a>03184 <span class="comment">*/</span>
<a name="l03185"></a>03185 <a class="code" href="a00092.html#a938734d014fb68dd8b2251fe8ec2b025">BMFORCEINLINE</a> 
<a name="l03186"></a><a class="code" href="a00119.html#gac18d7da0492983802511999a4ad0764a">03186</a> <a class="code" href="a00115.html#ac654d6319039a86546d235a236fc7cf6">gap_word_t</a>* <a class="code" href="a00119.html#gac18d7da0492983802511999a4ad0764a" title="GAP AND operation.">gap_operation_and</a>(<span class="keyword">const</span> <a class="code" href="a00115.html#ac654d6319039a86546d235a236fc7cf6">gap_word_t</a>* BMRESTRICT vect1,
<a name="l03187"></a>03187                               <span class="keyword">const</span> <a class="code" href="a00115.html#ac654d6319039a86546d235a236fc7cf6">gap_word_t</a>* BMRESTRICT vect2,
<a name="l03188"></a>03188                               <a class="code" href="a00115.html#ac654d6319039a86546d235a236fc7cf6">gap_word_t</a>*       BMRESTRICT tmp_buf,
<a name="l03189"></a>03189                               <span class="keywordtype">unsigned</span>&amp;         dsize)
<a name="l03190"></a>03190 {
<a name="l03191"></a>03191     <a class="code" href="a00115.html#aac0daaac2b5a7c88e6be726c77f52c68" title="Abstract operation for GAP buffers. Receives functor F as a template argument.">gap_buff_op</a>(tmp_buf, vect1, 0, vect2, 0, <a class="code" href="a00115.html#a8d943cf66c4592e2baddf5bc0667adbd" title="GAP and functor.">and_op</a>, dsize);
<a name="l03192"></a>03192     <span class="keywordflow">return</span> tmp_buf;
<a name="l03193"></a>03193 }
<a name="l03194"></a>03194 <span class="comment"></span>
<a name="l03195"></a>03195 <span class="comment">/*!</span>
<a name="l03196"></a>03196 <span class="comment">   \brief GAP AND operation test.</span>
<a name="l03197"></a>03197 <span class="comment">   </span>
<a name="l03198"></a>03198 <span class="comment">   Function performs AND logical operation on gap vectors.</span>
<a name="l03199"></a>03199 <span class="comment">   If possible function put the result into vect1 and returns this</span>
<a name="l03200"></a>03200 <span class="comment">   pointer.  Otherwise result is put into tmp_buf, which should be </span>
<a name="l03201"></a>03201 <span class="comment">   twice of the vector size.</span>
<a name="l03202"></a>03202 <span class="comment"></span>
<a name="l03203"></a>03203 <span class="comment">   \param vect1   - operand 1</span>
<a name="l03204"></a>03204 <span class="comment">   \param vect2   - operand 2</span>
<a name="l03205"></a>03205 <span class="comment">   \return non zero value if operation returns any 1 bit</span>
<a name="l03206"></a>03206 <span class="comment"></span>
<a name="l03207"></a>03207 <span class="comment">   @ingroup gapfunc</span>
<a name="l03208"></a>03208 <span class="comment">*/</span>
<a name="l03209"></a>03209 <a class="code" href="a00092.html#a938734d014fb68dd8b2251fe8ec2b025">BMFORCEINLINE</a> 
<a name="l03210"></a><a class="code" href="a00119.html#ga58e0312d3ab0551e883176b170c0a3e8">03210</a> <span class="keywordtype">unsigned</span> <a class="code" href="a00119.html#ga58e0312d3ab0551e883176b170c0a3e8" title="GAP AND operation test.">gap_operation_any_and</a>(<span class="keyword">const</span> <a class="code" href="a00115.html#ac654d6319039a86546d235a236fc7cf6">gap_word_t</a>* BMRESTRICT vect1,
<a name="l03211"></a>03211                                       <span class="keyword">const</span> <a class="code" href="a00115.html#ac654d6319039a86546d235a236fc7cf6">gap_word_t</a>* BMRESTRICT vect2)
<a name="l03212"></a>03212 {
<a name="l03213"></a>03213     <span class="keywordflow">return</span> <a class="code" href="a00119.html#ga5e3123c3c9d3587f470abdbe6c8c3ad3" title="Abstract distance test operation for GAP buffers. Receives functor F as a template...">gap_buff_any_op</a>(vect1, 0, vect2, 0, <a class="code" href="a00115.html#a8d943cf66c4592e2baddf5bc0667adbd" title="GAP and functor.">and_op</a>);
<a name="l03214"></a>03214 }
<a name="l03215"></a>03215 
<a name="l03216"></a>03216 <span class="comment"></span>
<a name="l03217"></a>03217 <span class="comment">/*!</span>
<a name="l03218"></a>03218 <span class="comment">   \brief GAP bitcount AND operation test.</span>
<a name="l03219"></a>03219 <span class="comment">   </span>
<a name="l03220"></a>03220 <span class="comment">   \param vect1   - operand 1</span>
<a name="l03221"></a>03221 <span class="comment">   \param vect2   - operand 2</span>
<a name="l03222"></a>03222 <span class="comment">   \return bitcount of vect1 AND vect2</span>
<a name="l03223"></a>03223 <span class="comment"></span>
<a name="l03224"></a>03224 <span class="comment">   @ingroup gapfunc</span>
<a name="l03225"></a>03225 <span class="comment">*/</span>
<a name="l03226"></a>03226 <a class="code" href="a00092.html#a938734d014fb68dd8b2251fe8ec2b025">BMFORCEINLINE</a> 
<a name="l03227"></a><a class="code" href="a00119.html#gafd92d013b0c377604831f401ef6917b8">03227</a> <span class="keywordtype">unsigned</span> <a class="code" href="a00119.html#gafd92d013b0c377604831f401ef6917b8" title="GAP bitcount AND operation test.">gap_count_and</a>(<span class="keyword">const</span> <a class="code" href="a00115.html#ac654d6319039a86546d235a236fc7cf6">gap_word_t</a>* BMRESTRICT vect1,
<a name="l03228"></a>03228                        <span class="keyword">const</span> <a class="code" href="a00115.html#ac654d6319039a86546d235a236fc7cf6">gap_word_t</a>* BMRESTRICT vect2)
<a name="l03229"></a>03229 {
<a name="l03230"></a>03230     <span class="keywordflow">return</span> <a class="code" href="a00119.html#ga9a5ff7782f3de0d1c699eb72d432f255" title="Abstract distance(similarity) operation for GAP buffers. Receives functor F as a...">gap_buff_count_op</a>(vect1, vect2, <a class="code" href="a00115.html#a8d943cf66c4592e2baddf5bc0667adbd" title="GAP and functor.">and_op</a>);
<a name="l03231"></a>03231 }
<a name="l03232"></a>03232 
<a name="l03233"></a>03233 
<a name="l03234"></a>03234 <span class="comment"></span>
<a name="l03235"></a>03235 <span class="comment">/*!</span>
<a name="l03236"></a>03236 <span class="comment">   \brief GAP XOR operation.</span>
<a name="l03237"></a>03237 <span class="comment">   </span>
<a name="l03238"></a>03238 <span class="comment">   Function performs XOR logical operation on gap vectors.</span>
<a name="l03239"></a>03239 <span class="comment">   If possible function put the result into vect1 and returns this</span>
<a name="l03240"></a>03240 <span class="comment">   pointer.  Otherwise result is put into tmp_buf, which should be </span>
<a name="l03241"></a>03241 <span class="comment">   twice of the vector size.</span>
<a name="l03242"></a>03242 <span class="comment"></span>
<a name="l03243"></a>03243 <span class="comment">   \param vect1   - operand 1</span>
<a name="l03244"></a>03244 <span class="comment">   \param vect2   - operand 2</span>
<a name="l03245"></a>03245 <span class="comment">   \param tmp_buf - pointer on temporary buffer</span>
<a name="l03246"></a>03246 <span class="comment">   \param dsize   - out destination size</span>
<a name="l03247"></a>03247 <span class="comment">   \return Result pointer (tmp_buf)</span>
<a name="l03248"></a>03248 <span class="comment"></span>
<a name="l03249"></a>03249 <span class="comment">   @ingroup gapfunc</span>
<a name="l03250"></a>03250 <span class="comment">*/</span>
<a name="l03251"></a>03251 <a class="code" href="a00092.html#a938734d014fb68dd8b2251fe8ec2b025">BMFORCEINLINE</a> 
<a name="l03252"></a><a class="code" href="a00119.html#ga72d2d3933b4410413eeb02e9ee0a910d">03252</a> <a class="code" href="a00115.html#ac654d6319039a86546d235a236fc7cf6">gap_word_t</a>* <a class="code" href="a00119.html#ga72d2d3933b4410413eeb02e9ee0a910d" title="GAP XOR operation.">gap_operation_xor</a>(<span class="keyword">const</span> <a class="code" href="a00115.html#ac654d6319039a86546d235a236fc7cf6">gap_word_t</a>*  BMRESTRICT vect1,
<a name="l03253"></a>03253                               <span class="keyword">const</span> <a class="code" href="a00115.html#ac654d6319039a86546d235a236fc7cf6">gap_word_t</a>*  BMRESTRICT vect2,
<a name="l03254"></a>03254                               <a class="code" href="a00115.html#ac654d6319039a86546d235a236fc7cf6">gap_word_t</a>*        BMRESTRICT tmp_buf,
<a name="l03255"></a>03255                               <span class="keywordtype">unsigned</span>&amp;                     dsize)
<a name="l03256"></a>03256 {
<a name="l03257"></a>03257     <a class="code" href="a00115.html#aac0daaac2b5a7c88e6be726c77f52c68" title="Abstract operation for GAP buffers. Receives functor F as a template argument.">gap_buff_op</a>(tmp_buf, vect1, 0, vect2, 0, <a class="code" href="a00115.html#a6e7085de3103a42f81c0d3d82903cd5f" title="GAP xor functor.">bm::xor_op</a>, dsize);
<a name="l03258"></a>03258     <span class="keywordflow">return</span> tmp_buf;
<a name="l03259"></a>03259 }
<a name="l03260"></a>03260 
<a name="l03261"></a>03261 <span class="comment"></span>
<a name="l03262"></a>03262 <span class="comment">/*!</span>
<a name="l03263"></a>03263 <span class="comment">   \brief GAP XOR operation test.</span>
<a name="l03264"></a>03264 <span class="comment">   </span>
<a name="l03265"></a>03265 <span class="comment">   Function performs AND logical operation on gap vectors.</span>
<a name="l03266"></a>03266 <span class="comment">   If possible function put the result into vect1 and returns this</span>
<a name="l03267"></a>03267 <span class="comment">   pointer.  Otherwise result is put into tmp_buf, which should be </span>
<a name="l03268"></a>03268 <span class="comment">   twice of the vector size.</span>
<a name="l03269"></a>03269 <span class="comment"></span>
<a name="l03270"></a>03270 <span class="comment">   \param vect1   - operand 1</span>
<a name="l03271"></a>03271 <span class="comment">   \param vect2   - operand 2</span>
<a name="l03272"></a>03272 <span class="comment">   \return non zero value if operation returns any 1 bit</span>
<a name="l03273"></a>03273 <span class="comment"></span>
<a name="l03274"></a>03274 <span class="comment">   @ingroup gapfunc</span>
<a name="l03275"></a>03275 <span class="comment">*/</span>
<a name="l03276"></a>03276 <a class="code" href="a00092.html#a938734d014fb68dd8b2251fe8ec2b025">BMFORCEINLINE</a> 
<a name="l03277"></a><a class="code" href="a00119.html#gab8800dff60eb05404a83159035e8e72f">03277</a> <span class="keywordtype">unsigned</span> <a class="code" href="a00119.html#gab8800dff60eb05404a83159035e8e72f" title="GAP XOR operation test.">gap_operation_any_xor</a>(<span class="keyword">const</span> <a class="code" href="a00115.html#ac654d6319039a86546d235a236fc7cf6">gap_word_t</a>* BMRESTRICT vect1,
<a name="l03278"></a>03278                                <span class="keyword">const</span> <a class="code" href="a00115.html#ac654d6319039a86546d235a236fc7cf6">gap_word_t</a>* BMRESTRICT vect2)
<a name="l03279"></a>03279 {
<a name="l03280"></a>03280     <span class="keywordflow">return</span> <a class="code" href="a00119.html#ga5e3123c3c9d3587f470abdbe6c8c3ad3" title="Abstract distance test operation for GAP buffers. Receives functor F as a template...">gap_buff_any_op</a>(vect1, 0, vect2, 0, <a class="code" href="a00115.html#a6e7085de3103a42f81c0d3d82903cd5f" title="GAP xor functor.">bm::xor_op</a>);
<a name="l03281"></a>03281 }
<a name="l03282"></a>03282 <span class="comment"></span>
<a name="l03283"></a>03283 <span class="comment">/*!</span>
<a name="l03284"></a>03284 <span class="comment">   \brief GAP bitcount XOR operation test.</span>
<a name="l03285"></a>03285 <span class="comment">   </span>
<a name="l03286"></a>03286 <span class="comment">   \param vect1   - operand 1</span>
<a name="l03287"></a>03287 <span class="comment">   \param vect2   - operand 2</span>
<a name="l03288"></a>03288 <span class="comment">   \return bitcount of vect1 XOR vect2</span>
<a name="l03289"></a>03289 <span class="comment"></span>
<a name="l03290"></a>03290 <span class="comment">   @ingroup gapfunc</span>
<a name="l03291"></a>03291 <span class="comment">*/</span>
<a name="l03292"></a>03292 <a class="code" href="a00092.html#a938734d014fb68dd8b2251fe8ec2b025">BMFORCEINLINE</a> 
<a name="l03293"></a><a class="code" href="a00119.html#gae38d6a3296f0562be512f47b4edfb1ad">03293</a> <span class="keywordtype">unsigned</span> <a class="code" href="a00119.html#gae38d6a3296f0562be512f47b4edfb1ad" title="GAP bitcount XOR operation test.">gap_count_xor</a>(<span class="keyword">const</span> <a class="code" href="a00115.html#ac654d6319039a86546d235a236fc7cf6">gap_word_t</a>* BMRESTRICT vect1,
<a name="l03294"></a>03294                        <span class="keyword">const</span> <a class="code" href="a00115.html#ac654d6319039a86546d235a236fc7cf6">gap_word_t</a>* BMRESTRICT vect2)
<a name="l03295"></a>03295 {
<a name="l03296"></a>03296     <span class="keywordflow">return</span> <a class="code" href="a00119.html#ga9a5ff7782f3de0d1c699eb72d432f255" title="Abstract distance(similarity) operation for GAP buffers. Receives functor F as a...">gap_buff_count_op</a>(vect1, vect2, <a class="code" href="a00115.html#a6e7085de3103a42f81c0d3d82903cd5f" title="GAP xor functor.">bm::xor_op</a>);
<a name="l03297"></a>03297 }
<a name="l03298"></a>03298 
<a name="l03299"></a>03299 <span class="comment"></span>
<a name="l03300"></a>03300 <span class="comment">/*!</span>
<a name="l03301"></a>03301 <span class="comment">   \brief GAP OR operation.</span>
<a name="l03302"></a>03302 <span class="comment">   </span>
<a name="l03303"></a>03303 <span class="comment">   Function performs OR logical oparation on gap vectors.</span>
<a name="l03304"></a>03304 <span class="comment">   If possible function put the result into vect1 and returns this</span>
<a name="l03305"></a>03305 <span class="comment">   pointer.  Otherwise result is put into tmp_buf, which should be </span>
<a name="l03306"></a>03306 <span class="comment">   twice of the vector size.</span>
<a name="l03307"></a>03307 <span class="comment"></span>
<a name="l03308"></a>03308 <span class="comment">   \param vect1   - operand 1</span>
<a name="l03309"></a>03309 <span class="comment">   \param vect2   - operand 2</span>
<a name="l03310"></a>03310 <span class="comment">   \param tmp_buf - pointer on temporary buffer</span>
<a name="l03311"></a>03311 <span class="comment">   \param dsize   - out destination size</span>
<a name="l03312"></a>03312 <span class="comment"></span>
<a name="l03313"></a>03313 <span class="comment">   \return Result pointer (tmp_buf)</span>
<a name="l03314"></a>03314 <span class="comment"></span>
<a name="l03315"></a>03315 <span class="comment">   @ingroup gapfunc</span>
<a name="l03316"></a>03316 <span class="comment">*/</span>
<a name="l03317"></a>03317 <span class="keyword">inline</span> 
<a name="l03318"></a><a class="code" href="a00119.html#gacda280af8910ae5fde37731a3a7a1226">03318</a> <a class="code" href="a00115.html#ac654d6319039a86546d235a236fc7cf6">gap_word_t</a>* <a class="code" href="a00119.html#gacda280af8910ae5fde37731a3a7a1226" title="GAP OR operation.">gap_operation_or</a>(<span class="keyword">const</span> <a class="code" href="a00115.html#ac654d6319039a86546d235a236fc7cf6">gap_word_t</a>*  BMRESTRICT vect1,
<a name="l03319"></a>03319                              <span class="keyword">const</span> <a class="code" href="a00115.html#ac654d6319039a86546d235a236fc7cf6">gap_word_t</a>*  BMRESTRICT vect2,
<a name="l03320"></a>03320                              <a class="code" href="a00115.html#ac654d6319039a86546d235a236fc7cf6">gap_word_t</a>*        BMRESTRICT tmp_buf,
<a name="l03321"></a>03321                              <span class="keywordtype">unsigned</span>&amp;                     dsize)
<a name="l03322"></a>03322 {
<a name="l03323"></a>03323     <a class="code" href="a00115.html#aac0daaac2b5a7c88e6be726c77f52c68" title="Abstract operation for GAP buffers. Receives functor F as a template argument.">gap_buff_op</a>(tmp_buf, vect1, 1, vect2, 1, <a class="code" href="a00115.html#a8d943cf66c4592e2baddf5bc0667adbd" title="GAP and functor.">bm::and_op</a>, dsize);
<a name="l03324"></a>03324     <a class="code" href="a00119.html#ga3f22bfde5dfe06d6d77dc2598b8c0845" title="Inverts all bits in the GAP buffer.">gap_invert</a>(tmp_buf);
<a name="l03325"></a>03325     <span class="keywordflow">return</span> tmp_buf;
<a name="l03326"></a>03326 }
<a name="l03327"></a>03327 <span class="comment"></span>
<a name="l03328"></a>03328 <span class="comment">/*!</span>
<a name="l03329"></a>03329 <span class="comment">   \brief GAP bitcount OR operation test.</span>
<a name="l03330"></a>03330 <span class="comment">   </span>
<a name="l03331"></a>03331 <span class="comment">   \param vect1   - operand 1</span>
<a name="l03332"></a>03332 <span class="comment">   \param vect2   - operand 2</span>
<a name="l03333"></a>03333 <span class="comment">   \return bitcount of vect1 OR vect2</span>
<a name="l03334"></a>03334 <span class="comment"></span>
<a name="l03335"></a>03335 <span class="comment">   @ingroup gapfunc</span>
<a name="l03336"></a>03336 <span class="comment">*/</span>
<a name="l03337"></a>03337 <a class="code" href="a00092.html#a938734d014fb68dd8b2251fe8ec2b025">BMFORCEINLINE</a> 
<a name="l03338"></a><a class="code" href="a00119.html#ga125fc8dc68245a11a171e7793c6588a2">03338</a> <span class="keywordtype">unsigned</span> <a class="code" href="a00119.html#ga125fc8dc68245a11a171e7793c6588a2" title="GAP bitcount OR operation test.">gap_count_or</a>(<span class="keyword">const</span> <a class="code" href="a00115.html#ac654d6319039a86546d235a236fc7cf6">gap_word_t</a>* BMRESTRICT vect1,
<a name="l03339"></a>03339                       <span class="keyword">const</span> <a class="code" href="a00115.html#ac654d6319039a86546d235a236fc7cf6">gap_word_t</a>* BMRESTRICT vect2)
<a name="l03340"></a>03340 {
<a name="l03341"></a>03341     <span class="keywordflow">return</span> <a class="code" href="a00119.html#ga9a5ff7782f3de0d1c699eb72d432f255" title="Abstract distance(similarity) operation for GAP buffers. Receives functor F as a...">gap_buff_count_op</a>(vect1, vect2, <a class="code" href="a00115.html#ac330d13a0846ca89ff6fc6927e675a93" title="GAP or functor.">bm::or_op</a>);
<a name="l03342"></a>03342 }
<a name="l03343"></a>03343 
<a name="l03344"></a>03344 
<a name="l03345"></a>03345 <span class="comment"></span>
<a name="l03346"></a>03346 <span class="comment">/*!</span>
<a name="l03347"></a>03347 <span class="comment">   \brief GAP SUB (AND NOT) operation.</span>
<a name="l03348"></a>03348 <span class="comment">   </span>
<a name="l03349"></a>03349 <span class="comment">   Function performs SUB logical operation on gap vectors.</span>
<a name="l03350"></a>03350 <span class="comment">   If possible function put the result into vect1 and returns this</span>
<a name="l03351"></a>03351 <span class="comment">   pointer.  Otherwise result is put into tmp_buf, which should be </span>
<a name="l03352"></a>03352 <span class="comment">   twice of the vector size.</span>
<a name="l03353"></a>03353 <span class="comment"></span>
<a name="l03354"></a>03354 <span class="comment">   \param vect1   - operand 1</span>
<a name="l03355"></a>03355 <span class="comment">   \param vect2   - operand 2</span>
<a name="l03356"></a>03356 <span class="comment">   \param tmp_buf - pointer on temporary buffer</span>
<a name="l03357"></a>03357 <span class="comment">   \param dsize   - out destination size</span>
<a name="l03358"></a>03358 <span class="comment"></span>
<a name="l03359"></a>03359 <span class="comment">   \return Result pointer (tmp_buf)</span>
<a name="l03360"></a>03360 <span class="comment"></span>
<a name="l03361"></a>03361 <span class="comment">   @ingroup gapfunc</span>
<a name="l03362"></a>03362 <span class="comment">*/</span>
<a name="l03363"></a><a class="code" href="a00119.html#gabe4c83e5e162c38e297116dd1cd05ac4">03363</a> <span class="keyword">inline</span> <a class="code" href="a00115.html#ac654d6319039a86546d235a236fc7cf6">gap_word_t</a>* <a class="code" href="a00119.html#gabe4c83e5e162c38e297116dd1cd05ac4" title="GAP SUB (AND NOT) operation.">gap_operation_sub</a>(<span class="keyword">const</span> <a class="code" href="a00115.html#ac654d6319039a86546d235a236fc7cf6">gap_word_t</a>*  BMRESTRICT vect1,
<a name="l03364"></a>03364                                      <span class="keyword">const</span> <a class="code" href="a00115.html#ac654d6319039a86546d235a236fc7cf6">gap_word_t</a>*  BMRESTRICT vect2,
<a name="l03365"></a>03365                                      <a class="code" href="a00115.html#ac654d6319039a86546d235a236fc7cf6">gap_word_t</a>*        BMRESTRICT tmp_buf,
<a name="l03366"></a>03366                                      <span class="keywordtype">unsigned</span>&amp;                     dsize)
<a name="l03367"></a>03367 {
<a name="l03368"></a>03368     <a class="code" href="a00115.html#aac0daaac2b5a7c88e6be726c77f52c68" title="Abstract operation for GAP buffers. Receives functor F as a template argument.">gap_buff_op</a>(tmp_buf, vect1, 0, vect2, 1, <a class="code" href="a00115.html#a8d943cf66c4592e2baddf5bc0667adbd" title="GAP and functor.">and_op</a>, dsize);    
<a name="l03369"></a>03369     <span class="keywordflow">return</span> tmp_buf;
<a name="l03370"></a>03370 }
<a name="l03371"></a>03371 
<a name="l03372"></a>03372 <span class="comment"></span>
<a name="l03373"></a>03373 <span class="comment">/*!</span>
<a name="l03374"></a>03374 <span class="comment">   \brief GAP SUB operation test.</span>
<a name="l03375"></a>03375 <span class="comment">   </span>
<a name="l03376"></a>03376 <span class="comment">   Function performs AND logical operation on gap vectors.</span>
<a name="l03377"></a>03377 <span class="comment">   If possible function put the result into vect1 and returns this</span>
<a name="l03378"></a>03378 <span class="comment">   pointer.  Otherwise result is put into tmp_buf, which should be </span>
<a name="l03379"></a>03379 <span class="comment">   twice of the vector size.</span>
<a name="l03380"></a>03380 <span class="comment"></span>
<a name="l03381"></a>03381 <span class="comment">   \param vect1   - operand 1</span>
<a name="l03382"></a>03382 <span class="comment">   \param vect2   - operand 2</span>
<a name="l03383"></a>03383 <span class="comment">   \return non zero value if operation returns any 1 bit</span>
<a name="l03384"></a>03384 <span class="comment"></span>
<a name="l03385"></a>03385 <span class="comment">   @ingroup gapfunc</span>
<a name="l03386"></a>03386 <span class="comment">*/</span>
<a name="l03387"></a>03387 <a class="code" href="a00092.html#a938734d014fb68dd8b2251fe8ec2b025">BMFORCEINLINE</a> 
<a name="l03388"></a><a class="code" href="a00119.html#ga1c9b33d00f74206ad655dc2cef52428b">03388</a> <span class="keywordtype">unsigned</span> <a class="code" href="a00119.html#ga1c9b33d00f74206ad655dc2cef52428b" title="GAP SUB operation test.">gap_operation_any_sub</a>(<span class="keyword">const</span> <a class="code" href="a00115.html#ac654d6319039a86546d235a236fc7cf6">gap_word_t</a>* BMRESTRICT vect1,
<a name="l03389"></a>03389                                <span class="keyword">const</span> <a class="code" href="a00115.html#ac654d6319039a86546d235a236fc7cf6">gap_word_t</a>* BMRESTRICT vect2)
<a name="l03390"></a>03390 {
<a name="l03391"></a>03391     <span class="keywordflow">return</span> <a class="code" href="a00119.html#ga5e3123c3c9d3587f470abdbe6c8c3ad3" title="Abstract distance test operation for GAP buffers. Receives functor F as a template...">gap_buff_any_op</a>(vect1, 0, vect2, 1, <a class="code" href="a00115.html#a8d943cf66c4592e2baddf5bc0667adbd" title="GAP and functor.">bm::and_op</a>);    
<a name="l03392"></a>03392 }
<a name="l03393"></a>03393 
<a name="l03394"></a>03394 <span class="comment"></span>
<a name="l03395"></a>03395 <span class="comment">/*!</span>
<a name="l03396"></a>03396 <span class="comment">\brief GAP bitcount SUB (AND NOT) operation test.</span>
<a name="l03397"></a>03397 <span class="comment"></span>
<a name="l03398"></a>03398 <span class="comment">\param vect1   - operand 1</span>
<a name="l03399"></a>03399 <span class="comment">\param vect2   - operand 2</span>
<a name="l03400"></a>03400 <span class="comment">\return bitcount of vect1 SUB (AND NOT) vect2</span>
<a name="l03401"></a>03401 <span class="comment"></span>
<a name="l03402"></a>03402 <span class="comment">@ingroup gapfunc</span>
<a name="l03403"></a>03403 <span class="comment">*/</span>
<a name="l03404"></a>03404 <a class="code" href="a00092.html#a938734d014fb68dd8b2251fe8ec2b025">BMFORCEINLINE</a> 
<a name="l03405"></a><a class="code" href="a00119.html#gacacf55c60da82a1c384f3ac3a51229d4">03405</a> <span class="keywordtype">unsigned</span> <a class="code" href="a00119.html#gacacf55c60da82a1c384f3ac3a51229d4" title="GAP bitcount SUB (AND NOT) operation test.">gap_count_sub</a>(<span class="keyword">const</span> <a class="code" href="a00115.html#ac654d6319039a86546d235a236fc7cf6">gap_word_t</a>* BMRESTRICT vect1,
<a name="l03406"></a>03406                        <span class="keyword">const</span> <a class="code" href="a00115.html#ac654d6319039a86546d235a236fc7cf6">gap_word_t</a>* BMRESTRICT vect2)
<a name="l03407"></a>03407 {
<a name="l03408"></a>03408     <span class="keywordflow">return</span> <a class="code" href="a00119.html#ga9a5ff7782f3de0d1c699eb72d432f255" title="Abstract distance(similarity) operation for GAP buffers. Receives functor F as a...">gap_buff_count_op</a>(vect1, vect2, <a class="code" href="a00115.html#a35c5866395bfb88b68913b32539a2b96" title="GAP or functor.">bm::sub_op</a>);
<a name="l03409"></a>03409 }
<a name="l03410"></a>03410 
<a name="l03411"></a>03411 
<a name="l03412"></a>03412 <span class="comment">// ----------------------------------------------------------------------</span>
<a name="l03413"></a>03413 
<a name="l03414"></a>03414 <span class="comment">// BIT blocks manipulation functions:</span>
<a name="l03415"></a>03415 
<a name="l03416"></a>03416 <span class="comment"></span>
<a name="l03417"></a>03417 <span class="comment">/*!</span>
<a name="l03418"></a>03418 <span class="comment">   \brief Bitblock copy operation. </span>
<a name="l03419"></a>03419 <span class="comment"></span>
<a name="l03420"></a>03420 <span class="comment">   \param dst - destination block.</span>
<a name="l03421"></a>03421 <span class="comment">   \param src - source block.</span>
<a name="l03422"></a>03422 <span class="comment"></span>
<a name="l03423"></a>03423 <span class="comment">   @ingroup bitfunc</span>
<a name="l03424"></a>03424 <span class="comment">*/</span>
<a name="l03425"></a>03425 <span class="keyword">inline</span> 
<a name="l03426"></a><a class="code" href="a00120.html#ga9090de87d53e7f25eff96c8259b3485c">03426</a> <span class="keywordtype">void</span> <a class="code" href="a00120.html#ga9090de87d53e7f25eff96c8259b3485c" title="Bitblock copy operation.">bit_block_copy</a>(<a class="code" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a>* BMRESTRICT dst, <span class="keyword">const</span> <a class="code" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a>* BMRESTRICT src)
<a name="l03427"></a>03427 {
<a name="l03428"></a>03428 <span class="preprocessor">#ifdef BMVECTOPT</span>
<a name="l03429"></a>03429 <span class="preprocessor"></span>    <a class="code" href="a00098.html#a72b713f259e0542169a1228bebadcede">VECT_COPY_BLOCK</a>(dst, src, src + <a class="code" href="a00115.html#a91319dbc0d0e1bf3a3efc4d92bac7972">bm::set_block_size</a>);
<a name="l03430"></a>03430 <span class="preprocessor">#else</span>
<a name="l03431"></a>03431 <span class="preprocessor"></span>    ::memcpy(dst, src, <a class="code" href="a00115.html#a91319dbc0d0e1bf3a3efc4d92bac7972">bm::set_block_size</a> * <span class="keyword">sizeof</span>(<a class="code" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a>));
<a name="l03432"></a>03432 <span class="preprocessor">#endif</span>
<a name="l03433"></a>03433 <span class="preprocessor"></span>}
<a name="l03434"></a>03434 
<a name="l03435"></a>03435 <span class="comment"></span>
<a name="l03436"></a>03436 <span class="comment">/*!</span>
<a name="l03437"></a>03437 <span class="comment">   \brief Plain bitblock AND operation. </span>
<a name="l03438"></a>03438 <span class="comment">   Function does not analyse availability of source and destination blocks.</span>
<a name="l03439"></a>03439 <span class="comment"></span>
<a name="l03440"></a>03440 <span class="comment">   \param dst - destination block.</span>
<a name="l03441"></a>03441 <span class="comment">   \param src - source block.</span>
<a name="l03442"></a>03442 <span class="comment"></span>
<a name="l03443"></a>03443 <span class="comment">   @ingroup bitfunc</span>
<a name="l03444"></a>03444 <span class="comment">*/</span>
<a name="l03445"></a>03445 <span class="keyword">inline</span> 
<a name="l03446"></a><a class="code" href="a00120.html#ga882f79df0a0175ad4ddf483c5f1eeb0e">03446</a> <span class="keywordtype">void</span> <a class="code" href="a00120.html#ga882f79df0a0175ad4ddf483c5f1eeb0e" title="Plain bitblock AND operation. Function does not analyse availability of source and...">bit_block_and</a>(<a class="code" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a>* BMRESTRICT dst, <span class="keyword">const</span> <a class="code" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a>* BMRESTRICT src)
<a name="l03447"></a>03447 {
<a name="l03448"></a>03448 <span class="preprocessor">#ifdef BMVECTOPT</span>
<a name="l03449"></a>03449 <span class="preprocessor"></span>    <a class="code" href="a00098.html#aa6a3504bb5449abf6f5ec084b2ddfac6">VECT_AND_ARR</a>(dst, src, src + <a class="code" href="a00115.html#a91319dbc0d0e1bf3a3efc4d92bac7972">bm::set_block_size</a>);
<a name="l03450"></a>03450 <span class="preprocessor">#else</span>
<a name="l03451"></a>03451 <span class="preprocessor"></span>    <span class="keyword">const</span> <a class="code" href="a00115.html#a7176bf7817550ca24cb6612bd8d7957d">bm::wordop_t</a>* BMRESTRICT wrd_ptr = (<a class="code" href="a00115.html#a7176bf7817550ca24cb6612bd8d7957d">wordop_t</a>*)src;
<a name="l03452"></a>03452     <span class="keyword">const</span> <a class="code" href="a00115.html#a7176bf7817550ca24cb6612bd8d7957d">bm::wordop_t</a>* BMRESTRICT wrd_end = (<a class="code" href="a00115.html#a7176bf7817550ca24cb6612bd8d7957d">wordop_t</a>*)(src + <a class="code" href="a00115.html#a91319dbc0d0e1bf3a3efc4d92bac7972">bm::set_block_size</a>);
<a name="l03453"></a>03453     <a class="code" href="a00115.html#a7176bf7817550ca24cb6612bd8d7957d">bm::wordop_t</a>* BMRESTRICT dst_ptr = (<a class="code" href="a00115.html#a7176bf7817550ca24cb6612bd8d7957d">wordop_t</a>*)dst;
<a name="l03454"></a>03454 
<a name="l03455"></a>03455     <span class="keywordflow">do</span>
<a name="l03456"></a>03456     {
<a name="l03457"></a>03457         dst_ptr[0] &amp;= wrd_ptr[0];
<a name="l03458"></a>03458         dst_ptr[1] &amp;= wrd_ptr[1];
<a name="l03459"></a>03459         dst_ptr[2] &amp;= wrd_ptr[2];
<a name="l03460"></a>03460         dst_ptr[3] &amp;= wrd_ptr[3];
<a name="l03461"></a>03461 
<a name="l03462"></a>03462         dst_ptr+=4;
<a name="l03463"></a>03463         wrd_ptr+=4;
<a name="l03464"></a>03464     } <span class="keywordflow">while</span> (wrd_ptr &lt; wrd_end);
<a name="l03465"></a>03465 <span class="preprocessor">#endif</span>
<a name="l03466"></a>03466 <span class="preprocessor"></span>}
<a name="l03467"></a>03467 
<a name="l03468"></a>03468 <span class="comment"></span>
<a name="l03469"></a>03469 <span class="comment">/*!</span>
<a name="l03470"></a>03470 <span class="comment">   \brief Function ANDs two bitblocks and computes the bitcount. </span>
<a name="l03471"></a>03471 <span class="comment">   Function does not analyse availability of source blocks.</span>
<a name="l03472"></a>03472 <span class="comment"></span>
<a name="l03473"></a>03473 <span class="comment">   \param src1     - first bit block</span>
<a name="l03474"></a>03474 <span class="comment">   \param src1_end - first bit block end</span>
<a name="l03475"></a>03475 <span class="comment">   \param src2     - second bit block</span>
<a name="l03476"></a>03476 <span class="comment"></span>
<a name="l03477"></a>03477 <span class="comment">   @ingroup bitfunc</span>
<a name="l03478"></a>03478 <span class="comment">*/</span>
<a name="l03479"></a>03479 <span class="keyword">inline</span> 
<a name="l03480"></a><a class="code" href="a00120.html#ga0070984bb1d332610150a9106ab8eb0a">03480</a> <span class="keywordtype">unsigned</span> <a class="code" href="a00120.html#ga0070984bb1d332610150a9106ab8eb0a" title="Function ANDs two bitblocks and computes the bitcount. Function does not analyse...">bit_block_and_count</a>(<span class="keyword">const</span> <a class="code" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a>* src1, 
<a name="l03481"></a>03481                              <span class="keyword">const</span> <a class="code" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a>* src1_end,
<a name="l03482"></a>03482                              <span class="keyword">const</span> <a class="code" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a>* src2)
<a name="l03483"></a>03483 {
<a name="l03484"></a>03484     <span class="keywordtype">unsigned</span> count;
<a name="l03485"></a>03485 <span class="preprocessor">#ifdef BMVECTOPT</span>
<a name="l03486"></a>03486 <span class="preprocessor"></span>    count = <a class="code" href="a00098.html#a3459200618dab65142340f1abd760eb9">VECT_BITCOUNT_AND</a>(src1, src1_end, src2);
<a name="l03487"></a>03487 <span class="preprocessor">#else  </span>
<a name="l03488"></a>03488 <span class="preprocessor"></span>    count = 0;  
<a name="l03489"></a>03489 <span class="preprocessor"># ifdef BM64OPT</span>
<a name="l03490"></a>03490 <span class="preprocessor"></span>    <span class="keyword">const</span> <a class="code" href="a00115.html#a1f6a6dd108cd9e9f4fb284043ef518fe">bm::id64_t</a>* b1 = (<a class="code" href="a00115.html#a1f6a6dd108cd9e9f4fb284043ef518fe">bm::id64_t</a>*) src1;
<a name="l03491"></a>03491     <span class="keyword">const</span> <a class="code" href="a00115.html#a1f6a6dd108cd9e9f4fb284043ef518fe">bm::id64_t</a>* b1_end = (<a class="code" href="a00115.html#a1f6a6dd108cd9e9f4fb284043ef518fe">bm::id64_t</a>*) src1_end;
<a name="l03492"></a>03492     <span class="keyword">const</span> <a class="code" href="a00115.html#a1f6a6dd108cd9e9f4fb284043ef518fe">bm::id64_t</a>* b2 = (<a class="code" href="a00115.html#a1f6a6dd108cd9e9f4fb284043ef518fe">bm::id64_t</a>*) src2;
<a name="l03493"></a>03493     <span class="keywordflow">do</span>
<a name="l03494"></a>03494     {
<a name="l03495"></a>03495         count += bitcount64_4way(b1[0] &amp; b2[0], 
<a name="l03496"></a>03496                                  b1[1] &amp; b2[1], 
<a name="l03497"></a>03497                                  b1[2] &amp; b2[2], 
<a name="l03498"></a>03498                                  b1[3] &amp; b2[3]);
<a name="l03499"></a>03499         b1 += 4;
<a name="l03500"></a>03500         b2 += 4;
<a name="l03501"></a>03501     } <span class="keywordflow">while</span> (b1 &lt; b1_end);
<a name="l03502"></a>03502 <span class="preprocessor"># else</span>
<a name="l03503"></a>03503 <span class="preprocessor"></span>    <span class="keywordflow">do</span>
<a name="l03504"></a>03504     {
<a name="l03505"></a>03505         <a class="code" href="a00120.html#ga967f6a5264f47d8adb93f6bdf8cdc129">BM_INCWORD_BITCOUNT</a>(count, src1[0] &amp; src2[0]);
<a name="l03506"></a>03506         <a class="code" href="a00120.html#ga967f6a5264f47d8adb93f6bdf8cdc129">BM_INCWORD_BITCOUNT</a>(count, src1[1] &amp; src2[1]);
<a name="l03507"></a>03507         <a class="code" href="a00120.html#ga967f6a5264f47d8adb93f6bdf8cdc129">BM_INCWORD_BITCOUNT</a>(count, src1[2] &amp; src2[2]);
<a name="l03508"></a>03508         <a class="code" href="a00120.html#ga967f6a5264f47d8adb93f6bdf8cdc129">BM_INCWORD_BITCOUNT</a>(count, src1[3] &amp; src2[3]);
<a name="l03509"></a>03509 
<a name="l03510"></a>03510         src1+=4;
<a name="l03511"></a>03511         src2+=4;
<a name="l03512"></a>03512     } <span class="keywordflow">while</span> (src1 &lt; src1_end);
<a name="l03513"></a>03513 <span class="preprocessor"># endif</span>
<a name="l03514"></a>03514 <span class="preprocessor"></span><span class="preprocessor">#endif    </span>
<a name="l03515"></a>03515 <span class="preprocessor"></span>    <span class="keywordflow">return</span> count;
<a name="l03516"></a>03516 }
<a name="l03517"></a>03517 
<a name="l03518"></a>03518 <span class="comment"></span>
<a name="l03519"></a>03519 <span class="comment">/*!</span>
<a name="l03520"></a>03520 <span class="comment">   \brief Function ANDs two bitblocks and tests for any bit. </span>
<a name="l03521"></a>03521 <span class="comment">   Function does not analyse availability of source blocks.</span>
<a name="l03522"></a>03522 <span class="comment"></span>
<a name="l03523"></a>03523 <span class="comment">   \param src1     - first bit block</span>
<a name="l03524"></a>03524 <span class="comment">   \param src1_end - first bit block end</span>
<a name="l03525"></a>03525 <span class="comment">   \param src2     - second bit block</span>
<a name="l03526"></a>03526 <span class="comment"></span>
<a name="l03527"></a>03527 <span class="comment">   @ingroup bitfunc</span>
<a name="l03528"></a>03528 <span class="comment">*/</span>
<a name="l03529"></a>03529 <span class="keyword">inline</span> 
<a name="l03530"></a><a class="code" href="a00120.html#ga9fe2d12ddac5293fe53038c687c732f3">03530</a> <span class="keywordtype">unsigned</span> <a class="code" href="a00120.html#ga9fe2d12ddac5293fe53038c687c732f3" title="Function ANDs two bitblocks and tests for any bit. Function does not analyse availability...">bit_block_and_any</a>(<span class="keyword">const</span> <a class="code" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a>* src1, 
<a name="l03531"></a>03531                            <span class="keyword">const</span> <a class="code" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a>* src1_end,
<a name="l03532"></a>03532                            <span class="keyword">const</span> <a class="code" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a>* src2)
<a name="l03533"></a>03533 {
<a name="l03534"></a>03534     <span class="keywordtype">unsigned</span> count = 0;
<a name="l03535"></a>03535     <span class="keywordflow">do</span>
<a name="l03536"></a>03536     {
<a name="l03537"></a>03537         count = (src1[0] &amp; src2[0]) |
<a name="l03538"></a>03538                 (src1[1] &amp; src2[1]) |
<a name="l03539"></a>03539                 (src1[2] &amp; src2[2]) |
<a name="l03540"></a>03540                 (src1[3] &amp; src2[3]);
<a name="l03541"></a>03541 
<a name="l03542"></a>03542         src1+=4; src2+=4;
<a name="l03543"></a>03543     } <span class="keywordflow">while</span> ((src1 &lt; src1_end) &amp;&amp; (count == 0));
<a name="l03544"></a>03544     <span class="keywordflow">return</span> count;
<a name="l03545"></a>03545 }
<a name="l03546"></a>03546 
<a name="l03547"></a>03547 
<a name="l03548"></a>03548 
<a name="l03549"></a>03549 <span class="comment"></span>
<a name="l03550"></a>03550 <span class="comment">/*!</span>
<a name="l03551"></a>03551 <span class="comment">   \brief Function XORs two bitblocks and computes the bitcount. </span>
<a name="l03552"></a>03552 <span class="comment">   Function does not analyse availability of source blocks.</span>
<a name="l03553"></a>03553 <span class="comment"></span>
<a name="l03554"></a>03554 <span class="comment">   \param src1     - first bit block.</span>
<a name="l03555"></a>03555 <span class="comment">   \param src1_end - first bit block end</span>
<a name="l03556"></a>03556 <span class="comment">   \param src2     - second bit block.</span>
<a name="l03557"></a>03557 <span class="comment"></span>
<a name="l03558"></a>03558 <span class="comment">   @ingroup bitfunc</span>
<a name="l03559"></a>03559 <span class="comment">*/</span>
<a name="l03560"></a>03560 <span class="keyword">inline</span> 
<a name="l03561"></a><a class="code" href="a00120.html#gaf8af8cfe8b49407be1af7398da28c939">03561</a> <span class="keywordtype">unsigned</span> <a class="code" href="a00120.html#gaf8af8cfe8b49407be1af7398da28c939" title="Function XORs two bitblocks and computes the bitcount. Function does not analyse...">bit_block_xor_count</a>(<span class="keyword">const</span> <a class="code" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a>* BMRESTRICT src1,
<a name="l03562"></a>03562                              <span class="keyword">const</span> <a class="code" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a>* BMRESTRICT src1_end, 
<a name="l03563"></a>03563                              <span class="keyword">const</span> <a class="code" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a>* BMRESTRICT src2)
<a name="l03564"></a>03564 {
<a name="l03565"></a>03565     <span class="keywordtype">unsigned</span> count;
<a name="l03566"></a>03566 <span class="preprocessor">#ifdef BMVECTOPT</span>
<a name="l03567"></a>03567 <span class="preprocessor"></span>    count = <a class="code" href="a00098.html#a9954c72d227a3ca78df22a56efad6baf">VECT_BITCOUNT_XOR</a>(src1, src1_end, src2);
<a name="l03568"></a>03568 <span class="preprocessor">#else  </span>
<a name="l03569"></a>03569 <span class="preprocessor"></span>    count = 0;  
<a name="l03570"></a>03570 <span class="preprocessor"># ifdef BM64OPT</span>
<a name="l03571"></a>03571 <span class="preprocessor"></span>    <span class="keyword">const</span> <a class="code" href="a00115.html#a1f6a6dd108cd9e9f4fb284043ef518fe">bm::id64_t</a>* b1 = (<a class="code" href="a00115.html#a1f6a6dd108cd9e9f4fb284043ef518fe">bm::id64_t</a>*) src1;
<a name="l03572"></a>03572     <span class="keyword">const</span> <a class="code" href="a00115.html#a1f6a6dd108cd9e9f4fb284043ef518fe">bm::id64_t</a>* b1_end = (<a class="code" href="a00115.html#a1f6a6dd108cd9e9f4fb284043ef518fe">bm::id64_t</a>*) src1_end;
<a name="l03573"></a>03573     <span class="keyword">const</span> <a class="code" href="a00115.html#a1f6a6dd108cd9e9f4fb284043ef518fe">bm::id64_t</a>* b2 = (<a class="code" href="a00115.html#a1f6a6dd108cd9e9f4fb284043ef518fe">bm::id64_t</a>*) src2;
<a name="l03574"></a>03574     <span class="keywordflow">do</span>
<a name="l03575"></a>03575     {
<a name="l03576"></a>03576         count += bitcount64_4way(b1[0] ^ b2[0], 
<a name="l03577"></a>03577                                  b1[1] ^ b2[1], 
<a name="l03578"></a>03578                                  b1[2] ^ b2[2], 
<a name="l03579"></a>03579                                  b1[3] ^ b2[3]);
<a name="l03580"></a>03580         b1 += 4;
<a name="l03581"></a>03581         b2 += 4;
<a name="l03582"></a>03582     } <span class="keywordflow">while</span> (b1 &lt; b1_end);
<a name="l03583"></a>03583 <span class="preprocessor"># else</span>
<a name="l03584"></a>03584 <span class="preprocessor"></span>    <span class="keywordflow">do</span>
<a name="l03585"></a>03585     {
<a name="l03586"></a>03586         <a class="code" href="a00120.html#ga967f6a5264f47d8adb93f6bdf8cdc129">BM_INCWORD_BITCOUNT</a>(count, src1[0] ^ src2[0]);
<a name="l03587"></a>03587         <a class="code" href="a00120.html#ga967f6a5264f47d8adb93f6bdf8cdc129">BM_INCWORD_BITCOUNT</a>(count, src1[1] ^ src2[1]);
<a name="l03588"></a>03588         <a class="code" href="a00120.html#ga967f6a5264f47d8adb93f6bdf8cdc129">BM_INCWORD_BITCOUNT</a>(count, src1[2] ^ src2[2]);
<a name="l03589"></a>03589         <a class="code" href="a00120.html#ga967f6a5264f47d8adb93f6bdf8cdc129">BM_INCWORD_BITCOUNT</a>(count, src1[3] ^ src2[3]);
<a name="l03590"></a>03590 
<a name="l03591"></a>03591         src1+=4;
<a name="l03592"></a>03592         src2+=4;
<a name="l03593"></a>03593     } <span class="keywordflow">while</span> (src1 &lt; src1_end);
<a name="l03594"></a>03594 <span class="preprocessor"># endif</span>
<a name="l03595"></a>03595 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l03596"></a>03596 <span class="preprocessor"></span>    <span class="keywordflow">return</span> count;
<a name="l03597"></a>03597 }
<a name="l03598"></a>03598 
<a name="l03599"></a>03599 <span class="comment"></span>
<a name="l03600"></a>03600 <span class="comment">/*!</span>
<a name="l03601"></a>03601 <span class="comment">   \brief Function XORs two bitblocks and and tests for any bit.</span>
<a name="l03602"></a>03602 <span class="comment">   Function does not analyse availability of source blocks.</span>
<a name="l03603"></a>03603 <span class="comment"></span>
<a name="l03604"></a>03604 <span class="comment">   \param src1     - first bit block.</span>
<a name="l03605"></a>03605 <span class="comment">   \param src1_end - first bit block end</span>
<a name="l03606"></a>03606 <span class="comment">   \param src2     - second bit block.</span>
<a name="l03607"></a>03607 <span class="comment"></span>
<a name="l03608"></a>03608 <span class="comment">   @ingroup bitfunc</span>
<a name="l03609"></a>03609 <span class="comment">*/</span>
<a name="l03610"></a>03610 <span class="keyword">inline</span> 
<a name="l03611"></a><a class="code" href="a00120.html#gafbc3ffafc859a503fdd2fc96e7fb60ce">03611</a> <span class="keywordtype">unsigned</span> <a class="code" href="a00120.html#gafbc3ffafc859a503fdd2fc96e7fb60ce" title="Function XORs two bitblocks and and tests for any bit. Function does not analyse...">bit_block_xor_any</a>(<span class="keyword">const</span> <a class="code" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a>* BMRESTRICT src1,
<a name="l03612"></a>03612                              <span class="keyword">const</span> <a class="code" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a>* BMRESTRICT src1_end, 
<a name="l03613"></a>03613                              <span class="keyword">const</span> <a class="code" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a>* BMRESTRICT src2)
<a name="l03614"></a>03614 {
<a name="l03615"></a>03615     <span class="keywordtype">unsigned</span> count = 0;
<a name="l03616"></a>03616     <span class="keywordflow">do</span>
<a name="l03617"></a>03617     {
<a name="l03618"></a>03618         count = (src1[0] ^ src2[0]) |
<a name="l03619"></a>03619                 (src1[1] ^ src2[1]) |
<a name="l03620"></a>03620                 (src1[2] ^ src2[2]) |
<a name="l03621"></a>03621                 (src1[3] ^ src2[3]);
<a name="l03622"></a>03622 
<a name="l03623"></a>03623         src1+=4; src2+=4;
<a name="l03624"></a>03624     } <span class="keywordflow">while</span> ((src1 &lt; src1_end) &amp;&amp; (count == 0));
<a name="l03625"></a>03625     <span class="keywordflow">return</span> count;
<a name="l03626"></a>03626 }
<a name="l03627"></a>03627 
<a name="l03628"></a>03628 
<a name="l03629"></a>03629 
<a name="l03630"></a>03630 <span class="comment"></span>
<a name="l03631"></a>03631 <span class="comment">/*!</span>
<a name="l03632"></a>03632 <span class="comment">   \brief Function SUBs two bitblocks and computes the bitcount. </span>
<a name="l03633"></a>03633 <span class="comment">   Function does not analyse availability of source blocks.</span>
<a name="l03634"></a>03634 <span class="comment"></span>
<a name="l03635"></a>03635 <span class="comment">   \param src1     - first bit block.</span>
<a name="l03636"></a>03636 <span class="comment">   \param src1_end - first bit block end</span>
<a name="l03637"></a>03637 <span class="comment">   \param src2     - second bit block.</span>
<a name="l03638"></a>03638 <span class="comment"></span>
<a name="l03639"></a>03639 <span class="comment">   @ingroup bitfunc</span>
<a name="l03640"></a>03640 <span class="comment">*/</span>
<a name="l03641"></a>03641 <span class="keyword">inline</span> 
<a name="l03642"></a><a class="code" href="a00120.html#gad34175255e9860a572fcf2e664a6de8e">03642</a> <span class="keywordtype">unsigned</span> <a class="code" href="a00120.html#gad34175255e9860a572fcf2e664a6de8e" title="Function SUBs two bitblocks and computes the bitcount. Function does not analyse...">bit_block_sub_count</a>(<span class="keyword">const</span> <a class="code" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a>* BMRESTRICT src1, 
<a name="l03643"></a>03643                              <span class="keyword">const</span> <a class="code" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a>* BMRESTRICT src1_end, 
<a name="l03644"></a>03644                              <span class="keyword">const</span> <a class="code" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a>* BMRESTRICT src2)
<a name="l03645"></a>03645 {
<a name="l03646"></a>03646     <span class="keywordtype">unsigned</span> count;
<a name="l03647"></a>03647 <span class="preprocessor">#ifdef BMVECTOPT</span>
<a name="l03648"></a>03648 <span class="preprocessor"></span>    count = <a class="code" href="a00098.html#a98aaf230431767be4838323266d0b493">VECT_BITCOUNT_SUB</a>(src1, src1_end, src2);
<a name="l03649"></a>03649 <span class="preprocessor">#else  </span>
<a name="l03650"></a>03650 <span class="preprocessor"></span>    count = 0;  
<a name="l03651"></a>03651 <span class="preprocessor"># ifdef BM64OPT</span>
<a name="l03652"></a>03652 <span class="preprocessor"></span>    <span class="keyword">const</span> <a class="code" href="a00115.html#a1f6a6dd108cd9e9f4fb284043ef518fe">bm::id64_t</a>* b1 = (<a class="code" href="a00115.html#a1f6a6dd108cd9e9f4fb284043ef518fe">bm::id64_t</a>*) src1;
<a name="l03653"></a>03653     <span class="keyword">const</span> <a class="code" href="a00115.html#a1f6a6dd108cd9e9f4fb284043ef518fe">bm::id64_t</a>* b1_end = (<a class="code" href="a00115.html#a1f6a6dd108cd9e9f4fb284043ef518fe">bm::id64_t</a>*) src1_end;
<a name="l03654"></a>03654     <span class="keyword">const</span> <a class="code" href="a00115.html#a1f6a6dd108cd9e9f4fb284043ef518fe">bm::id64_t</a>* b2 = (<a class="code" href="a00115.html#a1f6a6dd108cd9e9f4fb284043ef518fe">bm::id64_t</a>*) src2;
<a name="l03655"></a>03655     <span class="keywordflow">do</span>
<a name="l03656"></a>03656     {
<a name="l03657"></a>03657         count += bitcount64_4way(b1[0] &amp; ~b2[0], 
<a name="l03658"></a>03658                                  b1[1] &amp; ~b2[1], 
<a name="l03659"></a>03659                                  b1[2] &amp; ~b2[2], 
<a name="l03660"></a>03660                                  b1[3] &amp; ~b2[3]);
<a name="l03661"></a>03661         b1 += 4;
<a name="l03662"></a>03662         b2 += 4;
<a name="l03663"></a>03663     } <span class="keywordflow">while</span> (b1 &lt; b1_end);
<a name="l03664"></a>03664 <span class="preprocessor"># else</span>
<a name="l03665"></a>03665 <span class="preprocessor"></span>    <span class="keywordflow">do</span>
<a name="l03666"></a>03666     {
<a name="l03667"></a>03667         <a class="code" href="a00120.html#ga967f6a5264f47d8adb93f6bdf8cdc129">BM_INCWORD_BITCOUNT</a>(count, src1[0] &amp; ~src2[0]);
<a name="l03668"></a>03668         <a class="code" href="a00120.html#ga967f6a5264f47d8adb93f6bdf8cdc129">BM_INCWORD_BITCOUNT</a>(count, src1[1] &amp; ~src2[1]);
<a name="l03669"></a>03669         <a class="code" href="a00120.html#ga967f6a5264f47d8adb93f6bdf8cdc129">BM_INCWORD_BITCOUNT</a>(count, src1[2] &amp; ~src2[2]);
<a name="l03670"></a>03670         <a class="code" href="a00120.html#ga967f6a5264f47d8adb93f6bdf8cdc129">BM_INCWORD_BITCOUNT</a>(count, src1[3] &amp; ~src2[3]);
<a name="l03671"></a>03671 
<a name="l03672"></a>03672         src1+=4;
<a name="l03673"></a>03673         src2+=4;
<a name="l03674"></a>03674     } <span class="keywordflow">while</span> (src1 &lt; src1_end);
<a name="l03675"></a>03675 <span class="preprocessor"># endif</span>
<a name="l03676"></a>03676 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l03677"></a>03677 <span class="preprocessor"></span>    <span class="keywordflow">return</span> count;
<a name="l03678"></a>03678 }
<a name="l03679"></a>03679 <span class="comment"></span>
<a name="l03680"></a>03680 <span class="comment">/*!</span>
<a name="l03681"></a>03681 <span class="comment">   \brief Function SUBs two bitblocks and and tests for any bit.</span>
<a name="l03682"></a>03682 <span class="comment">   Function does not analyse availability of source blocks.</span>
<a name="l03683"></a>03683 <span class="comment"></span>
<a name="l03684"></a>03684 <span class="comment">   \param src1     - first bit block.</span>
<a name="l03685"></a>03685 <span class="comment">   \param src1_end - first bit block end</span>
<a name="l03686"></a>03686 <span class="comment">   \param src2     - second bit block.</span>
<a name="l03687"></a>03687 <span class="comment"></span>
<a name="l03688"></a>03688 <span class="comment">   @ingroup bitfunc</span>
<a name="l03689"></a>03689 <span class="comment">*/</span>
<a name="l03690"></a>03690 <span class="keyword">inline</span> 
<a name="l03691"></a><a class="code" href="a00120.html#ga3f51735d2ca08e5a9fae2c9c49138c5c">03691</a> <span class="keywordtype">unsigned</span> <a class="code" href="a00120.html#ga3f51735d2ca08e5a9fae2c9c49138c5c" title="Function SUBs two bitblocks and and tests for any bit. Function does not analyse...">bit_block_sub_any</a>(<span class="keyword">const</span> <a class="code" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a>* BMRESTRICT src1,
<a name="l03692"></a>03692                              <span class="keyword">const</span> <a class="code" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a>* BMRESTRICT src1_end, 
<a name="l03693"></a>03693                              <span class="keyword">const</span> <a class="code" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a>* BMRESTRICT src2)
<a name="l03694"></a>03694 {
<a name="l03695"></a>03695     <span class="keywordtype">unsigned</span> count = 0;
<a name="l03696"></a>03696     <span class="keywordflow">do</span>
<a name="l03697"></a>03697     {
<a name="l03698"></a>03698         count = (src1[0] &amp; ~src2[0]) |
<a name="l03699"></a>03699                 (src1[1] &amp; ~src2[1]) |
<a name="l03700"></a>03700                 (src1[2] &amp; ~src2[2]) |
<a name="l03701"></a>03701                 (src1[3] &amp; ~src2[3]);
<a name="l03702"></a>03702 
<a name="l03703"></a>03703         src1+=4; src2+=4;
<a name="l03704"></a>03704     } <span class="keywordflow">while</span> ((src1 &lt; src1_end) &amp;&amp; (count == 0));
<a name="l03705"></a>03705     <span class="keywordflow">return</span> count;
<a name="l03706"></a>03706 }
<a name="l03707"></a>03707 
<a name="l03708"></a>03708 
<a name="l03709"></a>03709 <span class="comment"></span>
<a name="l03710"></a>03710 <span class="comment">/*!</span>
<a name="l03711"></a>03711 <span class="comment">   \brief Function ORs two bitblocks and computes the bitcount. </span>
<a name="l03712"></a>03712 <span class="comment">   Function does not analyse availability of source blocks.</span>
<a name="l03713"></a>03713 <span class="comment"></span>
<a name="l03714"></a>03714 <span class="comment">   \param src1     - first bit block</span>
<a name="l03715"></a>03715 <span class="comment">   \param src1_end - first block end</span>
<a name="l03716"></a>03716 <span class="comment">   \param src2     - second bit block.</span>
<a name="l03717"></a>03717 <span class="comment"></span>
<a name="l03718"></a>03718 <span class="comment">   @ingroup bitfunc</span>
<a name="l03719"></a>03719 <span class="comment">*/</span>
<a name="l03720"></a>03720 <span class="keyword">inline</span> 
<a name="l03721"></a><a class="code" href="a00120.html#gacf4f8ab164277278448a541863c07517">03721</a> <span class="keywordtype">unsigned</span> <a class="code" href="a00120.html#gacf4f8ab164277278448a541863c07517" title="Function ORs two bitblocks and computes the bitcount. Function does not analyse availability...">bit_block_or_count</a>(<span class="keyword">const</span> <a class="code" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a>* src1, 
<a name="l03722"></a>03722                             <span class="keyword">const</span> <a class="code" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a>* src1_end,
<a name="l03723"></a>03723                             <span class="keyword">const</span> <a class="code" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a>* src2)
<a name="l03724"></a>03724 {
<a name="l03725"></a>03725     <span class="keywordtype">unsigned</span> count;
<a name="l03726"></a>03726 <span class="preprocessor">#ifdef BMVECTOPT</span>
<a name="l03727"></a>03727 <span class="preprocessor"></span>    count = <a class="code" href="a00098.html#a07583d48db4ede7eadbc3156e9dd7d3b">VECT_BITCOUNT_OR</a>(src1, src1_end, src2);
<a name="l03728"></a>03728 <span class="preprocessor">#else  </span>
<a name="l03729"></a>03729 <span class="preprocessor"></span>    count = 0;  
<a name="l03730"></a>03730 <span class="preprocessor"># ifdef BM64OPT</span>
<a name="l03731"></a>03731 <span class="preprocessor"></span>    <span class="keyword">const</span> <a class="code" href="a00115.html#a1f6a6dd108cd9e9f4fb284043ef518fe">bm::id64_t</a>* b1 = (<a class="code" href="a00115.html#a1f6a6dd108cd9e9f4fb284043ef518fe">bm::id64_t</a>*) src1;
<a name="l03732"></a>03732     <span class="keyword">const</span> <a class="code" href="a00115.html#a1f6a6dd108cd9e9f4fb284043ef518fe">bm::id64_t</a>* b1_end = (<a class="code" href="a00115.html#a1f6a6dd108cd9e9f4fb284043ef518fe">bm::id64_t</a>*) src1_end;
<a name="l03733"></a>03733     <span class="keyword">const</span> <a class="code" href="a00115.html#a1f6a6dd108cd9e9f4fb284043ef518fe">bm::id64_t</a>* b2 = (<a class="code" href="a00115.html#a1f6a6dd108cd9e9f4fb284043ef518fe">bm::id64_t</a>*) src2;
<a name="l03734"></a>03734     <span class="keywordflow">do</span>
<a name="l03735"></a>03735     {
<a name="l03736"></a>03736         count += bitcount64_4way(b1[0] | b2[0], 
<a name="l03737"></a>03737                                  b1[1] | b2[1], 
<a name="l03738"></a>03738                                  b1[2] | b2[2], 
<a name="l03739"></a>03739                                  b1[3] | b2[3]);
<a name="l03740"></a>03740         b1 += 4;
<a name="l03741"></a>03741         b2 += 4;
<a name="l03742"></a>03742     } <span class="keywordflow">while</span> (b1 &lt; b1_end);
<a name="l03743"></a>03743 <span class="preprocessor"># else</span>
<a name="l03744"></a>03744 <span class="preprocessor"></span>    <span class="keywordflow">do</span>
<a name="l03745"></a>03745     {
<a name="l03746"></a>03746         <a class="code" href="a00120.html#ga967f6a5264f47d8adb93f6bdf8cdc129">BM_INCWORD_BITCOUNT</a>(count, src1[0] | src2[0]);
<a name="l03747"></a>03747         <a class="code" href="a00120.html#ga967f6a5264f47d8adb93f6bdf8cdc129">BM_INCWORD_BITCOUNT</a>(count, src1[1] | src2[1]);
<a name="l03748"></a>03748         <a class="code" href="a00120.html#ga967f6a5264f47d8adb93f6bdf8cdc129">BM_INCWORD_BITCOUNT</a>(count, src1[2] | src2[2]);
<a name="l03749"></a>03749         <a class="code" href="a00120.html#ga967f6a5264f47d8adb93f6bdf8cdc129">BM_INCWORD_BITCOUNT</a>(count, src1[3] | src2[3]);
<a name="l03750"></a>03750 
<a name="l03751"></a>03751         src1+=4;
<a name="l03752"></a>03752         src2+=4;
<a name="l03753"></a>03753     } <span class="keywordflow">while</span> (src1 &lt; src1_end);
<a name="l03754"></a>03754 <span class="preprocessor"># endif</span>
<a name="l03755"></a>03755 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l03756"></a>03756 <span class="preprocessor"></span>    <span class="keywordflow">return</span> count;
<a name="l03757"></a>03757 }
<a name="l03758"></a>03758 <span class="comment"></span>
<a name="l03759"></a>03759 <span class="comment">/*!</span>
<a name="l03760"></a>03760 <span class="comment">   \brief Function ORs two bitblocks and and tests for any bit.</span>
<a name="l03761"></a>03761 <span class="comment">   Function does not analyse availability of source blocks.</span>
<a name="l03762"></a>03762 <span class="comment"></span>
<a name="l03763"></a>03763 <span class="comment">   \param src1     - first bit block.</span>
<a name="l03764"></a>03764 <span class="comment">   \param src1_end - first bit block end</span>
<a name="l03765"></a>03765 <span class="comment">   \param src2     - second bit block.</span>
<a name="l03766"></a>03766 <span class="comment"></span>
<a name="l03767"></a>03767 <span class="comment">   @ingroup bitfunc</span>
<a name="l03768"></a>03768 <span class="comment">*/</span>
<a name="l03769"></a>03769 <span class="keyword">inline</span> 
<a name="l03770"></a><a class="code" href="a00120.html#gab2047495f7844d3014ff697503669d24">03770</a> <span class="keywordtype">unsigned</span> <a class="code" href="a00120.html#gab2047495f7844d3014ff697503669d24" title="Function ORs two bitblocks and and tests for any bit. Function does not analyse availability...">bit_block_or_any</a>(<span class="keyword">const</span> <a class="code" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a>* BMRESTRICT src1,
<a name="l03771"></a>03771                           <span class="keyword">const</span> <a class="code" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a>* BMRESTRICT src1_end, 
<a name="l03772"></a>03772                           <span class="keyword">const</span> <a class="code" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a>* BMRESTRICT src2)
<a name="l03773"></a>03773 {
<a name="l03774"></a>03774     <span class="keywordtype">unsigned</span> count = 0;
<a name="l03775"></a>03775     <span class="keywordflow">do</span>
<a name="l03776"></a>03776     {
<a name="l03777"></a>03777         count = (src1[0] | src2[0]) |
<a name="l03778"></a>03778                 (src1[1] | src2[1]) |
<a name="l03779"></a>03779                 (src1[2] | src2[2]) |
<a name="l03780"></a>03780                 (src1[3] | src2[3]);
<a name="l03781"></a>03781 
<a name="l03782"></a>03782         src1+=4; src2+=4;
<a name="l03783"></a>03783     } <span class="keywordflow">while</span> ((src1 &lt; src1_end) &amp;&amp; (count == 0));
<a name="l03784"></a>03784     <span class="keywordflow">return</span> count;
<a name="l03785"></a>03785 }
<a name="l03786"></a>03786 
<a name="l03787"></a>03787 
<a name="l03788"></a>03788 
<a name="l03789"></a>03789 <span class="comment"></span>
<a name="l03790"></a>03790 <span class="comment">/*!</span>
<a name="l03791"></a>03791 <span class="comment">   \brief bitblock AND operation. </span>
<a name="l03792"></a>03792 <span class="comment"></span>
<a name="l03793"></a>03793 <span class="comment">   \param dst - destination block.</span>
<a name="l03794"></a>03794 <span class="comment">   \param src - source block.</span>
<a name="l03795"></a>03795 <span class="comment"></span>
<a name="l03796"></a>03796 <span class="comment">   \returns pointer on destination block. </span>
<a name="l03797"></a>03797 <span class="comment">    If returned value  equal to src means that block mutation requested. </span>
<a name="l03798"></a>03798 <span class="comment">    NULL is valid return value.</span>
<a name="l03799"></a>03799 <span class="comment"></span>
<a name="l03800"></a>03800 <span class="comment">   @ingroup bitfunc</span>
<a name="l03801"></a>03801 <span class="comment">*/</span>
<a name="l03802"></a><a class="code" href="a00120.html#ga869fce5348076d4c7b92adcc2f1a49ab">03802</a> <span class="keyword">inline</span> <a class="code" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a>* <a class="code" href="a00120.html#ga869fce5348076d4c7b92adcc2f1a49ab" title="bitblock AND operation.">bit_operation_and</a>(<a class="code" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a>* BMRESTRICT dst, 
<a name="l03803"></a>03803                                      <span class="keyword">const</span> <a class="code" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a>* BMRESTRICT src)
<a name="l03804"></a>03804 {
<a name="l03805"></a>03805     <a class="code" href="a00092.html#aa44515fab0ace8928d1cb82009a95bf8">BM_ASSERT</a>(dst || src);
<a name="l03806"></a>03806 
<a name="l03807"></a>03807     <a class="code" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a>* ret = dst;
<a name="l03808"></a>03808 
<a name="l03809"></a>03809     <span class="keywordflow">if</span> (<a class="code" href="a00092.html#a13ba598909515339ceede09e3b9b0198">IS_VALID_ADDR</a>(dst))  <span class="comment">// The destination block already exists</span>
<a name="l03810"></a>03810     {
<a name="l03811"></a>03811 
<a name="l03812"></a>03812         <span class="keywordflow">if</span> (!<a class="code" href="a00092.html#a13ba598909515339ceede09e3b9b0198">IS_VALID_ADDR</a>(src))
<a name="l03813"></a>03813         {
<a name="l03814"></a>03814             <span class="keywordflow">if</span> (<a class="code" href="a00092.html#accfe8650b3e8ee65da94f7712b3c44b8">IS_EMPTY_BLOCK</a>(src))
<a name="l03815"></a>03815             {
<a name="l03816"></a>03816                 <span class="comment">//If the source block is zero </span>
<a name="l03817"></a>03817                 <span class="comment">//just clean the destination block</span>
<a name="l03818"></a>03818                 <span class="keywordflow">return</span> 0;
<a name="l03819"></a>03819             }
<a name="l03820"></a>03820         }
<a name="l03821"></a>03821         <span class="keywordflow">else</span>
<a name="l03822"></a>03822         {
<a name="l03823"></a>03823             <span class="comment">// Regular operation AND on the whole block.</span>
<a name="l03824"></a>03824             <a class="code" href="a00120.html#ga882f79df0a0175ad4ddf483c5f1eeb0e" title="Plain bitblock AND operation. Function does not analyse availability of source and...">bit_block_and</a>(dst, src);
<a name="l03825"></a>03825         }
<a name="l03826"></a>03826     }
<a name="l03827"></a>03827     <span class="keywordflow">else</span> <span class="comment">// The destination block does not exist yet</span>
<a name="l03828"></a>03828     {
<a name="l03829"></a>03829         <span class="keywordflow">if</span>(!<a class="code" href="a00092.html#a13ba598909515339ceede09e3b9b0198">IS_VALID_ADDR</a>(src))
<a name="l03830"></a>03830         {
<a name="l03831"></a>03831             <span class="keywordflow">if</span>(<a class="code" href="a00092.html#accfe8650b3e8ee65da94f7712b3c44b8">IS_EMPTY_BLOCK</a>(src)) 
<a name="l03832"></a>03832             {
<a name="l03833"></a>03833                 <span class="comment">// The source block is empty.</span>
<a name="l03834"></a>03834                 <span class="comment">// One argument empty - all result is empty.</span>
<a name="l03835"></a>03835                 <span class="keywordflow">return</span> 0;
<a name="l03836"></a>03836             }
<a name="l03837"></a>03837             <span class="comment">// Here we have nothing to do.</span>
<a name="l03838"></a>03838             <span class="comment">// Src block is all ON, dst block remains as it is</span>
<a name="l03839"></a>03839         }
<a name="l03840"></a>03840         <span class="keywordflow">else</span> <span class="comment">// destination block does not exists, src - valid block</span>
<a name="l03841"></a>03841         {
<a name="l03842"></a>03842             <span class="keywordflow">if</span> (<a class="code" href="a00092.html#a074acb37afea68caaffe3832d326eb44">IS_FULL_BLOCK</a>(dst))
<a name="l03843"></a>03843             {
<a name="l03844"></a>03844                 <span class="keywordflow">return</span> <span class="keyword">const_cast&lt;</span><a class="code" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a>*<span class="keyword">&gt;</span>(src);
<a name="l03845"></a>03845             }
<a name="l03846"></a>03846             <span class="comment">// Nothng to do.</span>
<a name="l03847"></a>03847             <span class="comment">// Dst block is all ZERO no combination required.</span>
<a name="l03848"></a>03848         }
<a name="l03849"></a>03849     }
<a name="l03850"></a>03850 
<a name="l03851"></a>03851     <span class="keywordflow">return</span> ret;
<a name="l03852"></a>03852 }
<a name="l03853"></a>03853 
<a name="l03854"></a>03854 <span class="comment"></span>
<a name="l03855"></a>03855 <span class="comment">/*!</span>
<a name="l03856"></a>03856 <span class="comment">   \brief Performs bitblock AND operation and calculates bitcount of the result. </span>
<a name="l03857"></a>03857 <span class="comment"></span>
<a name="l03858"></a>03858 <span class="comment">   \param src1     - first bit block.</span>
<a name="l03859"></a>03859 <span class="comment">   \param src1_end - first bit block end</span>
<a name="l03860"></a>03860 <span class="comment">   \param src2     - second bit block.</span>
<a name="l03861"></a>03861 <span class="comment"></span>
<a name="l03862"></a>03862 <span class="comment">   \returns bitcount value </span>
<a name="l03863"></a>03863 <span class="comment"></span>
<a name="l03864"></a>03864 <span class="comment">   @ingroup bitfunc</span>
<a name="l03865"></a>03865 <span class="comment">*/</span>
<a name="l03866"></a>03866 <span class="keyword">inline</span> 
<a name="l03867"></a><a class="code" href="a00120.html#ga9765914087df2fc22ec18db8128f2a12">03867</a> <a class="code" href="a00115.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a> <a class="code" href="a00120.html#ga9765914087df2fc22ec18db8128f2a12" title="Performs bitblock AND operation and calculates bitcount of the result.">bit_operation_and_count</a>(<span class="keyword">const</span> <a class="code" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a>* BMRESTRICT src1,
<a name="l03868"></a>03868                                  <span class="keyword">const</span> <a class="code" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a>* BMRESTRICT src1_end,
<a name="l03869"></a>03869                                  <span class="keyword">const</span> <a class="code" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a>* BMRESTRICT src2)
<a name="l03870"></a>03870 {
<a name="l03871"></a>03871     <span class="keywordflow">if</span> (<a class="code" href="a00092.html#accfe8650b3e8ee65da94f7712b3c44b8">IS_EMPTY_BLOCK</a>(src1) || <a class="code" href="a00092.html#accfe8650b3e8ee65da94f7712b3c44b8">IS_EMPTY_BLOCK</a>(src2))
<a name="l03872"></a>03872     {
<a name="l03873"></a>03873         <span class="keywordflow">return</span> 0;
<a name="l03874"></a>03874     }
<a name="l03875"></a>03875     <span class="keywordflow">return</span> <a class="code" href="a00120.html#ga0070984bb1d332610150a9106ab8eb0a" title="Function ANDs two bitblocks and computes the bitcount. Function does not analyse...">bit_block_and_count</a>(src1, src1_end, src2);
<a name="l03876"></a>03876 }
<a name="l03877"></a>03877 <span class="comment"></span>
<a name="l03878"></a>03878 <span class="comment">/*!</span>
<a name="l03879"></a>03879 <span class="comment">   \brief Performs bitblock AND operation test. </span>
<a name="l03880"></a>03880 <span class="comment"></span>
<a name="l03881"></a>03881 <span class="comment">   \param src1     - first bit block.</span>
<a name="l03882"></a>03882 <span class="comment">   \param src1_end - first bit block end</span>
<a name="l03883"></a>03883 <span class="comment">   \param src2     - second bit block.</span>
<a name="l03884"></a>03884 <span class="comment"></span>
<a name="l03885"></a>03885 <span class="comment">   \returns non zero if there is any value </span>
<a name="l03886"></a>03886 <span class="comment"></span>
<a name="l03887"></a>03887 <span class="comment">   @ingroup bitfunc</span>
<a name="l03888"></a>03888 <span class="comment">*/</span>
<a name="l03889"></a>03889 <span class="keyword">inline</span> 
<a name="l03890"></a><a class="code" href="a00120.html#ga0e7995f7d6c791f6ff27a8dd21d324e5">03890</a> <a class="code" href="a00115.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a> <a class="code" href="a00120.html#ga0e7995f7d6c791f6ff27a8dd21d324e5" title="Performs bitblock AND operation test.">bit_operation_and_any</a>(<span class="keyword">const</span> <a class="code" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a>* BMRESTRICT src1,
<a name="l03891"></a>03891                                <span class="keyword">const</span> <a class="code" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a>* BMRESTRICT src1_end,
<a name="l03892"></a>03892                                <span class="keyword">const</span> <a class="code" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a>* BMRESTRICT src2)
<a name="l03893"></a>03893 {
<a name="l03894"></a>03894     <span class="keywordflow">if</span> (<a class="code" href="a00092.html#accfe8650b3e8ee65da94f7712b3c44b8">IS_EMPTY_BLOCK</a>(src1) || <a class="code" href="a00092.html#accfe8650b3e8ee65da94f7712b3c44b8">IS_EMPTY_BLOCK</a>(src2))
<a name="l03895"></a>03895     {
<a name="l03896"></a>03896         <span class="keywordflow">return</span> 0;
<a name="l03897"></a>03897     }
<a name="l03898"></a>03898     <span class="keywordflow">return</span> <a class="code" href="a00120.html#ga9fe2d12ddac5293fe53038c687c732f3" title="Function ANDs two bitblocks and tests for any bit. Function does not analyse availability...">bit_block_and_any</a>(src1, src1_end, src2);
<a name="l03899"></a>03899 }
<a name="l03900"></a>03900 
<a name="l03901"></a>03901 
<a name="l03902"></a>03902 <span class="comment"></span>
<a name="l03903"></a>03903 <span class="comment">/*!</span>
<a name="l03904"></a>03904 <span class="comment">   \brief Performs bitblock SUB operation and calculates bitcount of the result. </span>
<a name="l03905"></a>03905 <span class="comment"></span>
<a name="l03906"></a>03906 <span class="comment">   \param src1      - first bit block.</span>
<a name="l03907"></a>03907 <span class="comment">   \param src1_end  - first bit block end</span>
<a name="l03908"></a>03908 <span class="comment">   \param src2      - second bit block</span>
<a name="l03909"></a>03909 <span class="comment"></span>
<a name="l03910"></a>03910 <span class="comment">   \returns bitcount value </span>
<a name="l03911"></a>03911 <span class="comment"></span>
<a name="l03912"></a>03912 <span class="comment">   @ingroup bitfunc</span>
<a name="l03913"></a>03913 <span class="comment">*/</span>
<a name="l03914"></a>03914 <span class="keyword">inline</span> 
<a name="l03915"></a><a class="code" href="a00120.html#gaabb39bf01bf973cb7bf3648873921ab7">03915</a> <a class="code" href="a00115.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a> <a class="code" href="a00120.html#gaabb39bf01bf973cb7bf3648873921ab7" title="Performs bitblock SUB operation and calculates bitcount of the result.">bit_operation_sub_count</a>(<span class="keyword">const</span> <a class="code" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a>* BMRESTRICT src1, 
<a name="l03916"></a>03916                                  <span class="keyword">const</span> <a class="code" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a>* BMRESTRICT src1_end,
<a name="l03917"></a>03917                                  <span class="keyword">const</span> <a class="code" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a>* BMRESTRICT src2)
<a name="l03918"></a>03918 {
<a name="l03919"></a>03919     <span class="keywordflow">if</span> (<a class="code" href="a00092.html#accfe8650b3e8ee65da94f7712b3c44b8">IS_EMPTY_BLOCK</a>(src1))
<a name="l03920"></a>03920     {
<a name="l03921"></a>03921         <span class="keywordflow">return</span> 0;
<a name="l03922"></a>03922     }
<a name="l03923"></a>03923     
<a name="l03924"></a>03924     <span class="keywordflow">if</span> (<a class="code" href="a00092.html#accfe8650b3e8ee65da94f7712b3c44b8">IS_EMPTY_BLOCK</a>(src2)) <span class="comment">// nothing to diff</span>
<a name="l03925"></a>03925     {
<a name="l03926"></a>03926         <span class="keywordflow">return</span> <a class="code" href="a00120.html#gab30df14a61f036d690c091878feaff1c" title="Bitcount for bit string.">bit_block_calc_count</a>(src1, src1_end);
<a name="l03927"></a>03927     }
<a name="l03928"></a>03928     <span class="keywordflow">return</span> <a class="code" href="a00120.html#gad34175255e9860a572fcf2e664a6de8e" title="Function SUBs two bitblocks and computes the bitcount. Function does not analyse...">bit_block_sub_count</a>(src1, src1_end, src2);
<a name="l03929"></a>03929 }
<a name="l03930"></a>03930 
<a name="l03931"></a>03931 <span class="comment"></span>
<a name="l03932"></a>03932 <span class="comment">/*!</span>
<a name="l03933"></a>03933 <span class="comment">   \brief Performs inverted bitblock SUB operation and calculates </span>
<a name="l03934"></a>03934 <span class="comment">          bitcount of the result. </span>
<a name="l03935"></a>03935 <span class="comment"></span>
<a name="l03936"></a>03936 <span class="comment">   \param src1      - first bit block.</span>
<a name="l03937"></a>03937 <span class="comment">   \param src1_end  - first bit block end</span>
<a name="l03938"></a>03938 <span class="comment">   \param src2      - second bit block</span>
<a name="l03939"></a>03939 <span class="comment"></span>
<a name="l03940"></a>03940 <span class="comment">   \returns bitcount value </span>
<a name="l03941"></a>03941 <span class="comment"></span>
<a name="l03942"></a>03942 <span class="comment">   @ingroup bitfunc</span>
<a name="l03943"></a>03943 <span class="comment">*/</span>
<a name="l03944"></a>03944 <span class="keyword">inline</span> 
<a name="l03945"></a><a class="code" href="a00120.html#ga53867faf377db72324b858a37063c0b8">03945</a> <a class="code" href="a00115.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a> <a class="code" href="a00120.html#ga53867faf377db72324b858a37063c0b8" title="Performs inverted bitblock SUB operation and calculates bitcount of the result.">bit_operation_sub_count_inv</a>(<span class="keyword">const</span> <a class="code" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a>* BMRESTRICT src1, 
<a name="l03946"></a>03946                                      <span class="keyword">const</span> <a class="code" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a>* BMRESTRICT src1_end,
<a name="l03947"></a>03947                                      <span class="keyword">const</span> <a class="code" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a>* BMRESTRICT src2)
<a name="l03948"></a>03948 {
<a name="l03949"></a>03949     <span class="keywordtype">unsigned</span> arr_size = unsigned(src1_end - src1);
<a name="l03950"></a>03950     <span class="keywordflow">return</span> <a class="code" href="a00120.html#gaabb39bf01bf973cb7bf3648873921ab7" title="Performs bitblock SUB operation and calculates bitcount of the result.">bit_operation_sub_count</a>(src2, src2+arr_size, src1);
<a name="l03951"></a>03951 }
<a name="l03952"></a>03952 
<a name="l03953"></a>03953 <span class="comment"></span>
<a name="l03954"></a>03954 <span class="comment">/*!</span>
<a name="l03955"></a>03955 <span class="comment">   \brief Performs bitblock test of SUB operation. </span>
<a name="l03956"></a>03956 <span class="comment"></span>
<a name="l03957"></a>03957 <span class="comment">   \param src1      - first bit block.</span>
<a name="l03958"></a>03958 <span class="comment">   \param src1_end  - first bit block end</span>
<a name="l03959"></a>03959 <span class="comment">   \param src2      - second bit block</span>
<a name="l03960"></a>03960 <span class="comment"></span>
<a name="l03961"></a>03961 <span class="comment">   \returns non zero value if there are any bits</span>
<a name="l03962"></a>03962 <span class="comment"></span>
<a name="l03963"></a>03963 <span class="comment">   @ingroup bitfunc</span>
<a name="l03964"></a>03964 <span class="comment">*/</span>
<a name="l03965"></a>03965 <span class="keyword">inline</span> 
<a name="l03966"></a><a class="code" href="a00120.html#ga847d5a84673b284be984f0db583e2723">03966</a> <a class="code" href="a00115.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a> <a class="code" href="a00120.html#ga847d5a84673b284be984f0db583e2723" title="Performs bitblock test of SUB operation.">bit_operation_sub_any</a>(<span class="keyword">const</span> <a class="code" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a>* BMRESTRICT src1, 
<a name="l03967"></a>03967                                <span class="keyword">const</span> <a class="code" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a>* BMRESTRICT src1_end,
<a name="l03968"></a>03968                                <span class="keyword">const</span> <a class="code" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a>* BMRESTRICT src2)
<a name="l03969"></a>03969 {
<a name="l03970"></a>03970     <span class="keywordflow">if</span> (<a class="code" href="a00092.html#accfe8650b3e8ee65da94f7712b3c44b8">IS_EMPTY_BLOCK</a>(src1))
<a name="l03971"></a>03971     {
<a name="l03972"></a>03972         <span class="keywordflow">return</span> 0;
<a name="l03973"></a>03973     }
<a name="l03974"></a>03974     
<a name="l03975"></a>03975     <span class="keywordflow">if</span> (<a class="code" href="a00092.html#accfe8650b3e8ee65da94f7712b3c44b8">IS_EMPTY_BLOCK</a>(src2)) <span class="comment">// nothing to diff</span>
<a name="l03976"></a>03976     {
<a name="l03977"></a>03977         <span class="keywordflow">return</span> !<a class="code" href="a00120.html#gac6cfb9f92e4df6bb4c76f6efb2382860" title="Returns &amp;quot;true&amp;quot; if all bits in the block are 0.">bit_is_all_zero</a>((<a class="code" href="a00115.html#a7176bf7817550ca24cb6612bd8d7957d">bm::wordop_t</a>*)src1, (<a class="code" href="a00115.html#a7176bf7817550ca24cb6612bd8d7957d">bm::wordop_t</a>*)src1_end);
<a name="l03978"></a>03978     }
<a name="l03979"></a>03979     <span class="keywordflow">return</span> <a class="code" href="a00120.html#ga3f51735d2ca08e5a9fae2c9c49138c5c" title="Function SUBs two bitblocks and and tests for any bit. Function does not analyse...">bit_block_sub_any</a>(src1, src1_end, src2);
<a name="l03980"></a>03980 }
<a name="l03981"></a>03981 
<a name="l03982"></a>03982 
<a name="l03983"></a>03983 <span class="comment"></span>
<a name="l03984"></a>03984 <span class="comment">/*!</span>
<a name="l03985"></a>03985 <span class="comment">   \brief Performs bitblock OR operation and calculates bitcount of the result. </span>
<a name="l03986"></a>03986 <span class="comment"></span>
<a name="l03987"></a>03987 <span class="comment">   \param src1     - first bit block.</span>
<a name="l03988"></a>03988 <span class="comment">   \param src1_end - first bit block end</span>
<a name="l03989"></a>03989 <span class="comment">   \param src2     - second bit block.</span>
<a name="l03990"></a>03990 <span class="comment"></span>
<a name="l03991"></a>03991 <span class="comment">   \returns bitcount value </span>
<a name="l03992"></a>03992 <span class="comment"></span>
<a name="l03993"></a>03993 <span class="comment">   @ingroup bitfunc</span>
<a name="l03994"></a>03994 <span class="comment">*/</span>
<a name="l03995"></a>03995 <span class="keyword">inline</span> 
<a name="l03996"></a><a class="code" href="a00120.html#ga5a267aff3b56cc6dadf5a3a338e00a1d">03996</a> <a class="code" href="a00115.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a> <a class="code" href="a00120.html#ga5a267aff3b56cc6dadf5a3a338e00a1d" title="Performs bitblock OR operation and calculates bitcount of the result.">bit_operation_or_count</a>(<span class="keyword">const</span> <a class="code" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a>* BMRESTRICT src1,
<a name="l03997"></a>03997                                 <span class="keyword">const</span> <a class="code" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a>* BMRESTRICT src1_end, 
<a name="l03998"></a>03998                                 <span class="keyword">const</span> <a class="code" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a>* BMRESTRICT src2)
<a name="l03999"></a>03999 {
<a name="l04000"></a>04000     <span class="keywordflow">if</span> (<a class="code" href="a00092.html#accfe8650b3e8ee65da94f7712b3c44b8">IS_EMPTY_BLOCK</a>(src1))
<a name="l04001"></a>04001     {
<a name="l04002"></a>04002         <span class="keywordflow">if</span> (!<a class="code" href="a00092.html#accfe8650b3e8ee65da94f7712b3c44b8">IS_EMPTY_BLOCK</a>(src2))
<a name="l04003"></a>04003             <span class="keywordflow">return</span> <a class="code" href="a00120.html#gab30df14a61f036d690c091878feaff1c" title="Bitcount for bit string.">bit_block_calc_count</a>(src2, src2 + (src1_end - src1));
<a name="l04004"></a>04004         <span class="keywordflow">else</span>
<a name="l04005"></a>04005             <span class="keywordflow">return</span> 0; <span class="comment">// both blocks are empty        </span>
<a name="l04006"></a>04006     }
<a name="l04007"></a>04007     <span class="keywordflow">else</span>
<a name="l04008"></a>04008     {
<a name="l04009"></a>04009         <span class="keywordflow">if</span> (<a class="code" href="a00092.html#accfe8650b3e8ee65da94f7712b3c44b8">IS_EMPTY_BLOCK</a>(src2))
<a name="l04010"></a>04010             <span class="keywordflow">return</span> <a class="code" href="a00120.html#gab30df14a61f036d690c091878feaff1c" title="Bitcount for bit string.">bit_block_calc_count</a>(src1, src1_end);
<a name="l04011"></a>04011     }
<a name="l04012"></a>04012 
<a name="l04013"></a>04013     <span class="keywordflow">return</span> <a class="code" href="a00120.html#gacf4f8ab164277278448a541863c07517" title="Function ORs two bitblocks and computes the bitcount. Function does not analyse availability...">bit_block_or_count</a>(src1, src1_end, src2);
<a name="l04014"></a>04014 }
<a name="l04015"></a>04015 <span class="comment"></span>
<a name="l04016"></a>04016 <span class="comment">/*!</span>
<a name="l04017"></a>04017 <span class="comment">   \brief Performs bitblock OR operation test. </span>
<a name="l04018"></a>04018 <span class="comment"></span>
<a name="l04019"></a>04019 <span class="comment">   \param src1     - first bit block.</span>
<a name="l04020"></a>04020 <span class="comment">   \param src1_end - first bit block end</span>
<a name="l04021"></a>04021 <span class="comment">   \param src2     - second bit block.</span>
<a name="l04022"></a>04022 <span class="comment"></span>
<a name="l04023"></a>04023 <span class="comment">   \returns non zero value if there are any bits</span>
<a name="l04024"></a>04024 <span class="comment"></span>
<a name="l04025"></a>04025 <span class="comment">   @ingroup bitfunc</span>
<a name="l04026"></a>04026 <span class="comment">*/</span>
<a name="l04027"></a>04027 <span class="keyword">inline</span> 
<a name="l04028"></a><a class="code" href="a00120.html#ga6d26742bdc373074474a6932eab4f388">04028</a> <a class="code" href="a00115.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a> <a class="code" href="a00120.html#ga6d26742bdc373074474a6932eab4f388" title="Performs bitblock OR operation test.">bit_operation_or_any</a>(<span class="keyword">const</span> <a class="code" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a>* BMRESTRICT src1,
<a name="l04029"></a>04029                               <span class="keyword">const</span> <a class="code" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a>* BMRESTRICT src1_end, 
<a name="l04030"></a>04030                               <span class="keyword">const</span> <a class="code" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a>* BMRESTRICT src2)
<a name="l04031"></a>04031 {
<a name="l04032"></a>04032     <span class="keywordflow">if</span> (<a class="code" href="a00092.html#accfe8650b3e8ee65da94f7712b3c44b8">IS_EMPTY_BLOCK</a>(src1))
<a name="l04033"></a>04033     {
<a name="l04034"></a>04034         <span class="keywordflow">if</span> (!<a class="code" href="a00092.html#accfe8650b3e8ee65da94f7712b3c44b8">IS_EMPTY_BLOCK</a>(src2))
<a name="l04035"></a>04035             <span class="keywordflow">return</span> !<a class="code" href="a00120.html#gac6cfb9f92e4df6bb4c76f6efb2382860" title="Returns &amp;quot;true&amp;quot; if all bits in the block are 0.">bit_is_all_zero</a>((<a class="code" href="a00115.html#a7176bf7817550ca24cb6612bd8d7957d">bm::wordop_t</a>*)src2, 
<a name="l04036"></a>04036                                      (<a class="code" href="a00115.html#a7176bf7817550ca24cb6612bd8d7957d">bm::wordop_t</a>*)(src2 + (src1_end - src1)));
<a name="l04037"></a>04037         <span class="keywordflow">else</span>
<a name="l04038"></a>04038             <span class="keywordflow">return</span> 0; <span class="comment">// both blocks are empty        </span>
<a name="l04039"></a>04039     }
<a name="l04040"></a>04040     <span class="keywordflow">else</span>
<a name="l04041"></a>04041     {
<a name="l04042"></a>04042         <span class="keywordflow">if</span> (<a class="code" href="a00092.html#accfe8650b3e8ee65da94f7712b3c44b8">IS_EMPTY_BLOCK</a>(src2))
<a name="l04043"></a>04043             <span class="keywordflow">return</span> !<a class="code" href="a00120.html#gac6cfb9f92e4df6bb4c76f6efb2382860" title="Returns &amp;quot;true&amp;quot; if all bits in the block are 0.">bit_is_all_zero</a>((<a class="code" href="a00115.html#a7176bf7817550ca24cb6612bd8d7957d">bm::wordop_t</a>*)src1, (<a class="code" href="a00115.html#a7176bf7817550ca24cb6612bd8d7957d">bm::wordop_t</a>*)src1_end);
<a name="l04044"></a>04044     }
<a name="l04045"></a>04045 
<a name="l04046"></a>04046     <span class="keywordflow">return</span> <a class="code" href="a00120.html#gab2047495f7844d3014ff697503669d24" title="Function ORs two bitblocks and and tests for any bit. Function does not analyse availability...">bit_block_or_any</a>(src1, src1_end, src2);
<a name="l04047"></a>04047 }
<a name="l04048"></a>04048 
<a name="l04049"></a>04049 
<a name="l04050"></a>04050 <span class="comment"></span>
<a name="l04051"></a>04051 <span class="comment">/*!</span>
<a name="l04052"></a>04052 <span class="comment">   \brief Plain bitblock OR operation. </span>
<a name="l04053"></a>04053 <span class="comment">   Function does not analyse availability of source and destination blocks.</span>
<a name="l04054"></a>04054 <span class="comment"></span>
<a name="l04055"></a>04055 <span class="comment">   \param dst - destination block.</span>
<a name="l04056"></a>04056 <span class="comment">   \param src - source block.</span>
<a name="l04057"></a>04057 <span class="comment"></span>
<a name="l04058"></a>04058 <span class="comment">   @ingroup bitfunc</span>
<a name="l04059"></a>04059 <span class="comment">*/</span>
<a name="l04060"></a><a class="code" href="a00120.html#ga3515d8eb5da7f9d41d63dc90ad9523a4">04060</a> <span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="a00120.html#ga3515d8eb5da7f9d41d63dc90ad9523a4" title="Plain bitblock OR operation. Function does not analyse availability of source and...">bit_block_or</a>(<a class="code" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a>* BMRESTRICT dst, 
<a name="l04061"></a>04061                          <span class="keyword">const</span> <a class="code" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a>* BMRESTRICT src)
<a name="l04062"></a>04062 {
<a name="l04063"></a>04063 <span class="preprocessor">#ifdef BMVECTOPT</span>
<a name="l04064"></a>04064 <span class="preprocessor"></span>    <a class="code" href="a00098.html#ae3cdeec275429ea0d60668da63e96df8">VECT_OR_ARR</a>(dst, src, src + <a class="code" href="a00115.html#a91319dbc0d0e1bf3a3efc4d92bac7972">bm::set_block_size</a>);
<a name="l04065"></a>04065 <span class="preprocessor">#else</span>
<a name="l04066"></a>04066 <span class="preprocessor"></span>    <span class="keyword">const</span> <a class="code" href="a00115.html#a7176bf7817550ca24cb6612bd8d7957d">bm::wordop_t</a>* BMRESTRICT wrd_ptr = (<a class="code" href="a00115.html#a7176bf7817550ca24cb6612bd8d7957d">wordop_t</a>*)src;
<a name="l04067"></a>04067     <span class="keyword">const</span> <a class="code" href="a00115.html#a7176bf7817550ca24cb6612bd8d7957d">bm::wordop_t</a>* BMRESTRICT wrd_end = (<a class="code" href="a00115.html#a7176bf7817550ca24cb6612bd8d7957d">wordop_t</a>*)(src + <a class="code" href="a00115.html#a91319dbc0d0e1bf3a3efc4d92bac7972">set_block_size</a>);
<a name="l04068"></a>04068     <a class="code" href="a00115.html#a7176bf7817550ca24cb6612bd8d7957d">bm::wordop_t</a>* BMRESTRICT dst_ptr = (<a class="code" href="a00115.html#a7176bf7817550ca24cb6612bd8d7957d">wordop_t</a>*)dst;
<a name="l04069"></a>04069 
<a name="l04070"></a>04070     <span class="keywordflow">do</span>
<a name="l04071"></a>04071     {
<a name="l04072"></a>04072         dst_ptr[0] |= wrd_ptr[0];
<a name="l04073"></a>04073         dst_ptr[1] |= wrd_ptr[1];
<a name="l04074"></a>04074         dst_ptr[2] |= wrd_ptr[2];
<a name="l04075"></a>04075         dst_ptr[3] |= wrd_ptr[3];
<a name="l04076"></a>04076 
<a name="l04077"></a>04077         dst_ptr+=4;
<a name="l04078"></a>04078         wrd_ptr+=4;
<a name="l04079"></a>04079 
<a name="l04080"></a>04080     } <span class="keywordflow">while</span> (wrd_ptr &lt; wrd_end);
<a name="l04081"></a>04081 <span class="preprocessor">#endif</span>
<a name="l04082"></a>04082 <span class="preprocessor"></span>}
<a name="l04083"></a>04083 
<a name="l04084"></a>04084 <span class="comment"></span>
<a name="l04085"></a>04085 <span class="comment">/*!</span>
<a name="l04086"></a>04086 <span class="comment">   \brief Block OR operation. Makes analysis if block is 0 or FULL. </span>
<a name="l04087"></a>04087 <span class="comment"></span>
<a name="l04088"></a>04088 <span class="comment">   \param dst - destination block.</span>
<a name="l04089"></a>04089 <span class="comment">   \param src - source block.</span>
<a name="l04090"></a>04090 <span class="comment"></span>
<a name="l04091"></a>04091 <span class="comment">   \returns pointer on destination block. </span>
<a name="l04092"></a>04092 <span class="comment">    If returned value  equal to src means that block mutation requested. </span>
<a name="l04093"></a>04093 <span class="comment">    NULL is valid return value.</span>
<a name="l04094"></a>04094 <span class="comment"></span>
<a name="l04095"></a>04095 <span class="comment">   @ingroup bitfunc</span>
<a name="l04096"></a>04096 <span class="comment">*/</span>
<a name="l04097"></a>04097 <span class="keyword">inline</span> 
<a name="l04098"></a><a class="code" href="a00120.html#ga0e945a9eaae699ad40f63b3f0632e6f9">04098</a> <a class="code" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a>* <a class="code" href="a00120.html#ga0e945a9eaae699ad40f63b3f0632e6f9" title="Block OR operation. Makes analysis if block is 0 or FULL.">bit_operation_or</a>(<a class="code" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a>* BMRESTRICT dst, 
<a name="l04099"></a>04099                              <span class="keyword">const</span> <a class="code" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a>* BMRESTRICT src)
<a name="l04100"></a>04100 {
<a name="l04101"></a>04101     <a class="code" href="a00092.html#aa44515fab0ace8928d1cb82009a95bf8">BM_ASSERT</a>(dst || src);
<a name="l04102"></a>04102 
<a name="l04103"></a>04103     <a class="code" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a>* ret = dst;
<a name="l04104"></a>04104 
<a name="l04105"></a>04105     <span class="keywordflow">if</span> (<a class="code" href="a00092.html#a13ba598909515339ceede09e3b9b0198">IS_VALID_ADDR</a>(dst)) <span class="comment">// The destination block already exists</span>
<a name="l04106"></a>04106     {
<a name="l04107"></a>04107         <span class="keywordflow">if</span> (!<a class="code" href="a00092.html#a13ba598909515339ceede09e3b9b0198">IS_VALID_ADDR</a>(src))
<a name="l04108"></a>04108         {
<a name="l04109"></a>04109             <span class="keywordflow">if</span> (<a class="code" href="a00092.html#a074acb37afea68caaffe3832d326eb44">IS_FULL_BLOCK</a>(src))
<a name="l04110"></a>04110             {
<a name="l04111"></a>04111                 <span class="comment">// if the source block is all set </span>
<a name="l04112"></a>04112                 <span class="comment">// just set the destination block</span>
<a name="l04113"></a>04113                 ::memset(dst, 0xFF, <a class="code" href="a00115.html#a91319dbc0d0e1bf3a3efc4d92bac7972">bm::set_block_size</a> * <span class="keyword">sizeof</span>(<a class="code" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a>));
<a name="l04114"></a>04114             }
<a name="l04115"></a>04115         }
<a name="l04116"></a>04116         <span class="keywordflow">else</span>
<a name="l04117"></a>04117         {
<a name="l04118"></a>04118             <span class="comment">// Regular operation OR on the whole block</span>
<a name="l04119"></a>04119             <a class="code" href="a00120.html#ga3515d8eb5da7f9d41d63dc90ad9523a4" title="Plain bitblock OR operation. Function does not analyse availability of source and...">bit_block_or</a>(dst, src);
<a name="l04120"></a>04120         }
<a name="l04121"></a>04121     }
<a name="l04122"></a>04122     <span class="keywordflow">else</span> <span class="comment">// The destination block does not exist yet</span>
<a name="l04123"></a>04123     {
<a name="l04124"></a>04124         <span class="keywordflow">if</span> (!<a class="code" href="a00092.html#a13ba598909515339ceede09e3b9b0198">IS_VALID_ADDR</a>(src))
<a name="l04125"></a>04125         {
<a name="l04126"></a>04126             <span class="keywordflow">if</span> (<a class="code" href="a00092.html#a074acb37afea68caaffe3832d326eb44">IS_FULL_BLOCK</a>(src)) 
<a name="l04127"></a>04127             {
<a name="l04128"></a>04128                 <span class="comment">// The source block is all set, because dst does not exist</span>
<a name="l04129"></a>04129                 <span class="comment">// we can simply replace it.</span>
<a name="l04130"></a>04130                 <span class="keywordflow">return</span> <span class="keyword">const_cast&lt;</span><a class="code" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a>*<span class="keyword">&gt;</span>(<a class="code" href="a00092.html#a1365569f85f442c4914a3579f55df99b">FULL_BLOCK_ADDR</a>);
<a name="l04131"></a>04131             }
<a name="l04132"></a>04132         }
<a name="l04133"></a>04133         <span class="keywordflow">else</span>
<a name="l04134"></a>04134         {
<a name="l04135"></a>04135             <span class="keywordflow">if</span> (dst == 0)
<a name="l04136"></a>04136             {
<a name="l04137"></a>04137                 <span class="comment">// The only case when we have to allocate the new block:</span>
<a name="l04138"></a>04138                 <span class="comment">// Src is all zero and Dst does not exist</span>
<a name="l04139"></a>04139                 <span class="keywordflow">return</span> <span class="keyword">const_cast&lt;</span><a class="code" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a>*<span class="keyword">&gt;</span>(src);
<a name="l04140"></a>04140             }
<a name="l04141"></a>04141         }
<a name="l04142"></a>04142     }
<a name="l04143"></a>04143     <span class="keywordflow">return</span> ret;
<a name="l04144"></a>04144 }
<a name="l04145"></a>04145 <span class="comment"></span>
<a name="l04146"></a>04146 <span class="comment">/*!</span>
<a name="l04147"></a>04147 <span class="comment">   \brief Plain bitblock SUB (AND NOT) operation. </span>
<a name="l04148"></a>04148 <span class="comment">   Function does not analyse availability of source and destination blocks.</span>
<a name="l04149"></a>04149 <span class="comment"></span>
<a name="l04150"></a>04150 <span class="comment">   \param dst - destination block.</span>
<a name="l04151"></a>04151 <span class="comment">   \param src - source block.</span>
<a name="l04152"></a>04152 <span class="comment"></span>
<a name="l04153"></a>04153 <span class="comment">   @ingroup bitfunc</span>
<a name="l04154"></a>04154 <span class="comment">*/</span>
<a name="l04155"></a>04155 <span class="keyword">inline</span> 
<a name="l04156"></a><a class="code" href="a00120.html#gafed81435f74c0542857842d4461686e4">04156</a> <span class="keywordtype">void</span> <a class="code" href="a00120.html#gafed81435f74c0542857842d4461686e4" title="Plain bitblock SUB (AND NOT) operation. Function does not analyse availability of...">bit_block_sub</a>(<a class="code" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a>* BMRESTRICT dst, 
<a name="l04157"></a>04157                    <span class="keyword">const</span> <a class="code" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a>* BMRESTRICT src)
<a name="l04158"></a>04158 {
<a name="l04159"></a>04159 <span class="preprocessor">#ifdef BMVECTOPT</span>
<a name="l04160"></a>04160 <span class="preprocessor"></span>    <a class="code" href="a00098.html#af079345cbcb256bb6216c0446fd775f2">VECT_SUB_ARR</a>(dst, src, src + <a class="code" href="a00115.html#a91319dbc0d0e1bf3a3efc4d92bac7972">bm::set_block_size</a>);
<a name="l04161"></a>04161 <span class="preprocessor">#else</span>
<a name="l04162"></a>04162 <span class="preprocessor"></span>    <span class="keyword">const</span> <a class="code" href="a00115.html#a7176bf7817550ca24cb6612bd8d7957d">bm::wordop_t</a>* BMRESTRICT wrd_ptr = (<a class="code" href="a00115.html#a7176bf7817550ca24cb6612bd8d7957d">wordop_t</a>*) src;
<a name="l04163"></a>04163     <span class="keyword">const</span> <a class="code" href="a00115.html#a7176bf7817550ca24cb6612bd8d7957d">bm::wordop_t</a>* BMRESTRICT wrd_end = 
<a name="l04164"></a>04164                      (<a class="code" href="a00115.html#a7176bf7817550ca24cb6612bd8d7957d">wordop_t</a>*) (src + <a class="code" href="a00115.html#a91319dbc0d0e1bf3a3efc4d92bac7972">bm::set_block_size</a>);
<a name="l04165"></a>04165     <a class="code" href="a00115.html#a7176bf7817550ca24cb6612bd8d7957d">bm::wordop_t</a>* dst_ptr = (<a class="code" href="a00115.html#a7176bf7817550ca24cb6612bd8d7957d">wordop_t</a>*)dst;
<a name="l04166"></a>04166     
<a name="l04167"></a>04167     <span class="comment">// Regular operation AND-NOT on the whole block.</span>
<a name="l04168"></a>04168     <span class="keywordflow">do</span>
<a name="l04169"></a>04169     {
<a name="l04170"></a>04170         dst_ptr[0] &amp;= ~wrd_ptr[0];
<a name="l04171"></a>04171         dst_ptr[1] &amp;= ~wrd_ptr[1];
<a name="l04172"></a>04172         dst_ptr[2] &amp;= ~wrd_ptr[2];
<a name="l04173"></a>04173         dst_ptr[3] &amp;= ~wrd_ptr[3];
<a name="l04174"></a>04174 
<a name="l04175"></a>04175         dst_ptr+=4;
<a name="l04176"></a>04176         wrd_ptr+=4;
<a name="l04177"></a>04177     } <span class="keywordflow">while</span> (wrd_ptr &lt; wrd_end);
<a name="l04178"></a>04178 <span class="preprocessor">#endif</span>
<a name="l04179"></a>04179 <span class="preprocessor"></span>    
<a name="l04180"></a>04180 }
<a name="l04181"></a>04181 
<a name="l04182"></a>04182 <span class="comment"></span>
<a name="l04183"></a>04183 <span class="comment">/*!</span>
<a name="l04184"></a>04184 <span class="comment">   \brief bitblock SUB operation. </span>
<a name="l04185"></a>04185 <span class="comment"></span>
<a name="l04186"></a>04186 <span class="comment">   \param dst - destination block.</span>
<a name="l04187"></a>04187 <span class="comment">   \param src - source block.</span>
<a name="l04188"></a>04188 <span class="comment"></span>
<a name="l04189"></a>04189 <span class="comment">   \returns pointer on destination block. </span>
<a name="l04190"></a>04190 <span class="comment">    If returned value  equal to src means that block mutation requested. </span>
<a name="l04191"></a>04191 <span class="comment">    NULL is valid return value.</span>
<a name="l04192"></a>04192 <span class="comment"></span>
<a name="l04193"></a>04193 <span class="comment">   @ingroup bitfunc</span>
<a name="l04194"></a>04194 <span class="comment">*/</span>
<a name="l04195"></a>04195 <span class="keyword">inline</span> 
<a name="l04196"></a><a class="code" href="a00120.html#gad7afa9bce28a376360ca4826960d669f">04196</a> <a class="code" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a>* <a class="code" href="a00120.html#gad7afa9bce28a376360ca4826960d669f" title="bitblock SUB operation.">bit_operation_sub</a>(<a class="code" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a>* BMRESTRICT dst, 
<a name="l04197"></a>04197                               <span class="keyword">const</span> <a class="code" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a>* BMRESTRICT src)
<a name="l04198"></a>04198 {
<a name="l04199"></a>04199     <a class="code" href="a00092.html#aa44515fab0ace8928d1cb82009a95bf8">BM_ASSERT</a>(dst || src);
<a name="l04200"></a>04200 
<a name="l04201"></a>04201     <a class="code" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a>* ret = dst;
<a name="l04202"></a>04202     <span class="keywordflow">if</span> (<a class="code" href="a00092.html#a13ba598909515339ceede09e3b9b0198">IS_VALID_ADDR</a>(dst))  <span class="comment">//  The destination block already exists</span>
<a name="l04203"></a>04203     {
<a name="l04204"></a>04204         <span class="keywordflow">if</span> (!<a class="code" href="a00092.html#a13ba598909515339ceede09e3b9b0198">IS_VALID_ADDR</a>(src))
<a name="l04205"></a>04205         {
<a name="l04206"></a>04206             <span class="keywordflow">if</span> (<a class="code" href="a00092.html#a074acb37afea68caaffe3832d326eb44">IS_FULL_BLOCK</a>(src))
<a name="l04207"></a>04207             {
<a name="l04208"></a>04208                 <span class="comment">// If the source block is all set</span>
<a name="l04209"></a>04209                 <span class="comment">// just clean the destination block</span>
<a name="l04210"></a>04210                 <span class="keywordflow">return</span> 0;
<a name="l04211"></a>04211             }
<a name="l04212"></a>04212         }
<a name="l04213"></a>04213         <span class="keywordflow">else</span>
<a name="l04214"></a>04214         {
<a name="l04215"></a>04215             <a class="code" href="a00120.html#gafed81435f74c0542857842d4461686e4" title="Plain bitblock SUB (AND NOT) operation. Function does not analyse availability of...">bit_block_sub</a>(dst, src);
<a name="l04216"></a>04216         }
<a name="l04217"></a>04217     }
<a name="l04218"></a>04218     <span class="keywordflow">else</span> <span class="comment">// The destination block does not exist yet</span>
<a name="l04219"></a>04219     {
<a name="l04220"></a>04220         <span class="keywordflow">if</span> (!<a class="code" href="a00092.html#a13ba598909515339ceede09e3b9b0198">IS_VALID_ADDR</a>(src))
<a name="l04221"></a>04221         {
<a name="l04222"></a>04222             <span class="keywordflow">if</span> (<a class="code" href="a00092.html#a074acb37afea68caaffe3832d326eb44">IS_FULL_BLOCK</a>(src)) 
<a name="l04223"></a>04223             {
<a name="l04224"></a>04224                 <span class="comment">// The source block is full</span>
<a name="l04225"></a>04225                 <span class="keywordflow">return</span> 0;
<a name="l04226"></a>04226             }
<a name="l04227"></a>04227         }
<a name="l04228"></a>04228         <span class="keywordflow">else</span>
<a name="l04229"></a>04229         {
<a name="l04230"></a>04230             <span class="keywordflow">if</span> (<a class="code" href="a00092.html#a074acb37afea68caaffe3832d326eb44">IS_FULL_BLOCK</a>(dst))
<a name="l04231"></a>04231             {
<a name="l04232"></a>04232                 <span class="comment">// The only case when we have to allocate the new block:</span>
<a name="l04233"></a>04233                 <span class="comment">// dst is all set and src exists</span>
<a name="l04234"></a>04234                 <span class="keywordflow">return</span> <span class="keyword">const_cast&lt;</span><a class="code" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a>*<span class="keyword">&gt;</span>(src);                  
<a name="l04235"></a>04235             }
<a name="l04236"></a>04236         }
<a name="l04237"></a>04237     }
<a name="l04238"></a>04238     <span class="keywordflow">return</span> ret;
<a name="l04239"></a>04239 }
<a name="l04240"></a>04240 
<a name="l04241"></a>04241 <span class="comment"></span>
<a name="l04242"></a>04242 <span class="comment">/*!</span>
<a name="l04243"></a>04243 <span class="comment">   \brief Plain bitblock XOR operation. </span>
<a name="l04244"></a>04244 <span class="comment">   Function does not analyse availability of source and destination blocks.</span>
<a name="l04245"></a>04245 <span class="comment"></span>
<a name="l04246"></a>04246 <span class="comment">   \param dst - destination block.</span>
<a name="l04247"></a>04247 <span class="comment">   \param src - source block.</span>
<a name="l04248"></a>04248 <span class="comment"></span>
<a name="l04249"></a>04249 <span class="comment">   @ingroup bitfunc</span>
<a name="l04250"></a>04250 <span class="comment">*/</span>
<a name="l04251"></a>04251 <span class="keyword">inline</span> 
<a name="l04252"></a><a class="code" href="a00120.html#gae6a46c5e671ea1c9312219ceb41025ef">04252</a> <span class="keywordtype">void</span> <a class="code" href="a00120.html#gae6a46c5e671ea1c9312219ceb41025ef" title="Plain bitblock XOR operation. Function does not analyse availability of source and...">bit_block_xor</a>(<a class="code" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a>* BMRESTRICT dst, 
<a name="l04253"></a>04253                    <span class="keyword">const</span> <a class="code" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a>* BMRESTRICT src)
<a name="l04254"></a>04254 {
<a name="l04255"></a>04255 <span class="preprocessor">#ifdef BMVECTOPT</span>
<a name="l04256"></a>04256 <span class="preprocessor"></span>    <a class="code" href="a00098.html#a1f520ac49859f992de5c00f43b851179">VECT_XOR_ARR</a>(dst, src, src + <a class="code" href="a00115.html#a91319dbc0d0e1bf3a3efc4d92bac7972">bm::set_block_size</a>);
<a name="l04257"></a>04257 <span class="preprocessor">#else</span>
<a name="l04258"></a>04258 <span class="preprocessor"></span>    <span class="keyword">const</span> <a class="code" href="a00115.html#a7176bf7817550ca24cb6612bd8d7957d">bm::wordop_t</a>* BMRESTRICT wrd_ptr = (<a class="code" href="a00115.html#a7176bf7817550ca24cb6612bd8d7957d">wordop_t</a>*) src;
<a name="l04259"></a>04259     <span class="keyword">const</span> <a class="code" href="a00115.html#a7176bf7817550ca24cb6612bd8d7957d">bm::wordop_t</a>* BMRESTRICT wrd_end = 
<a name="l04260"></a>04260                             (<a class="code" href="a00115.html#a7176bf7817550ca24cb6612bd8d7957d">wordop_t</a>*) (src + <a class="code" href="a00115.html#a91319dbc0d0e1bf3a3efc4d92bac7972">bm::set_block_size</a>);
<a name="l04261"></a>04261     <a class="code" href="a00115.html#a7176bf7817550ca24cb6612bd8d7957d">bm::wordop_t</a>* BMRESTRICT dst_ptr = (<a class="code" href="a00115.html#a7176bf7817550ca24cb6612bd8d7957d">wordop_t</a>*)dst;
<a name="l04262"></a>04262 
<a name="l04263"></a>04263     <span class="comment">// Regular XOR operation on the whole block.</span>
<a name="l04264"></a>04264     <span class="keywordflow">do</span>
<a name="l04265"></a>04265     {
<a name="l04266"></a>04266         dst_ptr[0] ^= wrd_ptr[0];
<a name="l04267"></a>04267         dst_ptr[1] ^= wrd_ptr[1];
<a name="l04268"></a>04268         dst_ptr[2] ^= wrd_ptr[2];
<a name="l04269"></a>04269         dst_ptr[3] ^= wrd_ptr[3];
<a name="l04270"></a>04270 
<a name="l04271"></a>04271         dst_ptr+=4;
<a name="l04272"></a>04272         wrd_ptr+=4;
<a name="l04273"></a>04273     } <span class="keywordflow">while</span> (wrd_ptr &lt; wrd_end);
<a name="l04274"></a>04274 <span class="preprocessor">#endif</span>
<a name="l04275"></a>04275 <span class="preprocessor"></span>    
<a name="l04276"></a>04276 }
<a name="l04277"></a>04277 
<a name="l04278"></a>04278 <span class="comment"></span>
<a name="l04279"></a>04279 <span class="comment">/*!</span>
<a name="l04280"></a>04280 <span class="comment">   \brief bitblock XOR operation. </span>
<a name="l04281"></a>04281 <span class="comment"></span>
<a name="l04282"></a>04282 <span class="comment">   \param dst - destination block.</span>
<a name="l04283"></a>04283 <span class="comment">   \param src - source block.</span>
<a name="l04284"></a>04284 <span class="comment"></span>
<a name="l04285"></a>04285 <span class="comment">   \returns pointer on destination block. </span>
<a name="l04286"></a>04286 <span class="comment">    If returned value  equal to src means that block mutation requested. </span>
<a name="l04287"></a>04287 <span class="comment">    NULL is valid return value.</span>
<a name="l04288"></a>04288 <span class="comment"></span>
<a name="l04289"></a>04289 <span class="comment">   @ingroup bitfunc</span>
<a name="l04290"></a>04290 <span class="comment">*/</span>
<a name="l04291"></a>04291 <span class="keyword">inline</span> 
<a name="l04292"></a><a class="code" href="a00120.html#ga179de722e87ccf8189d975ca6beed025">04292</a> <a class="code" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a>* <a class="code" href="a00120.html#ga179de722e87ccf8189d975ca6beed025" title="bitblock XOR operation.">bit_operation_xor</a>(<a class="code" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a>* BMRESTRICT dst, 
<a name="l04293"></a>04293                               <span class="keyword">const</span> <a class="code" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a>* BMRESTRICT src)
<a name="l04294"></a>04294 {
<a name="l04295"></a>04295     <a class="code" href="a00092.html#aa44515fab0ace8928d1cb82009a95bf8">BM_ASSERT</a>(dst || src);
<a name="l04296"></a>04296     <span class="keywordflow">if</span> (src == dst) <span class="keywordflow">return</span> 0;  <span class="comment">// XOR rule  </span>
<a name="l04297"></a>04297 
<a name="l04298"></a>04298     <a class="code" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a>* ret = dst;
<a name="l04299"></a>04299 
<a name="l04300"></a>04300     <span class="keywordflow">if</span> (<a class="code" href="a00092.html#a13ba598909515339ceede09e3b9b0198">IS_VALID_ADDR</a>(dst))  <span class="comment">//  The destination block already exists</span>
<a name="l04301"></a>04301     {           
<a name="l04302"></a>04302         <span class="keywordflow">if</span> (!src) <span class="keywordflow">return</span> dst;
<a name="l04303"></a>04303         
<a name="l04304"></a>04304         <a class="code" href="a00120.html#gae6a46c5e671ea1c9312219ceb41025ef" title="Plain bitblock XOR operation. Function does not analyse availability of source and...">bit_block_xor</a>(dst, src);
<a name="l04305"></a>04305     }
<a name="l04306"></a>04306     <span class="keywordflow">else</span> <span class="comment">// The destination block does not exist yet</span>
<a name="l04307"></a>04307     {
<a name="l04308"></a>04308         <span class="keywordflow">if</span> (!src) <span class="keywordflow">return</span> dst;      <span class="comment">// 1 xor 0 = 1</span>
<a name="l04309"></a>04309 
<a name="l04310"></a>04310         <span class="comment">// Here we have two cases:</span>
<a name="l04311"></a>04311         <span class="comment">// if dest block is full or zero if zero we need to copy the source</span>
<a name="l04312"></a>04312         <span class="comment">// otherwise XOR loop against 0xFF...</span>
<a name="l04313"></a>04313         <span class="comment">//BM_ASSERT(dst == 0);</span>
<a name="l04314"></a>04314         <span class="keywordflow">return</span> <span class="keyword">const_cast&lt;</span><a class="code" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a>*<span class="keyword">&gt;</span>(src);  <span class="comment">// src is the final result               </span>
<a name="l04315"></a>04315     }
<a name="l04316"></a>04316     <span class="keywordflow">return</span> ret;
<a name="l04317"></a>04317 }
<a name="l04318"></a>04318 <span class="comment"></span>
<a name="l04319"></a>04319 <span class="comment">/*!</span>
<a name="l04320"></a>04320 <span class="comment">   \brief Performs bitblock XOR operation and calculates bitcount of the result. </span>
<a name="l04321"></a>04321 <span class="comment"></span>
<a name="l04322"></a>04322 <span class="comment">   \param src1 - first bit block.</span>
<a name="l04323"></a>04323 <span class="comment">   \param src2 - second bit block.</span>
<a name="l04324"></a>04324 <span class="comment"></span>
<a name="l04325"></a>04325 <span class="comment">   \returns bitcount value </span>
<a name="l04326"></a>04326 <span class="comment"></span>
<a name="l04327"></a>04327 <span class="comment">   @ingroup bitfunc</span>
<a name="l04328"></a>04328 <span class="comment">*/</span>
<a name="l04329"></a>04329 <span class="keyword">inline</span> 
<a name="l04330"></a><a class="code" href="a00120.html#gace08ab77feefb638daee164ee83118bc">04330</a> <a class="code" href="a00115.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a> <a class="code" href="a00120.html#gace08ab77feefb638daee164ee83118bc" title="Performs bitblock XOR operation and calculates bitcount of the result.">bit_operation_xor_count</a>(<span class="keyword">const</span> <a class="code" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a>* BMRESTRICT src1,
<a name="l04331"></a>04331                                  <span class="keyword">const</span> <a class="code" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a>* BMRESTRICT src1_end,
<a name="l04332"></a>04332                                  <span class="keyword">const</span> <a class="code" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a>* BMRESTRICT src2)
<a name="l04333"></a>04333 {
<a name="l04334"></a>04334     <span class="keywordflow">if</span> (<a class="code" href="a00092.html#accfe8650b3e8ee65da94f7712b3c44b8">IS_EMPTY_BLOCK</a>(src1) || <a class="code" href="a00092.html#accfe8650b3e8ee65da94f7712b3c44b8">IS_EMPTY_BLOCK</a>(src2))
<a name="l04335"></a>04335     {
<a name="l04336"></a>04336         <span class="keywordflow">if</span> (<a class="code" href="a00092.html#accfe8650b3e8ee65da94f7712b3c44b8">IS_EMPTY_BLOCK</a>(src1) &amp;&amp; <a class="code" href="a00092.html#accfe8650b3e8ee65da94f7712b3c44b8">IS_EMPTY_BLOCK</a>(src2))
<a name="l04337"></a>04337             <span class="keywordflow">return</span> 0;
<a name="l04338"></a>04338         <span class="keyword">const</span> <a class="code" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a>* block = <a class="code" href="a00092.html#accfe8650b3e8ee65da94f7712b3c44b8">IS_EMPTY_BLOCK</a>(src1) ? src2 : src1;
<a name="l04339"></a>04339         <span class="keywordflow">return</span> <a class="code" href="a00120.html#gab30df14a61f036d690c091878feaff1c" title="Bitcount for bit string.">bit_block_calc_count</a>(block, block + (src1_end - src1));
<a name="l04340"></a>04340     }
<a name="l04341"></a>04341     <span class="keywordflow">return</span> <a class="code" href="a00120.html#gaf8af8cfe8b49407be1af7398da28c939" title="Function XORs two bitblocks and computes the bitcount. Function does not analyse...">bit_block_xor_count</a>(src1, src1_end, src2);
<a name="l04342"></a>04342 }
<a name="l04343"></a>04343 <span class="comment"></span>
<a name="l04344"></a>04344 <span class="comment">/*!</span>
<a name="l04345"></a>04345 <span class="comment">   \brief Performs bitblock XOR operation test. </span>
<a name="l04346"></a>04346 <span class="comment"></span>
<a name="l04347"></a>04347 <span class="comment">   \param src1 - first bit block.</span>
<a name="l04348"></a>04348 <span class="comment">   \param src2 - second bit block.</span>
<a name="l04349"></a>04349 <span class="comment"></span>
<a name="l04350"></a>04350 <span class="comment">   \returns non zero value if there are bits</span>
<a name="l04351"></a>04351 <span class="comment"></span>
<a name="l04352"></a>04352 <span class="comment">   @ingroup bitfunc</span>
<a name="l04353"></a>04353 <span class="comment">*/</span>
<a name="l04354"></a>04354 <span class="keyword">inline</span> 
<a name="l04355"></a><a class="code" href="a00120.html#gaa86561b6d11c3f01dd772563c692f732">04355</a> <a class="code" href="a00115.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a> <a class="code" href="a00120.html#gaa86561b6d11c3f01dd772563c692f732" title="Performs bitblock XOR operation test.">bit_operation_xor_any</a>(<span class="keyword">const</span> <a class="code" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a>* BMRESTRICT src1,
<a name="l04356"></a>04356                                <span class="keyword">const</span> <a class="code" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a>* BMRESTRICT src1_end,
<a name="l04357"></a>04357                                <span class="keyword">const</span> <a class="code" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a>* BMRESTRICT src2)
<a name="l04358"></a>04358 {
<a name="l04359"></a>04359     <span class="keywordflow">if</span> (<a class="code" href="a00092.html#accfe8650b3e8ee65da94f7712b3c44b8">IS_EMPTY_BLOCK</a>(src1) || <a class="code" href="a00092.html#accfe8650b3e8ee65da94f7712b3c44b8">IS_EMPTY_BLOCK</a>(src2))
<a name="l04360"></a>04360     {
<a name="l04361"></a>04361         <span class="keywordflow">if</span> (<a class="code" href="a00092.html#accfe8650b3e8ee65da94f7712b3c44b8">IS_EMPTY_BLOCK</a>(src1) &amp;&amp; <a class="code" href="a00092.html#accfe8650b3e8ee65da94f7712b3c44b8">IS_EMPTY_BLOCK</a>(src2))
<a name="l04362"></a>04362             <span class="keywordflow">return</span> 0;
<a name="l04363"></a>04363         <span class="keyword">const</span> <a class="code" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a>* block = <a class="code" href="a00092.html#accfe8650b3e8ee65da94f7712b3c44b8">IS_EMPTY_BLOCK</a>(src1) ? src2 : src1;
<a name="l04364"></a>04364         <span class="keywordflow">return</span> !<a class="code" href="a00120.html#gac6cfb9f92e4df6bb4c76f6efb2382860" title="Returns &amp;quot;true&amp;quot; if all bits in the block are 0.">bit_is_all_zero</a>((<a class="code" href="a00115.html#a7176bf7817550ca24cb6612bd8d7957d">bm::wordop_t</a>*)block, 
<a name="l04365"></a>04365                                 (<a class="code" href="a00115.html#a7176bf7817550ca24cb6612bd8d7957d">bm::wordop_t</a>*)(block + (src1_end - src1)));
<a name="l04366"></a>04366     }
<a name="l04367"></a>04367     <span class="keywordflow">return</span> <a class="code" href="a00120.html#gafbc3ffafc859a503fdd2fc96e7fb60ce" title="Function XORs two bitblocks and and tests for any bit. Function does not analyse...">bit_block_xor_any</a>(src1, src1_end, src2);
<a name="l04368"></a>04368 }
<a name="l04369"></a>04369 
<a name="l04370"></a>04370 
<a name="l04371"></a>04371 <span class="comment"></span>
<a name="l04372"></a>04372 <span class="comment">/**</span>
<a name="l04373"></a>04373 <span class="comment">    \brief Inspects block for full zero words </span>
<a name="l04374"></a>04374 <span class="comment"></span>
<a name="l04375"></a>04375 <span class="comment">    \param data - bit block pointer</span>
<a name="l04376"></a>04376 <span class="comment">    \param data_size - data size</span>
<a name="l04377"></a>04377 <span class="comment"></span>
<a name="l04378"></a>04378 <span class="comment">    \return size of all non-zero words</span>
<a name="l04379"></a>04379 <span class="comment"></span>
<a name="l04380"></a>04380 <span class="comment">    @ingroup bitfunc</span>
<a name="l04381"></a>04381 <span class="comment">*/</span>
<a name="l04382"></a>04382 
<a name="l04383"></a>04383 <span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;
<a name="l04384"></a><a class="code" href="a00120.html#ga0ff158706f2e194be67fb8267641c30a">04384</a> <span class="keywordtype">unsigned</span> <a class="code" href="a00120.html#ga0ff158706f2e194be67fb8267641c30a" title="Inspects block for full zero words.">bit_count_nonzero_size</a>(<span class="keyword">const</span> T*     blk, 
<a name="l04385"></a>04385                                 <span class="keywordtype">unsigned</span>     data_size)
<a name="l04386"></a>04386 {
<a name="l04387"></a>04387     <a class="code" href="a00092.html#aa44515fab0ace8928d1cb82009a95bf8">BM_ASSERT</a>(blk &amp;&amp; data_size);
<a name="l04388"></a>04388     <span class="keywordtype">unsigned</span> count = 0;
<a name="l04389"></a>04389     <span class="keyword">const</span> T* blk_end = blk + data_size - 2;
<a name="l04390"></a>04390 
<a name="l04391"></a>04391     <span class="keywordflow">do</span>
<a name="l04392"></a>04392     {
<a name="l04393"></a>04393         <span class="keywordflow">if</span> (*blk == 0) 
<a name="l04394"></a>04394         {
<a name="l04395"></a>04395             <span class="comment">// scan fwd to find 0 island length</span>
<a name="l04396"></a>04396             <span class="keyword">const</span> T* blk_j = blk + 1;
<a name="l04397"></a>04397             <span class="keywordflow">for</span> (; blk_j &lt; blk_end; ++blk_j)
<a name="l04398"></a>04398             {
<a name="l04399"></a>04399                 <span class="keywordflow">if</span> (*blk_j != 0)
<a name="l04400"></a>04400                     <span class="keywordflow">break</span>;
<a name="l04401"></a>04401             }
<a name="l04402"></a>04402             blk = blk_j-1;
<a name="l04403"></a>04403             count += <span class="keyword">sizeof</span>(<a class="code" href="a00115.html#ac654d6319039a86546d235a236fc7cf6">gap_word_t</a>);
<a name="l04404"></a>04404         }
<a name="l04405"></a>04405         <span class="keywordflow">else</span>
<a name="l04406"></a>04406         {
<a name="l04407"></a>04407             <span class="comment">// scan fwd to find non-0 island length</span>
<a name="l04408"></a>04408             <span class="keyword">const</span> T* blk_j = blk + 1;
<a name="l04409"></a>04409             <span class="keywordflow">for</span> ( ; blk_j &lt; blk_end; ++blk_j)
<a name="l04410"></a>04410             {
<a name="l04411"></a>04411                 <span class="keywordflow">if</span> (*blk_j == 0)
<a name="l04412"></a>04412                 {
<a name="l04413"></a>04413                     <span class="comment">// look ahead to identify and ignore short 0-run</span>
<a name="l04414"></a>04414                     <span class="keywordflow">if</span> (blk_j[1] | blk_j[2])
<a name="l04415"></a>04415                     {
<a name="l04416"></a>04416                         <span class="comment">// skip zero word</span>
<a name="l04417"></a>04417                         ++blk_j;
<a name="l04418"></a>04418                         <span class="keywordflow">continue</span>;
<a name="l04419"></a>04419                     }
<a name="l04420"></a>04420                     <span class="keywordflow">break</span>;
<a name="l04421"></a>04421                 }
<a name="l04422"></a>04422             }
<a name="l04423"></a>04423             count += <span class="keyword">sizeof</span>(<a class="code" href="a00115.html#ac654d6319039a86546d235a236fc7cf6">gap_word_t</a>);
<a name="l04424"></a>04424             <span class="comment">// count all bit-words now</span>
<a name="l04425"></a>04425             count += (blk_j - blk) * <span class="keyword">sizeof</span>(T);
<a name="l04426"></a>04426             blk = blk_j;
<a name="l04427"></a>04427         }
<a name="l04428"></a>04428         ++blk;
<a name="l04429"></a>04429     }
<a name="l04430"></a>04430     <span class="keywordflow">while</span>(blk &lt; blk_end); 
<a name="l04431"></a>04431 
<a name="l04432"></a>04432     <span class="keywordflow">return</span> count + (2 * <span class="keyword">sizeof</span>(T));
<a name="l04433"></a>04433 }
<a name="l04434"></a>04434 
<a name="l04435"></a>04435 <span class="comment"></span>
<a name="l04436"></a>04436 <span class="comment">/**</span>
<a name="l04437"></a>04437 <span class="comment">    \brief Searches for the next 1 bit in the BIT block</span>
<a name="l04438"></a>04438 <span class="comment">    \param data - BIT buffer</span>
<a name="l04439"></a>04439 <span class="comment">    \param nbit - bit index to start checking from</span>
<a name="l04440"></a>04440 <span class="comment">    \param prev - returns previously checked value</span>
<a name="l04441"></a>04441 <span class="comment"></span>
<a name="l04442"></a>04442 <span class="comment">    @ingroup bitfunc</span>
<a name="l04443"></a>04443 <span class="comment">*/</span>
<a name="l04444"></a>04444 <span class="keyword">inline</span> 
<a name="l04445"></a><a class="code" href="a00120.html#gad6a7c549a625df7aa7d68d43a57238c7">04445</a> <span class="keywordtype">int</span> <a class="code" href="a00120.html#gad6a7c549a625df7aa7d68d43a57238c7" title="Searches for the next 1 bit in the BIT block.">bit_find_in_block</a>(<span class="keyword">const</span> <a class="code" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a>* data, 
<a name="l04446"></a>04446                       <span class="keywordtype">unsigned</span>          nbit, 
<a name="l04447"></a>04447                       <a class="code" href="a00115.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a>*         prev)
<a name="l04448"></a>04448 {
<a name="l04449"></a>04449     <span class="keyword">register</span> <a class="code" href="a00115.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a> p = *prev;
<a name="l04450"></a>04450     <span class="keywordtype">int</span> found = 0;
<a name="l04451"></a>04451 
<a name="l04452"></a>04452     <span class="keywordflow">for</span>(;;)
<a name="l04453"></a>04453     {
<a name="l04454"></a>04454         <span class="keywordtype">unsigned</span> nword  = nbit &gt;&gt; <a class="code" href="a00115.html#a83d76bccf6fe3770f32d5ba11d2a37ad">bm::set_word_shift</a>;
<a name="l04455"></a>04455         <span class="keywordflow">if</span> (nword &gt;= <a class="code" href="a00115.html#a91319dbc0d0e1bf3a3efc4d92bac7972">bm::set_block_size</a>) <span class="keywordflow">break</span>;
<a name="l04456"></a>04456 
<a name="l04457"></a>04457         <span class="keyword">register</span> <a class="code" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> val = data[nword] &gt;&gt; (p &amp; <a class="code" href="a00115.html#addbf345be3733d5e4575d71733ed1da8">bm::set_word_mask</a>);
<a name="l04458"></a>04458 
<a name="l04459"></a>04459         <span class="comment">// TODO: consider BSF and de bruijn sequences here:</span>
<a name="l04460"></a>04460         <span class="comment">// http://www.0xe3.com/text/ntz/ComputingTrailingZerosHOWTO.html#debruijn</span>
<a name="l04461"></a>04461 
<a name="l04462"></a>04462         <span class="keywordflow">if</span> (val)
<a name="l04463"></a>04463         {
<a name="l04464"></a>04464             <span class="keywordflow">while</span>((val &amp; 1) == 0)
<a name="l04465"></a>04465             {
<a name="l04466"></a>04466                 val &gt;&gt;= 1;
<a name="l04467"></a>04467                 ++nbit;
<a name="l04468"></a>04468                 ++p;
<a name="l04469"></a>04469             }
<a name="l04470"></a>04470             ++found;
<a name="l04471"></a>04471 
<a name="l04472"></a>04472             <span class="keywordflow">break</span>;
<a name="l04473"></a>04473         }
<a name="l04474"></a>04474         <span class="keywordflow">else</span>
<a name="l04475"></a>04475         {
<a name="l04476"></a>04476            p    += (<a class="code" href="a00115.html#addbf345be3733d5e4575d71733ed1da8">bm::set_word_mask</a> + 1) - (nbit &amp; <a class="code" href="a00115.html#addbf345be3733d5e4575d71733ed1da8">bm::set_word_mask</a>);
<a name="l04477"></a>04477            nbit += (bm::set_word_mask + 1) - (nbit &amp; bm::set_word_mask);
<a name="l04478"></a>04478         }
<a name="l04479"></a>04479     }
<a name="l04480"></a>04480     *prev = p;
<a name="l04481"></a>04481     <span class="keywordflow">return</span> found;
<a name="l04482"></a>04482 }
<a name="l04483"></a>04483 <span class="comment"></span>
<a name="l04484"></a>04484 <span class="comment">/*!</span>
<a name="l04485"></a>04485 <span class="comment">   \brief Templated algorithm to unpacks octet based word into list of ON bit indexes</span>
<a name="l04486"></a>04486 <span class="comment">   \param w - value</span>
<a name="l04487"></a>04487 <span class="comment">   \param func - bit functor </span>
<a name="l04488"></a>04488 <span class="comment"></span>
<a name="l04489"></a>04489 <span class="comment">   @ingroup bitfunc</span>
<a name="l04490"></a>04490 <span class="comment">*/</span>
<a name="l04491"></a>04491 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> F&gt; 
<a name="l04492"></a><a class="code" href="a00120.html#gab9f80b3c898323ce77beb915e4c861f3">04492</a> <span class="keywordtype">void</span> <a class="code" href="a00120.html#gab9f80b3c898323ce77beb915e4c861f3" title="Templated algorithm to unpacks octet based word into list of ON bit indexes.">bit_for_each_4</a>(T w, F&amp; func)
<a name="l04493"></a>04493 {
<a name="l04494"></a>04494     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> sub_octet = 0; w != 0; w &gt;&gt;= 4, sub_octet += 4)
<a name="l04495"></a>04495     {
<a name="l04496"></a>04496         <span class="keywordflow">switch</span> (w &amp; 15)
<a name="l04497"></a>04497         {
<a name="l04498"></a>04498         <span class="keywordflow">case</span> 0: <span class="comment">// 0000</span>
<a name="l04499"></a>04499             <span class="keywordflow">break</span>;
<a name="l04500"></a>04500         <span class="keywordflow">case</span> 1: <span class="comment">// 0001</span>
<a name="l04501"></a>04501             func(sub_octet);
<a name="l04502"></a>04502             <span class="keywordflow">break</span>;
<a name="l04503"></a>04503         <span class="keywordflow">case</span> 2: <span class="comment">// 0010</span>
<a name="l04504"></a>04504             func(sub_octet + 1);
<a name="l04505"></a>04505             <span class="keywordflow">break</span>;
<a name="l04506"></a>04506         <span class="keywordflow">case</span> 3: <span class="comment">// 0011</span>
<a name="l04507"></a>04507             func(sub_octet, sub_octet + 1);
<a name="l04508"></a>04508             <span class="keywordflow">break</span>;
<a name="l04509"></a>04509         <span class="keywordflow">case</span> 4: <span class="comment">// 0100</span>
<a name="l04510"></a>04510             func(sub_octet + 2);
<a name="l04511"></a>04511             <span class="keywordflow">break</span>;
<a name="l04512"></a>04512         <span class="keywordflow">case</span> 5: <span class="comment">// 0101</span>
<a name="l04513"></a>04513             func(sub_octet, sub_octet + 2);
<a name="l04514"></a>04514             <span class="keywordflow">break</span>;
<a name="l04515"></a>04515         <span class="keywordflow">case</span> 6: <span class="comment">// 0110</span>
<a name="l04516"></a>04516             func(sub_octet + 1, sub_octet + 2);
<a name="l04517"></a>04517             <span class="keywordflow">break</span>;
<a name="l04518"></a>04518         <span class="keywordflow">case</span> 7: <span class="comment">// 0111</span>
<a name="l04519"></a>04519             func(sub_octet, sub_octet + 1, sub_octet + 2);
<a name="l04520"></a>04520             <span class="keywordflow">break</span>;
<a name="l04521"></a>04521         <span class="keywordflow">case</span> 8: <span class="comment">// 1000</span>
<a name="l04522"></a>04522             func(sub_octet + 3);
<a name="l04523"></a>04523             <span class="keywordflow">break</span>;
<a name="l04524"></a>04524         <span class="keywordflow">case</span> 9: <span class="comment">// 1001</span>
<a name="l04525"></a>04525             func(sub_octet, sub_octet + 3);
<a name="l04526"></a>04526             <span class="keywordflow">break</span>;
<a name="l04527"></a>04527         <span class="keywordflow">case</span> 10: <span class="comment">// 1010</span>
<a name="l04528"></a>04528             func(sub_octet + 1, sub_octet + 3);
<a name="l04529"></a>04529             <span class="keywordflow">break</span>;
<a name="l04530"></a>04530         <span class="keywordflow">case</span> 11: <span class="comment">// 1011</span>
<a name="l04531"></a>04531             func(sub_octet, sub_octet + 1, sub_octet + 3);
<a name="l04532"></a>04532             <span class="keywordflow">break</span>;
<a name="l04533"></a>04533         <span class="keywordflow">case</span> 12: <span class="comment">// 1100</span>
<a name="l04534"></a>04534             func(sub_octet + 2, sub_octet + 3);
<a name="l04535"></a>04535             <span class="keywordflow">break</span>;
<a name="l04536"></a>04536         <span class="keywordflow">case</span> 13: <span class="comment">// 1101</span>
<a name="l04537"></a>04537             func(sub_octet, sub_octet + 2, sub_octet + 3);
<a name="l04538"></a>04538             <span class="keywordflow">break</span>;
<a name="l04539"></a>04539         <span class="keywordflow">case</span> 14: <span class="comment">// 1110</span>
<a name="l04540"></a>04540             func(sub_octet + 1, sub_octet + 2, sub_octet + 3);
<a name="l04541"></a>04541             <span class="keywordflow">break</span>;
<a name="l04542"></a>04542         <span class="keywordflow">case</span> 15: <span class="comment">// 1111</span>
<a name="l04543"></a>04543             func(sub_octet, sub_octet + 1, sub_octet + 2, sub_octet + 3);
<a name="l04544"></a>04544             <span class="keywordflow">break</span>;
<a name="l04545"></a>04545         <span class="keywordflow">default</span>:
<a name="l04546"></a>04546             <a class="code" href="a00092.html#aa44515fab0ace8928d1cb82009a95bf8">BM_ASSERT</a>(0);
<a name="l04547"></a>04547             <span class="keywordflow">break</span>;
<a name="l04548"></a>04548         }
<a name="l04549"></a>04549         
<a name="l04550"></a>04550     } <span class="comment">// for</span>
<a name="l04551"></a>04551 }
<a name="l04552"></a>04552 
<a name="l04553"></a>04553 <span class="comment"></span>
<a name="l04554"></a>04554 <span class="comment">/*!</span>
<a name="l04555"></a>04555 <span class="comment">   \brief Templated algorithm to unpacks word into list of ON bit indexes</span>
<a name="l04556"></a>04556 <span class="comment">   \param w - value</span>
<a name="l04557"></a>04557 <span class="comment">   \param func - bit functor </span>
<a name="l04558"></a>04558 <span class="comment"></span>
<a name="l04559"></a>04559 <span class="comment">   @ingroup bitfunc</span>
<a name="l04560"></a>04560 <span class="comment">*/</span>
<a name="l04561"></a>04561 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> F&gt; 
<a name="l04562"></a><a class="code" href="a00120.html#ga24be2ad5d8c2a8f18fdad142452aaae8">04562</a> <span class="keywordtype">void</span> <a class="code" href="a00120.html#ga24be2ad5d8c2a8f18fdad142452aaae8" title="Templated algorithm to unpacks word into list of ON bit indexes.">bit_for_each</a>(T w, F&amp; func)
<a name="l04563"></a>04563 {
<a name="l04564"></a>04564     <span class="comment">// Note: 4-bit table method works slower than plain check approach</span>
<a name="l04565"></a>04565     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> octet = 0; w != 0; w &gt;&gt;= 8, octet += 8)
<a name="l04566"></a>04566     {
<a name="l04567"></a>04567         <span class="keywordflow">if</span> (w &amp; 1)   func(octet + 0);
<a name="l04568"></a>04568         <span class="keywordflow">if</span> (w &amp; 2)   func(octet + 1);
<a name="l04569"></a>04569         <span class="keywordflow">if</span> (w &amp; 4)   func(octet + 2);
<a name="l04570"></a>04570         <span class="keywordflow">if</span> (w &amp; 8)   func(octet + 3);
<a name="l04571"></a>04571         <span class="keywordflow">if</span> (w &amp; 16)  func(octet + 4);
<a name="l04572"></a>04572         <span class="keywordflow">if</span> (w &amp; 32)  func(octet + 5);
<a name="l04573"></a>04573         <span class="keywordflow">if</span> (w &amp; 64)  func(octet + 6);
<a name="l04574"></a>04574         <span class="keywordflow">if</span> (w &amp; 128) func(octet + 7);
<a name="l04575"></a>04575         
<a name="l04576"></a>04576     } <span class="comment">// for</span>
<a name="l04577"></a>04577 }
<a name="l04578"></a>04578 <span class="comment"></span>
<a name="l04579"></a>04579 <span class="comment">/*! @brief Adaptor to copy 1 bits to array</span>
<a name="l04580"></a>04580 <span class="comment">    @internal</span>
<a name="l04581"></a>04581 <span class="comment">*/</span>
<a name="l04582"></a><a class="code" href="a00046.html">04582</a> <span class="keyword">template</span>&lt;<span class="keyword">typename</span> B&gt; <span class="keyword">class </span><a class="code" href="a00046.html" title="Adaptor to copy 1 bits to array.">copy_to_array_functor</a>
<a name="l04583"></a>04583 {
<a name="l04584"></a>04584 <span class="keyword">public</span>:
<a name="l04585"></a><a class="code" href="a00046.html#a1b1e4657ab4a7f79f1b9b69ece9c70d6">04585</a>     <a class="code" href="a00046.html#a1b1e4657ab4a7f79f1b9b69ece9c70d6">copy_to_array_functor</a>(B* bits): bp_(bits)
<a name="l04586"></a>04586     {}
<a name="l04587"></a>04587 
<a name="l04588"></a><a class="code" href="a00046.html#a688a369de329c57e8b28159a9c320a44">04588</a>     B* <a class="code" href="a00046.html#a688a369de329c57e8b28159a9c320a44">ptr</a>() { <span class="keywordflow">return</span> bp_; }
<a name="l04589"></a>04589     
<a name="l04590"></a><a class="code" href="a00046.html#ac6a8279c63d5479c7c20e2fad25eef71">04590</a>     <span class="keywordtype">void</span> <a class="code" href="a00046.html#ac6a8279c63d5479c7c20e2fad25eef71">operator()</a>(<span class="keywordtype">unsigned</span> bit_idx) { *bp_++ = (B)bit_idx; }
<a name="l04591"></a>04591     
<a name="l04592"></a><a class="code" href="a00046.html#a976500c6c53b3052aa4f55caaba84ca0">04592</a>     <span class="keywordtype">void</span> <a class="code" href="a00046.html#ac6a8279c63d5479c7c20e2fad25eef71">operator()</a>(<span class="keywordtype">unsigned</span> bit_idx0, 
<a name="l04593"></a>04593                     <span class="keywordtype">unsigned</span> bit_idx1) 
<a name="l04594"></a>04594     { 
<a name="l04595"></a>04595         bp_[0] = (B)bit_idx0; bp_[1] = (B)bit_idx1;
<a name="l04596"></a>04596         bp_+=2;
<a name="l04597"></a>04597     }
<a name="l04598"></a>04598     
<a name="l04599"></a><a class="code" href="a00046.html#a2fc00d634984ae2dc78060c2a23715be">04599</a>     <span class="keywordtype">void</span> <a class="code" href="a00046.html#ac6a8279c63d5479c7c20e2fad25eef71">operator()</a>(<span class="keywordtype">unsigned</span> bit_idx0, 
<a name="l04600"></a>04600                     <span class="keywordtype">unsigned</span> bit_idx1, 
<a name="l04601"></a>04601                     <span class="keywordtype">unsigned</span> bit_idx2) 
<a name="l04602"></a>04602     { 
<a name="l04603"></a>04603         bp_[0] = (B)bit_idx0; bp_[1] = (B)bit_idx1; bp_[2] = (B)bit_idx2;
<a name="l04604"></a>04604         bp_+=3;
<a name="l04605"></a>04605     }
<a name="l04606"></a>04606     
<a name="l04607"></a><a class="code" href="a00046.html#a9151cc8b0e9ad78c862e278d8fabe77e">04607</a>     <span class="keywordtype">void</span> <a class="code" href="a00046.html#ac6a8279c63d5479c7c20e2fad25eef71">operator()</a>(<span class="keywordtype">unsigned</span> bit_idx0, 
<a name="l04608"></a>04608                     <span class="keywordtype">unsigned</span> bit_idx1, 
<a name="l04609"></a>04609                     <span class="keywordtype">unsigned</span> bit_idx2, 
<a name="l04610"></a>04610                     <span class="keywordtype">unsigned</span> bit_idx3) 
<a name="l04611"></a>04611     { 
<a name="l04612"></a>04612         bp_[0] = (B)bit_idx0; bp_[1] = (B)bit_idx1;
<a name="l04613"></a>04613         bp_[2] = (B)bit_idx2; bp_[3] = (B)bit_idx3;
<a name="l04614"></a>04614         bp_+=4;
<a name="l04615"></a>04615     }
<a name="l04616"></a>04616 
<a name="l04617"></a>04617 <span class="keyword">private</span>:
<a name="l04618"></a>04618     <a class="code" href="a00046.html#a1b1e4657ab4a7f79f1b9b69ece9c70d6">copy_to_array_functor</a>(<span class="keyword">const</span> <a class="code" href="a00046.html" title="Adaptor to copy 1 bits to array.">copy_to_array_functor</a>&amp;);
<a name="l04619"></a>04619     <a class="code" href="a00046.html" title="Adaptor to copy 1 bits to array.">copy_to_array_functor</a>&amp; operator=(<span class="keyword">const</span> <a class="code" href="a00046.html" title="Adaptor to copy 1 bits to array.">copy_to_array_functor</a>&amp;);
<a name="l04620"></a>04620 <span class="keyword">private</span>:
<a name="l04621"></a>04621     B* bp_;
<a name="l04622"></a>04622 };
<a name="l04623"></a>04623 <span class="comment"></span>
<a name="l04624"></a>04624 <span class="comment">/*! @brief Adaptor to copy 1 bits to array with base increment</span>
<a name="l04625"></a>04625 <span class="comment">    @internal</span>
<a name="l04626"></a>04626 <span class="comment">*/</span>
<a name="l04627"></a><a class="code" href="a00047.html">04627</a> <span class="keyword">template</span>&lt;<span class="keyword">typename</span> B&gt; <span class="keyword">class </span><a class="code" href="a00047.html" title="Adaptor to copy 1 bits to array with base increment.">copy_to_array_functor_inc</a>
<a name="l04628"></a>04628 {
<a name="l04629"></a>04629 <span class="keyword">public</span>:
<a name="l04630"></a><a class="code" href="a00047.html#a9930456419a8b21419e0b88fea3d6cb6">04630</a>     <a class="code" href="a00047.html#a9930456419a8b21419e0b88fea3d6cb6">copy_to_array_functor_inc</a>(B* bits, <span class="keywordtype">unsigned</span> base_idx)
<a name="l04631"></a>04631     : bp_(bits), base_idx_(base_idx)
<a name="l04632"></a>04632     {}
<a name="l04633"></a>04633 
<a name="l04634"></a><a class="code" href="a00047.html#ab20935891fa37c6ea1ef8d03605f8669">04634</a>     B* <a class="code" href="a00047.html#ab20935891fa37c6ea1ef8d03605f8669">ptr</a>() { <span class="keywordflow">return</span> bp_; }
<a name="l04635"></a>04635     
<a name="l04636"></a><a class="code" href="a00047.html#a4b086ea3170907e2aabe0b10fd2ea18e">04636</a>     <span class="keywordtype">void</span> <a class="code" href="a00047.html#a4b086ea3170907e2aabe0b10fd2ea18e">operator()</a>(<span class="keywordtype">unsigned</span> bit_idx) 
<a name="l04637"></a>04637     { 
<a name="l04638"></a>04638         *bp_++ = (B)(bit_idx + base_idx_);
<a name="l04639"></a>04639     }
<a name="l04640"></a>04640 
<a name="l04641"></a>04641     
<a name="l04642"></a><a class="code" href="a00047.html#a0432c95dcde2c9b4276fd899c1328041">04642</a>     <span class="keywordtype">void</span> <a class="code" href="a00047.html#a4b086ea3170907e2aabe0b10fd2ea18e">operator()</a>(<span class="keywordtype">unsigned</span> bit_idx0, 
<a name="l04643"></a>04643                     <span class="keywordtype">unsigned</span> bit_idx1) 
<a name="l04644"></a>04644     { 
<a name="l04645"></a>04645         bp_[0]=(B)(bit_idx0+base_idx_);bp_[1]=(B)(bit_idx1+base_idx_);
<a name="l04646"></a>04646         bp_+=2;
<a name="l04647"></a>04647     }
<a name="l04648"></a>04648     
<a name="l04649"></a><a class="code" href="a00047.html#a741eaf29a5506c4f13b058b1016bdb03">04649</a>     <span class="keywordtype">void</span> <a class="code" href="a00047.html#a4b086ea3170907e2aabe0b10fd2ea18e">operator()</a>(<span class="keywordtype">unsigned</span> bit_idx0, 
<a name="l04650"></a>04650                     <span class="keywordtype">unsigned</span> bit_idx1, 
<a name="l04651"></a>04651                     <span class="keywordtype">unsigned</span> bit_idx2) 
<a name="l04652"></a>04652     { 
<a name="l04653"></a>04653         bp_[0]=(B)(bit_idx0+base_idx_);bp_[1]=(B)(bit_idx1+base_idx_);
<a name="l04654"></a>04654         bp_[2]=(B)(bit_idx2+base_idx_);
<a name="l04655"></a>04655         bp_+=3;
<a name="l04656"></a>04656     }
<a name="l04657"></a>04657     
<a name="l04658"></a><a class="code" href="a00047.html#a5f0586e43184f50fa22b5249303d286d">04658</a>     <span class="keywordtype">void</span> <a class="code" href="a00047.html#a4b086ea3170907e2aabe0b10fd2ea18e">operator()</a>(<span class="keywordtype">unsigned</span> bit_idx0, 
<a name="l04659"></a>04659                     <span class="keywordtype">unsigned</span> bit_idx1, 
<a name="l04660"></a>04660                     <span class="keywordtype">unsigned</span> bit_idx2, 
<a name="l04661"></a>04661                     <span class="keywordtype">unsigned</span> bit_idx3) 
<a name="l04662"></a>04662     { 
<a name="l04663"></a>04663         bp_[0]=(B)(bit_idx0+base_idx_);bp_[1]=(B)(bit_idx1+base_idx_);
<a name="l04664"></a>04664         bp_[2]=(B)(bit_idx2+base_idx_);bp_[3]=(B)(bit_idx3+base_idx_);
<a name="l04665"></a>04665         bp_+=4;
<a name="l04666"></a>04666     }
<a name="l04667"></a>04667 
<a name="l04668"></a>04668 <span class="keyword">private</span>:
<a name="l04669"></a>04669     <a class="code" href="a00047.html#a9930456419a8b21419e0b88fea3d6cb6">copy_to_array_functor_inc</a>(<span class="keyword">const</span> <a class="code" href="a00047.html" title="Adaptor to copy 1 bits to array with base increment.">copy_to_array_functor_inc</a>&amp;);
<a name="l04670"></a>04670     <a class="code" href="a00047.html" title="Adaptor to copy 1 bits to array with base increment.">copy_to_array_functor_inc</a>&amp; operator=(<span class="keyword">const</span> <a class="code" href="a00047.html" title="Adaptor to copy 1 bits to array with base increment.">copy_to_array_functor_inc</a>&amp;);
<a name="l04671"></a>04671 <span class="keyword">private</span>:
<a name="l04672"></a>04672     B*        bp_;
<a name="l04673"></a>04673     <span class="keywordtype">unsigned</span>  base_idx_; <span class="comment">///&lt; Base increment factor</span>
<a name="l04674"></a>04674 <span class="comment"></span>};
<a name="l04675"></a>04675 
<a name="l04676"></a>04676 <span class="comment"></span>
<a name="l04677"></a>04677 <span class="comment">/*!</span>
<a name="l04678"></a>04678 <span class="comment">   \brief Unpacks word into list of ON bit indexes (quad-bit based)</span>
<a name="l04679"></a>04679 <span class="comment">   \param w - value</span>
<a name="l04680"></a>04680 <span class="comment">   \param bits - pointer on the result array </span>
<a name="l04681"></a>04681 <span class="comment">   \return number of bits in the list</span>
<a name="l04682"></a>04682 <span class="comment"></span>
<a name="l04683"></a>04683 <span class="comment">   @ingroup bitfunc</span>
<a name="l04684"></a>04684 <span class="comment">*/</span>
<a name="l04685"></a><a class="code" href="a00120.html#ga3c81f6bff8866ec3ed0a94903eee96b7">04685</a> <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span> B&gt; <span class="keywordtype">unsigned</span> <a class="code" href="a00120.html#ga3c81f6bff8866ec3ed0a94903eee96b7" title="Unpacks word into list of ON bit indexes (quad-bit based).">bit_list_4</a>(T w, B* bits)
<a name="l04686"></a>04686 {
<a name="l04687"></a>04687     <a class="code" href="a00046.html" title="Adaptor to copy 1 bits to array.">copy_to_array_functor&lt;B&gt;</a> func(bits);
<a name="l04688"></a>04688     <a class="code" href="a00120.html#gab9f80b3c898323ce77beb915e4c861f3" title="Templated algorithm to unpacks octet based word into list of ON bit indexes.">bit_for_each_4</a>(w, func);
<a name="l04689"></a>04689     <span class="keywordflow">return</span> (<span class="keywordtype">unsigned</span>)(func.<a class="code" href="a00046.html#a688a369de329c57e8b28159a9c320a44">ptr</a>() - bits);
<a name="l04690"></a>04690 }
<a name="l04691"></a>04691 <span class="comment"></span>
<a name="l04692"></a>04692 <span class="comment">/*!</span>
<a name="l04693"></a>04693 <span class="comment">   \brief Unpacks word into list of ON bit indexes</span>
<a name="l04694"></a>04694 <span class="comment">   \param w - value</span>
<a name="l04695"></a>04695 <span class="comment">   \param bits - pointer on the result array </span>
<a name="l04696"></a>04696 <span class="comment">   \return number of bits in the list</span>
<a name="l04697"></a>04697 <span class="comment"></span>
<a name="l04698"></a>04698 <span class="comment">   @ingroup bitfunc</span>
<a name="l04699"></a>04699 <span class="comment">*/</span>
<a name="l04700"></a><a class="code" href="a00120.html#gaae3ae537760044543f842363e4614e82">04700</a> <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span> B&gt; <span class="keywordtype">unsigned</span> <a class="code" href="a00120.html#gaae3ae537760044543f842363e4614e82" title="Unpacks word into list of ON bit indexes.">bit_list</a>(T w, B* bits)
<a name="l04701"></a>04701 {
<a name="l04702"></a>04702     <a class="code" href="a00046.html" title="Adaptor to copy 1 bits to array.">copy_to_array_functor&lt;B&gt;</a> func(bits);
<a name="l04703"></a>04703     <a class="code" href="a00120.html#ga24be2ad5d8c2a8f18fdad142452aaae8" title="Templated algorithm to unpacks word into list of ON bit indexes.">bit_for_each</a>(w, func);
<a name="l04704"></a>04704     <span class="keywordflow">return</span> (<span class="keywordtype">unsigned</span>)(func.<a class="code" href="a00046.html#a688a369de329c57e8b28159a9c320a44">ptr</a>() - bits);
<a name="l04705"></a>04705 }
<a name="l04706"></a>04706 
<a name="l04707"></a>04707 <span class="comment"></span>
<a name="l04708"></a>04708 <span class="comment">/*!</span>
<a name="l04709"></a>04709 <span class="comment">    @brief Choose best representation for a bit-block</span>
<a name="l04710"></a>04710 <span class="comment">    @ingroup bitfunc </span>
<a name="l04711"></a>04711 <span class="comment">*/</span>
<a name="l04712"></a>04712 <span class="keyword">inline</span>
<a name="l04713"></a><a class="code" href="a00120.html#ga20610fae6b0de84957b74ed17429667f">04713</a> <a class="code" href="a00115.html#a593916a103395805070a3200720c6416" title="set representation variants">bm::set_representation</a> <a class="code" href="a00120.html#ga20610fae6b0de84957b74ed17429667f" title="Choose best representation for a bit-block.">best_representation</a>(<span class="keywordtype">unsigned</span> bit_count,
<a name="l04714"></a>04714                                            <span class="keywordtype">unsigned</span> total_possible_bitcount,
<a name="l04715"></a>04715                                            <span class="keywordtype">unsigned</span> gap_count,
<a name="l04716"></a>04716                                            <span class="keywordtype">unsigned</span> block_size)
<a name="l04717"></a>04717 {
<a name="l04718"></a>04718     <span class="keywordtype">unsigned</span> arr_size = <span class="keyword">sizeof</span>(<a class="code" href="a00115.html#ac654d6319039a86546d235a236fc7cf6">bm::gap_word_t</a>) * bit_count + <span class="keyword">sizeof</span>(<a class="code" href="a00115.html#ac654d6319039a86546d235a236fc7cf6">bm::gap_word_t</a>);
<a name="l04719"></a>04719     <span class="keywordtype">unsigned</span> gap_size = <span class="keyword">sizeof</span>(<a class="code" href="a00115.html#ac654d6319039a86546d235a236fc7cf6">bm::gap_word_t</a>) * gap_count + <span class="keyword">sizeof</span>(<a class="code" href="a00115.html#ac654d6319039a86546d235a236fc7cf6">bm::gap_word_t</a>);
<a name="l04720"></a>04720     <span class="keywordtype">unsigned</span> inv_arr_size = <span class="keyword">sizeof</span>(<a class="code" href="a00115.html#ac654d6319039a86546d235a236fc7cf6">bm::gap_word_t</a>) * (total_possible_bitcount - bit_count) + <span class="keyword">sizeof</span>(<a class="code" href="a00115.html#ac654d6319039a86546d235a236fc7cf6">bm::gap_word_t</a>);
<a name="l04721"></a>04721 
<a name="l04722"></a>04722     <span class="keywordflow">if</span> ((gap_size &lt; block_size) &amp;&amp; (gap_size &lt; arr_size) &amp;&amp; (gap_size &lt; inv_arr_size))
<a name="l04723"></a>04723     {
<a name="l04724"></a>04724         <span class="keywordflow">return</span> <a class="code" href="a00115.html#a593916a103395805070a3200720c6416a4809f1871df2ba431e5b70d175f050ec" title="GAP-RLE compression.">bm::set_gap</a>;
<a name="l04725"></a>04725     }
<a name="l04726"></a>04726 
<a name="l04727"></a>04727     <span class="keywordflow">if</span> (arr_size &lt; inv_arr_size)
<a name="l04728"></a>04728     {
<a name="l04729"></a>04729         <span class="keywordflow">if</span> ((arr_size &lt; block_size) &amp;&amp; (arr_size &lt; gap_size))
<a name="l04730"></a>04730         {
<a name="l04731"></a>04731             <span class="keywordflow">return</span> <a class="code" href="a00115.html#a593916a103395805070a3200720c6416a4bd710c312645ed34e4db359a7e59c42" title="array of set 1 values">bm::set_array1</a>;
<a name="l04732"></a>04732         }
<a name="l04733"></a>04733     }
<a name="l04734"></a>04734     <span class="keywordflow">else</span>
<a name="l04735"></a>04735     {
<a name="l04736"></a>04736         <span class="keywordflow">if</span> ((inv_arr_size &lt; block_size) &amp;&amp; (inv_arr_size &lt; gap_size))
<a name="l04737"></a>04737         {
<a name="l04738"></a>04738             <span class="keywordflow">return</span> <a class="code" href="a00115.html#a593916a103395805070a3200720c6416a8d71ac8a4f70b88d2a425d0c1e872fa2" title="array of 0 values">bm::set_array0</a>;
<a name="l04739"></a>04739         }
<a name="l04740"></a>04740     }
<a name="l04741"></a>04741     <span class="keywordflow">return</span> <a class="code" href="a00115.html#a593916a103395805070a3200720c6416a11f970b705c57a0572043e5cc5e2e333" title="Simple bitset.">bm::set_bitset</a>;
<a name="l04742"></a>04742 }
<a name="l04743"></a>04743 <span class="comment"></span>
<a name="l04744"></a>04744 <span class="comment">/*!</span>
<a name="l04745"></a>04745 <span class="comment">    @brief Convert bit block into an array of ints corresponding to 1 bits</span>
<a name="l04746"></a>04746 <span class="comment">    @ingroup bitfunc </span>
<a name="l04747"></a>04747 <span class="comment">*/</span>
<a name="l04748"></a><a class="code" href="a00120.html#gaf24d85761f60877c2260f8160593f732">04748</a> <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; T <a class="code" href="a00120.html#gaf24d85761f60877c2260f8160593f732" title="Convert bit block into an array of ints corresponding to 1 bits.">bit_convert_to_arr</a>(T* BMRESTRICT dest, 
<a name="l04749"></a>04749                                           <span class="keyword">const</span> <span class="keywordtype">unsigned</span>* BMRESTRICT src, 
<a name="l04750"></a>04750                                           <a class="code" href="a00115.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a> bits, 
<a name="l04751"></a>04751                                           <span class="keywordtype">unsigned</span> dest_len,
<a name="l04752"></a>04752                                           <span class="keywordtype">unsigned</span> mask = 0)
<a name="l04753"></a>04753 {
<a name="l04754"></a>04754     T* BMRESTRICT pcurr = dest;
<a name="l04755"></a>04755     <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> bit_idx=0; bit_idx &lt; bits; ++src,bit_idx += <span class="keyword">sizeof</span>(*src) * 8)
<a name="l04756"></a>04756     {
<a name="l04757"></a>04757         <span class="keywordtype">unsigned</span> val = *src ^ mask; <span class="comment">// possible to invert value by XOR 0xFF..</span>
<a name="l04758"></a>04758         <span class="keywordflow">if</span> (val == 0) 
<a name="l04759"></a>04759         {
<a name="l04760"></a>04760             <span class="keywordflow">continue</span>;
<a name="l04761"></a>04761         }
<a name="l04762"></a>04762         <span class="keywordflow">if</span> (pcurr + <span class="keyword">sizeof</span>(val)*8 &gt;= dest + dest_len) <span class="comment">// insufficient space</span>
<a name="l04763"></a>04763         {
<a name="l04764"></a>04764             <span class="keywordflow">return</span> 0;
<a name="l04765"></a>04765         }
<a name="l04766"></a>04766 
<a name="l04767"></a>04767         <a class="code" href="a00047.html" title="Adaptor to copy 1 bits to array with base increment.">copy_to_array_functor_inc&lt;T&gt;</a> func(pcurr, bit_idx);
<a name="l04768"></a>04768         <a class="code" href="a00120.html#gab9f80b3c898323ce77beb915e4c861f3" title="Templated algorithm to unpacks octet based word into list of ON bit indexes.">bit_for_each_4</a>(val, func);      
<a name="l04769"></a>04769         <span class="keywordtype">unsigned</span> word_bit_cnt = func.<a class="code" href="a00047.html#ab20935891fa37c6ea1ef8d03605f8669">ptr</a>() - pcurr;
<a name="l04770"></a>04770         pcurr += word_bit_cnt;    
<a name="l04771"></a>04771 
<a name="l04772"></a>04772     } <span class="comment">// for</span>
<a name="l04773"></a>04773     <span class="keywordflow">return</span> (T)(pcurr - dest);
<a name="l04774"></a>04774 }
<a name="l04775"></a>04775 
<a name="l04776"></a>04776 
<a name="l04777"></a>04777 
<a name="l04778"></a>04778 <span class="comment"></span>
<a name="l04779"></a>04779 <span class="comment">/*!</span>
<a name="l04780"></a>04780 <span class="comment">    OBSOLETE function</span>
<a name="l04781"></a>04781 <span class="comment">    \brief Convert bit block into an array of ints corresponding to 1 bits</span>
<a name="l04782"></a>04782 <span class="comment">    \internal</span>
<a name="l04783"></a>04783 <span class="comment">    @ingroup bitfunc </span>
<a name="l04784"></a>04784 <span class="comment">*/</span>
<a name="l04785"></a>04785 <span class="comment">/*</span>
<a name="l04786"></a>04786 <span class="comment">template&lt;typename T&gt; T bit_convert_to_arr2(T* BMRESTRICT dest, </span>
<a name="l04787"></a>04787 <span class="comment">                                          const unsigned* BMRESTRICT src, </span>
<a name="l04788"></a>04788 <span class="comment">                                          bm::id_t bits, </span>
<a name="l04789"></a>04789 <span class="comment">                                          unsigned dest_len)</span>
<a name="l04790"></a>04790 <span class="comment">{</span>
<a name="l04791"></a>04791 <span class="comment">    register T* BMRESTRICT pcurr = dest;</span>
<a name="l04792"></a>04792 <span class="comment">    T* BMRESTRICT end = dest + dest_len; </span>
<a name="l04793"></a>04793 <span class="comment">    unsigned  bit_idx = 0;</span>
<a name="l04794"></a>04794 <span class="comment"></span>
<a name="l04795"></a>04795 <span class="comment">    do</span>
<a name="l04796"></a>04796 <span class="comment">    {</span>
<a name="l04797"></a>04797 <span class="comment">        register unsigned val = *src;</span>
<a name="l04798"></a>04798 <span class="comment">        // We can skip if *src == 0 </span>
<a name="l04799"></a>04799 <span class="comment"></span>
<a name="l04800"></a>04800 <span class="comment">        while (val == 0)</span>
<a name="l04801"></a>04801 <span class="comment">        {</span>
<a name="l04802"></a>04802 <span class="comment">            bit_idx += sizeof(*src) * 8;</span>
<a name="l04803"></a>04803 <span class="comment">            if (bit_idx &gt;= bits)</span>
<a name="l04804"></a>04804 <span class="comment">            {</span>
<a name="l04805"></a>04805 <span class="comment">               return (T)(pcurr - dest);</span>
<a name="l04806"></a>04806 <span class="comment">            }</span>
<a name="l04807"></a>04807 <span class="comment">            val = *(++src);</span>
<a name="l04808"></a>04808 <span class="comment">        }</span>
<a name="l04809"></a>04809 <span class="comment"></span>
<a name="l04810"></a>04810 <span class="comment">        if (pcurr + sizeof(val)*8 &gt; end) // insufficient space</span>
<a name="l04811"></a>04811 <span class="comment">        {</span>
<a name="l04812"></a>04812 <span class="comment">            return 0;</span>
<a name="l04813"></a>04813 <span class="comment">        }</span>
<a name="l04814"></a>04814 <span class="comment">                </span>
<a name="l04815"></a>04815 <span class="comment">        for (int i = 0; i &lt; 32; i+=4)</span>
<a name="l04816"></a>04816 <span class="comment">        {</span>
<a name="l04817"></a>04817 <span class="comment">            if (val &amp; 1)</span>
<a name="l04818"></a>04818 <span class="comment">                *pcurr++ = bit_idx;</span>
<a name="l04819"></a>04819 <span class="comment">            val &gt;&gt;= 1; ++bit_idx;</span>
<a name="l04820"></a>04820 <span class="comment">            if (val &amp; 1)</span>
<a name="l04821"></a>04821 <span class="comment">                *pcurr++ = bit_idx;</span>
<a name="l04822"></a>04822 <span class="comment">            val &gt;&gt;= 1; ++bit_idx;</span>
<a name="l04823"></a>04823 <span class="comment">            if (val &amp; 1)</span>
<a name="l04824"></a>04824 <span class="comment">                *pcurr++ = bit_idx;</span>
<a name="l04825"></a>04825 <span class="comment">            val &gt;&gt;= 1; ++bit_idx;</span>
<a name="l04826"></a>04826 <span class="comment">            if (val &amp; 1)</span>
<a name="l04827"></a>04827 <span class="comment">                *pcurr++ = bit_idx;</span>
<a name="l04828"></a>04828 <span class="comment">            val &gt;&gt;= 1; ++bit_idx;</span>
<a name="l04829"></a>04829 <span class="comment">        }</span>
<a name="l04830"></a>04830 <span class="comment">        </span>
<a name="l04831"></a>04831 <span class="comment">        if (bits &lt;= bit_idx)</span>
<a name="l04832"></a>04832 <span class="comment">            break;</span>
<a name="l04833"></a>04833 <span class="comment"></span>
<a name="l04834"></a>04834 <span class="comment">        val = *(++src);</span>
<a name="l04835"></a>04835 <span class="comment">    } while (1);</span>
<a name="l04836"></a>04836 <span class="comment"></span>
<a name="l04837"></a>04837 <span class="comment">    return (T)(pcurr - dest);</span>
<a name="l04838"></a>04838 <span class="comment">}</span>
<a name="l04839"></a>04839 <span class="comment">*/</span>
<a name="l04840"></a>04840 
<a name="l04841"></a>04841 <span class="comment"></span>
<a name="l04842"></a>04842 <span class="comment">/*! @brief Calculates memory overhead for number of gap blocks sharing </span>
<a name="l04843"></a>04843 <span class="comment">           the same memory allocation table (level lengths table).</span>
<a name="l04844"></a>04844 <span class="comment">    @ingroup gapfunc</span>
<a name="l04845"></a>04845 <span class="comment">*/</span>
<a name="l04846"></a>04846 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; 
<a name="l04847"></a><a class="code" href="a00119.html#gacc578010f3700940829c600c812d23b1">04847</a> <span class="keywordtype">unsigned</span> <a class="code" href="a00119.html#gacc578010f3700940829c600c812d23b1" title="Convert bit block into an array of ints corresponding to 1 bits.">gap_overhead</a>(<span class="keyword">const</span> T* length, 
<a name="l04848"></a>04848                       <span class="keyword">const</span> T* length_end, 
<a name="l04849"></a>04849                       <span class="keyword">const</span> T* glevel_len)
<a name="l04850"></a>04850 {
<a name="l04851"></a>04851     <a class="code" href="a00092.html#aa44515fab0ace8928d1cb82009a95bf8">BM_ASSERT</a>(length &amp;&amp; length_end &amp;&amp; glevel_len);
<a name="l04852"></a>04852 
<a name="l04853"></a>04853     <span class="keywordtype">unsigned</span> overhead = 0;
<a name="l04854"></a>04854     <span class="keywordflow">for</span> (;length &lt; length_end; ++length)
<a name="l04855"></a>04855     {
<a name="l04856"></a>04856         <span class="keywordtype">unsigned</span> len = *length;
<a name="l04857"></a>04857         <span class="keywordtype">int</span> level = <a class="code" href="a00119.html#ga3bfaebeeb4b2d479c5a9ac9d57607165" title="Calculates GAP block capacity level.">gap_calc_level</a>(len, glevel_len);
<a name="l04858"></a>04858         <a class="code" href="a00092.html#aa44515fab0ace8928d1cb82009a95bf8">BM_ASSERT</a>(level &gt;= 0 &amp;&amp; level &lt; (<span class="keywordtype">int</span>)<a class="code" href="a00115.html#a773e9f5341919d58000bd54d50038733">bm::gap_levels</a>);
<a name="l04859"></a>04859         <span class="keywordtype">unsigned</span> capacity = glevel_len[level];
<a name="l04860"></a>04860         <a class="code" href="a00092.html#aa44515fab0ace8928d1cb82009a95bf8">BM_ASSERT</a>(capacity &gt;= len);
<a name="l04861"></a>04861         overhead += capacity - len;
<a name="l04862"></a>04862     }
<a name="l04863"></a>04863     <span class="keywordflow">return</span> overhead;
<a name="l04864"></a>04864 }
<a name="l04865"></a>04865 
<a name="l04866"></a>04866 <span class="comment"></span>
<a name="l04867"></a>04867 <span class="comment">/*! @brief Finds optimal gap blocks lengths.</span>
<a name="l04868"></a>04868 <span class="comment">    @param length - first element of GAP lengths array</span>
<a name="l04869"></a>04869 <span class="comment">    @param length_end - end of the GAP lengths array</span>
<a name="l04870"></a>04870 <span class="comment">    @param glevel_len - destination GAP lengths array</span>
<a name="l04871"></a>04871 <span class="comment">    @ingroup gapfunc</span>
<a name="l04872"></a>04872 <span class="comment">*/</span>
<a name="l04873"></a>04873 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;
<a name="l04874"></a><a class="code" href="a00119.html#ga2daff3a0ceda6fef87d3b0e892da5813">04874</a> <span class="keywordtype">bool</span> <a class="code" href="a00119.html#ga2daff3a0ceda6fef87d3b0e892da5813" title="Finds optimal gap blocks lengths.">improve_gap_levels</a>(<span class="keyword">const</span> T* length,
<a name="l04875"></a>04875                         <span class="keyword">const</span> T* length_end,
<a name="l04876"></a>04876                         T*       glevel_len)
<a name="l04877"></a>04877 {
<a name="l04878"></a>04878     <a class="code" href="a00092.html#aa44515fab0ace8928d1cb82009a95bf8">BM_ASSERT</a>(length &amp;&amp; length_end &amp;&amp; glevel_len);
<a name="l04879"></a>04879 
<a name="l04880"></a>04880     <span class="keywordtype">size_t</span> lsize = length_end - length;
<a name="l04881"></a>04881 
<a name="l04882"></a>04882     <a class="code" href="a00092.html#aa44515fab0ace8928d1cb82009a95bf8">BM_ASSERT</a>(lsize);
<a name="l04883"></a>04883     
<a name="l04884"></a>04884     <a class="code" href="a00115.html#ac654d6319039a86546d235a236fc7cf6">gap_word_t</a> max_len = 0;
<a name="l04885"></a>04885     <span class="keywordtype">unsigned</span> i;
<a name="l04886"></a>04886     <span class="keywordflow">for</span> (i = 0; i &lt; lsize; ++i)
<a name="l04887"></a>04887     {
<a name="l04888"></a>04888         <span class="keywordflow">if</span> (length[i] &gt; max_len)
<a name="l04889"></a>04889             max_len = length[i];
<a name="l04890"></a>04890     }
<a name="l04891"></a>04891     <span class="keywordflow">if</span> (max_len &lt; 5 || lsize &lt;= <a class="code" href="a00115.html#a773e9f5341919d58000bd54d50038733">bm::gap_levels</a>)
<a name="l04892"></a>04892     {
<a name="l04893"></a>04893         glevel_len[0] = max_len + 4;
<a name="l04894"></a>04894         <span class="keywordflow">for</span> (i = 1; i &lt; <a class="code" href="a00115.html#a773e9f5341919d58000bd54d50038733">bm::gap_levels</a>; ++i)
<a name="l04895"></a>04895         {
<a name="l04896"></a>04896             glevel_len[i] = <a class="code" href="a00115.html#aa5e01dfb650d168f9be0525e042af647">bm::gap_max_buff_len</a>;
<a name="l04897"></a>04897         }
<a name="l04898"></a>04898         <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l04899"></a>04899     }
<a name="l04900"></a>04900 
<a name="l04901"></a>04901     glevel_len[<a class="code" href="a00115.html#a773e9f5341919d58000bd54d50038733">bm::gap_levels</a>-1] = max_len + 5;
<a name="l04902"></a>04902 
<a name="l04903"></a>04903     <span class="keywordtype">unsigned</span> min_overhead = <a class="code" href="a00119.html#gacc578010f3700940829c600c812d23b1" title="Convert bit block into an array of ints corresponding to 1 bits.">gap_overhead</a>(length, length_end, glevel_len);
<a name="l04904"></a>04904     <span class="keywordtype">bool</span> is_improved = <span class="keyword">false</span>;
<a name="l04905"></a>04905     <a class="code" href="a00115.html#ac654d6319039a86546d235a236fc7cf6">gap_word_t</a> prev_value = glevel_len[<a class="code" href="a00115.html#a773e9f5341919d58000bd54d50038733">bm::gap_levels</a>-1];
<a name="l04906"></a>04906 
<a name="l04907"></a>04907     <span class="comment">// main problem solving loop</span>
<a name="l04908"></a>04908     <span class="comment">//</span>
<a name="l04909"></a>04909     <span class="keywordflow">for</span> (i = <a class="code" href="a00115.html#a773e9f5341919d58000bd54d50038733">bm::gap_levels</a>-2; ; --i)
<a name="l04910"></a>04910     {
<a name="l04911"></a>04911         <span class="keywordtype">unsigned</span> opt_len = 0;
<a name="l04912"></a>04912         <span class="keywordtype">unsigned</span> j;
<a name="l04913"></a>04913         <span class="keywordtype">bool</span> imp_flag = <span class="keyword">false</span>;
<a name="l04914"></a>04914         <a class="code" href="a00115.html#ac654d6319039a86546d235a236fc7cf6">gap_word_t</a> gap_saved_value = glevel_len[i];
<a name="l04915"></a>04915         <span class="keywordflow">for</span> (j = 0; j &lt; lsize; ++j)
<a name="l04916"></a>04916         {
<a name="l04917"></a>04917             glevel_len[i] = length[j]+4;
<a name="l04918"></a>04918             <span class="keywordtype">unsigned</span> ov = <a class="code" href="a00119.html#gacc578010f3700940829c600c812d23b1" title="Convert bit block into an array of ints corresponding to 1 bits.">gap_overhead</a>(length, length_end, glevel_len);
<a name="l04919"></a>04919             <span class="keywordflow">if</span> (ov &lt;= min_overhead)
<a name="l04920"></a>04920             {
<a name="l04921"></a>04921                 min_overhead = ov;                
<a name="l04922"></a>04922                 opt_len = length[j]+4;
<a name="l04923"></a>04923                 imp_flag = <span class="keyword">true</span>;
<a name="l04924"></a>04924             }
<a name="l04925"></a>04925         }
<a name="l04926"></a>04926         <span class="keywordflow">if</span> (imp_flag) 
<a name="l04927"></a>04927         {
<a name="l04928"></a>04928             glevel_len[i] = (T)opt_len; <span class="comment">// length[opt_idx]+4;</span>
<a name="l04929"></a>04929             is_improved = <span class="keyword">true</span>;
<a name="l04930"></a>04930         }
<a name="l04931"></a>04931         <span class="keywordflow">else</span> 
<a name="l04932"></a>04932         {
<a name="l04933"></a>04933             glevel_len[i] = gap_saved_value;
<a name="l04934"></a>04934         }
<a name="l04935"></a>04935         <span class="keywordflow">if</span> (i == 0) 
<a name="l04936"></a>04936             <span class="keywordflow">break</span>;
<a name="l04937"></a>04937         prev_value = glevel_len[i];
<a name="l04938"></a>04938     }
<a name="l04939"></a>04939     <span class="comment">// </span>
<a name="l04940"></a>04940     <span class="comment">// Remove duplicates</span>
<a name="l04941"></a>04941     <span class="comment">//</span>
<a name="l04942"></a>04942 
<a name="l04943"></a>04943     T val = *glevel_len;
<a name="l04944"></a>04944     T* gp = glevel_len;
<a name="l04945"></a>04945     T* res = glevel_len;
<a name="l04946"></a>04946     <span class="keywordflow">for</span> (i = 0; i &lt; <a class="code" href="a00115.html#a773e9f5341919d58000bd54d50038733">bm::gap_levels</a>; ++i)
<a name="l04947"></a>04947     {
<a name="l04948"></a>04948         <span class="keywordflow">if</span> (val != *gp)
<a name="l04949"></a>04949         {
<a name="l04950"></a>04950             val = *gp;
<a name="l04951"></a>04951             *++res = val;
<a name="l04952"></a>04952         }
<a name="l04953"></a>04953         ++gp;
<a name="l04954"></a>04954     }
<a name="l04955"></a>04955 
<a name="l04956"></a>04956     <span class="comment">// Filling the &quot;unused&quot; part with max. possible value</span>
<a name="l04957"></a>04957     <span class="keywordflow">while</span> (++res &lt; (glevel_len + bm::gap_levels)) 
<a name="l04958"></a>04958     {
<a name="l04959"></a>04959         *res = <a class="code" href="a00115.html#aa5e01dfb650d168f9be0525e042af647">bm::gap_max_buff_len</a>;
<a name="l04960"></a>04960     }
<a name="l04961"></a>04961 
<a name="l04962"></a>04962     <span class="keywordflow">return</span> is_improved;
<a name="l04963"></a>04963 
<a name="l04964"></a>04964 }
<a name="l04965"></a>04965 
<a name="l04966"></a>04966 
<a name="l04967"></a>04967 <span class="comment"></span>
<a name="l04968"></a>04968 <span class="comment">/**</span>
<a name="l04969"></a>04969 <span class="comment">    Bit-block get adapter, takes bitblock and represents it as a </span>
<a name="l04970"></a>04970 <span class="comment">    get_32() accessor function</span>
<a name="l04971"></a>04971 <span class="comment">    /internal</span>
<a name="l04972"></a>04972 <span class="comment">*/</span>
<a name="l04973"></a><a class="code" href="a00035.html">04973</a> <span class="keyword">class </span><a class="code" href="a00035.html" title="Bit-block get adapter, takes bitblock and represents it as a get_32() accessor function...">bitblock_get_adapter</a>
<a name="l04974"></a>04974 {
<a name="l04975"></a>04975 <span class="keyword">public</span>:
<a name="l04976"></a><a class="code" href="a00035.html#a266256a390509d2f87926bd2bac7748d">04976</a>     <a class="code" href="a00035.html#a266256a390509d2f87926bd2bac7748d">bitblock_get_adapter</a>(<span class="keyword">const</span> <a class="code" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a>* bit_block) : b_(bit_block) {}
<a name="l04977"></a>04977     
<a name="l04978"></a>04978     <a class="code" href="a00092.html#a938734d014fb68dd8b2251fe8ec2b025">BMFORCEINLINE</a>
<a name="l04979"></a><a class="code" href="a00035.html#a5fd937c34bcb5e5a2f6aa25333480db2">04979</a>     <a class="code" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> <a class="code" href="a00035.html#a5fd937c34bcb5e5a2f6aa25333480db2">get_32</a>() { <span class="keywordflow">return</span> *b_++; }
<a name="l04980"></a>04980 <span class="keyword">private</span>:
<a name="l04981"></a>04981     <span class="keyword">const</span> <a class="code" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a>*  b_;
<a name="l04982"></a>04982 };
<a name="l04983"></a>04983 
<a name="l04984"></a>04984 <span class="comment"></span>
<a name="l04985"></a>04985 <span class="comment">/**</span>
<a name="l04986"></a>04986 <span class="comment">    Bit-block store adapter, takes bitblock and saves results into it</span>
<a name="l04987"></a>04987 <span class="comment">    /internal</span>
<a name="l04988"></a>04988 <span class="comment">*/</span>
<a name="l04989"></a><a class="code" href="a00036.html">04989</a> <span class="keyword">class </span><a class="code" href="a00036.html" title="Bit-block store adapter, takes bitblock and saves results into it /internal.">bitblock_store_adapter</a>
<a name="l04990"></a>04990 {
<a name="l04991"></a>04991 <span class="keyword">public</span>:
<a name="l04992"></a><a class="code" href="a00036.html#a309083bbfd6b6206329d3407624f6e8c">04992</a>     <a class="code" href="a00036.html#a309083bbfd6b6206329d3407624f6e8c">bitblock_store_adapter</a>(<a class="code" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a>* bit_block) : b_(bit_block) {}
<a name="l04993"></a>04993     <a class="code" href="a00092.html#a938734d014fb68dd8b2251fe8ec2b025">BMFORCEINLINE</a>
<a name="l04994"></a><a class="code" href="a00036.html#a04ab146560605d7d4a158d736ada3d74">04994</a>     <span class="keywordtype">void</span> <a class="code" href="a00036.html#a04ab146560605d7d4a158d736ada3d74">push_back</a>(<a class="code" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> w) { *b_++ = w; }
<a name="l04995"></a>04995 <span class="keyword">private</span>:
<a name="l04996"></a>04996     <a class="code" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a>* b_;
<a name="l04997"></a>04997 };
<a name="l04998"></a>04998 <span class="comment"></span>
<a name="l04999"></a>04999 <span class="comment">/**</span>
<a name="l05000"></a>05000 <span class="comment">    Bit-block sum adapter, takes values and sums it</span>
<a name="l05001"></a>05001 <span class="comment">    /internal</span>
<a name="l05002"></a>05002 <span class="comment">*/</span>
<a name="l05003"></a><a class="code" href="a00037.html">05003</a> <span class="keyword">class </span><a class="code" href="a00037.html" title="Bit-block sum adapter, takes values and sums it /internal.">bitblock_sum_adapter</a>
<a name="l05004"></a>05004 {
<a name="l05005"></a>05005 <span class="keyword">public</span>:
<a name="l05006"></a><a class="code" href="a00037.html#a3a94e2bd54a12b27d94a62f9ae4628ee">05006</a>     <a class="code" href="a00037.html#a3a94e2bd54a12b27d94a62f9ae4628ee">bitblock_sum_adapter</a>() : sum_(0) {}
<a name="l05007"></a>05007     <a class="code" href="a00092.html#a938734d014fb68dd8b2251fe8ec2b025">BMFORCEINLINE</a>
<a name="l05008"></a><a class="code" href="a00037.html#ac7612d277b35a664989c8299f8da744c">05008</a>     <span class="keywordtype">void</span> <a class="code" href="a00037.html#ac7612d277b35a664989c8299f8da744c">push_back</a>(<a class="code" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> w) { this-&gt;sum_+= w; }<span class="comment"></span>
<a name="l05009"></a>05009 <span class="comment">    /// Get accumulated sum</span>
<a name="l05010"></a><a class="code" href="a00037.html#acc6c1b9a9929baee75d4729644037885">05010</a> <span class="comment"></span>    <a class="code" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> <a class="code" href="a00037.html#acc6c1b9a9929baee75d4729644037885" title="Get accumulated sum.">sum</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> this-&gt;sum_; }
<a name="l05011"></a>05011 <span class="keyword">private</span>:
<a name="l05012"></a>05012     <a class="code" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> sum_;
<a name="l05013"></a>05013 };
<a name="l05014"></a>05014 <span class="comment"></span>
<a name="l05015"></a>05015 <span class="comment">/**</span>
<a name="l05016"></a>05016 <span class="comment">    Adapter to get words from a range stream </span>
<a name="l05017"></a>05017 <span class="comment">    (see range serialized bit-block)</span>
<a name="l05018"></a>05018 <span class="comment">    \internal</span>
<a name="l05019"></a>05019 <span class="comment">*/</span>
<a name="l05020"></a><a class="code" href="a00056.html">05020</a> <span class="keyword">template</span>&lt;<span class="keyword">class</span> DEC&gt; <span class="keyword">class </span><a class="code" href="a00056.html" title="Adapter to get words from a range stream (see range serialized bit-block).">decoder_range_adapter</a>
<a name="l05021"></a>05021 {
<a name="l05022"></a>05022 <span class="keyword">public</span>: 
<a name="l05023"></a><a class="code" href="a00056.html#acef081bdb43b428cb65663ad422b2bd3">05023</a>     <a class="code" href="a00056.html#acef081bdb43b428cb65663ad422b2bd3">decoder_range_adapter</a>(DEC&amp; dec, <span class="keywordtype">unsigned</span> from_idx, <span class="keywordtype">unsigned</span> to_idx)
<a name="l05024"></a>05024     : decoder_(dec),
<a name="l05025"></a>05025       from_(from_idx),
<a name="l05026"></a>05026       to_(to_idx),
<a name="l05027"></a>05027       cnt_(0)
<a name="l05028"></a>05028     {}
<a name="l05029"></a>05029 
<a name="l05030"></a><a class="code" href="a00056.html#a42cd4bd363dec579dab6c0f5b2939562">05030</a>     <a class="code" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> <a class="code" href="a00056.html#a42cd4bd363dec579dab6c0f5b2939562">get_32</a>()
<a name="l05031"></a>05031     {
<a name="l05032"></a>05032         <span class="keywordflow">if</span> (cnt_ &lt; from_ || cnt_ &gt; to_)
<a name="l05033"></a>05033         {    
<a name="l05034"></a>05034             ++cnt_; <span class="keywordflow">return</span> 0;
<a name="l05035"></a>05035         }
<a name="l05036"></a>05036         ++cnt_;
<a name="l05037"></a>05037         <span class="keywordflow">return</span> decoder_.get_32();
<a name="l05038"></a>05038     }
<a name="l05039"></a>05039 
<a name="l05040"></a>05040 <span class="keyword">private</span>:
<a name="l05041"></a>05041     DEC&amp;     decoder_;
<a name="l05042"></a>05042     <span class="keywordtype">unsigned</span> from_;
<a name="l05043"></a>05043     <span class="keywordtype">unsigned</span> to_;
<a name="l05044"></a>05044     <span class="keywordtype">unsigned</span> cnt_;
<a name="l05045"></a>05045 };
<a name="l05046"></a>05046 
<a name="l05047"></a>05047 <span class="comment"></span>
<a name="l05048"></a>05048 <span class="comment">/*!</span>
<a name="l05049"></a>05049 <span class="comment">    Abstract recombination algorithm for two bit-blocks</span>
<a name="l05050"></a>05050 <span class="comment">    Bit blocks can come as dserialization decoders or bit-streams</span>
<a name="l05051"></a>05051 <span class="comment">*/</span>
<a name="l05052"></a>05052 <span class="keyword">template</span>&lt;<span class="keyword">class</span> It1, <span class="keyword">class</span> It2, <span class="keyword">class</span> BinaryOp, <span class="keyword">class</span> Encoder&gt;
<a name="l05053"></a><a class="code" href="a00115.html#a503fecc0ee281059897412d68f489e1e">05053</a> <span class="keywordtype">void</span> <a class="code" href="a00115.html#a503fecc0ee281059897412d68f489e1e">bit_recomb</a>(It1&amp; it1, It2&amp; it2, 
<a name="l05054"></a>05054                 BinaryOp&amp; op, 
<a name="l05055"></a>05055                 Encoder&amp; enc, 
<a name="l05056"></a>05056                 <span class="keywordtype">unsigned</span> block_size = <a class="code" href="a00115.html#a91319dbc0d0e1bf3a3efc4d92bac7972">bm::set_block_size</a>)
<a name="l05057"></a>05057 {
<a name="l05058"></a>05058     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i = 0; i &lt; block_size; ++i)
<a name="l05059"></a>05059     {
<a name="l05060"></a>05060         <a class="code" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> w1 = it1.get_32();
<a name="l05061"></a>05061         <a class="code" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> w2 = it2.get_32();
<a name="l05062"></a>05062         <a class="code" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> w = op(w1, w2);
<a name="l05063"></a>05063         enc.push_back( w );
<a name="l05064"></a>05064     } <span class="comment">// for</span>
<a name="l05065"></a>05065 }
<a name="l05066"></a>05066 <span class="comment"></span>
<a name="l05067"></a>05067 <span class="comment">/// Bit AND functor</span>
<a name="l05068"></a><a class="code" href="a00013.html">05068</a> <span class="comment"></span><span class="keyword">template</span>&lt;<span class="keyword">typename</span> W&gt; <span class="keyword">struct </span><a class="code" href="a00013.html" title="Bit AND functor.">bit_AND</a>
<a name="l05069"></a>05069 {
<a name="l05070"></a><a class="code" href="a00013.html#a158a14b25ed6831c7fefd64695fc816c">05070</a>     W <a class="code" href="a00013.html#a158a14b25ed6831c7fefd64695fc816c">operator()</a>(W w1, W w2) { <span class="keywordflow">return</span> w1 &amp; w2; }
<a name="l05071"></a>05071 };
<a name="l05072"></a>05072 <span class="comment"></span>
<a name="l05073"></a>05073 <span class="comment">/// Bit OR functor</span>
<a name="l05074"></a><a class="code" href="a00029.html">05074</a> <span class="comment"></span><span class="keyword">template</span>&lt;<span class="keyword">typename</span> W&gt; <span class="keyword">struct </span><a class="code" href="a00029.html" title="Bit OR functor.">bit_OR</a>
<a name="l05075"></a>05075 {
<a name="l05076"></a><a class="code" href="a00029.html#af6b753153686968b4fad2871ea7f60f2">05076</a>     W <a class="code" href="a00029.html#af6b753153686968b4fad2871ea7f60f2">operator()</a>(W w1, W w2) { <span class="keywordflow">return</span> w1 | w2; }
<a name="l05077"></a>05077 };
<a name="l05078"></a>05078 <span class="comment"></span>
<a name="l05079"></a>05079 <span class="comment">/// Bit SUB functor</span>
<a name="l05080"></a><a class="code" href="a00031.html">05080</a> <span class="comment"></span><span class="keyword">template</span>&lt;<span class="keyword">typename</span> W&gt; <span class="keyword">struct </span><a class="code" href="a00031.html" title="Bit SUB functor.">bit_SUB</a>
<a name="l05081"></a>05081 {
<a name="l05082"></a><a class="code" href="a00031.html#abd0415edafa50c93116c66314cb88148">05082</a>     W <a class="code" href="a00031.html#abd0415edafa50c93116c66314cb88148">operator()</a>(W w1, W w2) { <span class="keywordflow">return</span> w1 &amp; ~w2; }
<a name="l05083"></a>05083 };
<a name="l05084"></a>05084 <span class="comment"></span>
<a name="l05085"></a>05085 <span class="comment">/// Bit XOR functor</span>
<a name="l05086"></a><a class="code" href="a00033.html">05086</a> <span class="comment"></span><span class="keyword">template</span>&lt;<span class="keyword">typename</span> W&gt; <span class="keyword">struct </span><a class="code" href="a00033.html" title="Bit XOR functor.">bit_XOR</a>
<a name="l05087"></a>05087 {
<a name="l05088"></a><a class="code" href="a00033.html#a21cb402c91174d72ca7fe473b9e22bd8">05088</a>     W <a class="code" href="a00033.html#a21cb402c91174d72ca7fe473b9e22bd8">operator()</a>(W w1, W w2) { <span class="keywordflow">return</span> w1 ^ w2; }
<a name="l05089"></a>05089 };
<a name="l05090"></a>05090 <span class="comment"></span>
<a name="l05091"></a>05091 <span class="comment">/// Bit ASSIGN functor</span>
<a name="l05092"></a><a class="code" href="a00014.html">05092</a> <span class="comment"></span><span class="keyword">template</span>&lt;<span class="keyword">typename</span> W&gt; <span class="keyword">struct </span><a class="code" href="a00014.html" title="Bit ASSIGN functor.">bit_ASSIGN</a>
<a name="l05093"></a>05093 {
<a name="l05094"></a><a class="code" href="a00014.html#a870b61da95d05789a6cda3d57df7053e">05094</a>     W <a class="code" href="a00014.html#a870b61da95d05789a6cda3d57df7053e">operator()</a>(W w1, W w2) { <span class="keywordflow">return</span> w2; }
<a name="l05095"></a>05095 };
<a name="l05096"></a>05096 <span class="comment"></span>
<a name="l05097"></a>05097 <span class="comment">/// Bit COUNT functor</span>
<a name="l05098"></a><a class="code" href="a00015.html">05098</a> <span class="comment"></span><span class="keyword">template</span>&lt;<span class="keyword">typename</span> W&gt; <span class="keyword">struct </span><a class="code" href="a00015.html" title="Bit COUNT functor.">bit_COUNT</a>
<a name="l05099"></a>05099 {
<a name="l05100"></a><a class="code" href="a00015.html#a6241ea700bd682e3f0c35c679f80c352">05100</a>     W <a class="code" href="a00015.html#a6241ea700bd682e3f0c35c679f80c352">operator()</a>(W w1, W w2) 
<a name="l05101"></a>05101     {
<a name="l05102"></a>05102         w1 = 0;
<a name="l05103"></a>05103         <a class="code" href="a00120.html#ga967f6a5264f47d8adb93f6bdf8cdc129">BM_INCWORD_BITCOUNT</a>(w1, w2);
<a name="l05104"></a>05104         <span class="keywordflow">return</span> w1;
<a name="l05105"></a>05105     }
<a name="l05106"></a>05106 };
<a name="l05107"></a>05107 <span class="comment"></span>
<a name="l05108"></a>05108 <span class="comment">/// Bit COUNT AND functor</span>
<a name="l05109"></a><a class="code" href="a00017.html">05109</a> <span class="comment"></span><span class="keyword">template</span>&lt;<span class="keyword">typename</span> W&gt; <span class="keyword">struct </span><a class="code" href="a00017.html" title="Bit COUNT AND functor.">bit_COUNT_AND</a>
<a name="l05110"></a>05110 {
<a name="l05111"></a><a class="code" href="a00017.html#ac5e35266fd22b666d2e47922585e0bd4">05111</a>     W <a class="code" href="a00017.html#ac5e35266fd22b666d2e47922585e0bd4">operator()</a>(W w1, W w2) 
<a name="l05112"></a>05112     {
<a name="l05113"></a>05113         W r = 0;
<a name="l05114"></a>05114         <a class="code" href="a00120.html#ga967f6a5264f47d8adb93f6bdf8cdc129">BM_INCWORD_BITCOUNT</a>(r, w1 &amp; w2);
<a name="l05115"></a>05115         <span class="keywordflow">return</span> r;
<a name="l05116"></a>05116     }
<a name="l05117"></a>05117 };
<a name="l05118"></a>05118 <span class="comment"></span>
<a name="l05119"></a>05119 <span class="comment">/// Bit COUNT XOR functor</span>
<a name="l05120"></a><a class="code" href="a00023.html">05120</a> <span class="comment"></span><span class="keyword">template</span>&lt;<span class="keyword">typename</span> W&gt; <span class="keyword">struct </span><a class="code" href="a00023.html" title="Bit COUNT XOR functor.">bit_COUNT_XOR</a>
<a name="l05121"></a>05121 {
<a name="l05122"></a><a class="code" href="a00023.html#af51df3f3d2a924fe77c157203cce4105">05122</a>     W <a class="code" href="a00023.html#af51df3f3d2a924fe77c157203cce4105">operator()</a>(W w1, W w2) 
<a name="l05123"></a>05123     {
<a name="l05124"></a>05124         W r = 0;
<a name="l05125"></a>05125         <a class="code" href="a00120.html#ga967f6a5264f47d8adb93f6bdf8cdc129">BM_INCWORD_BITCOUNT</a>(r, w1 ^ w2);
<a name="l05126"></a>05126         <span class="keywordflow">return</span> r;
<a name="l05127"></a>05127     }
<a name="l05128"></a>05128 };
<a name="l05129"></a>05129 <span class="comment"></span>
<a name="l05130"></a>05130 <span class="comment">/// Bit COUNT OR functor</span>
<a name="l05131"></a><a class="code" href="a00019.html">05131</a> <span class="comment"></span><span class="keyword">template</span>&lt;<span class="keyword">typename</span> W&gt; <span class="keyword">struct </span><a class="code" href="a00019.html" title="Bit COUNT OR functor.">bit_COUNT_OR</a>
<a name="l05132"></a>05132 {
<a name="l05133"></a><a class="code" href="a00019.html#a6e7b8d564dc730e304e55975a85602cd">05133</a>     W <a class="code" href="a00019.html#a6e7b8d564dc730e304e55975a85602cd">operator()</a>(W w1, W w2) 
<a name="l05134"></a>05134     {
<a name="l05135"></a>05135         W r = 0;
<a name="l05136"></a>05136         <a class="code" href="a00120.html#ga967f6a5264f47d8adb93f6bdf8cdc129">BM_INCWORD_BITCOUNT</a>(r, w1 | w2);
<a name="l05137"></a>05137         <span class="keywordflow">return</span> r;
<a name="l05138"></a>05138     }
<a name="l05139"></a>05139 };
<a name="l05140"></a>05140 
<a name="l05141"></a>05141 <span class="comment"></span>
<a name="l05142"></a>05142 <span class="comment">/// Bit COUNT SUB AB functor</span>
<a name="l05143"></a><a class="code" href="a00020.html">05143</a> <span class="comment"></span><span class="keyword">template</span>&lt;<span class="keyword">typename</span> W&gt; <span class="keyword">struct </span><a class="code" href="a00020.html" title="Bit COUNT SUB AB functor.">bit_COUNT_SUB_AB</a>
<a name="l05144"></a>05144 {
<a name="l05145"></a><a class="code" href="a00020.html#a27efa5d69da163f699b58f8cf30cc7a8">05145</a>     W <a class="code" href="a00020.html#a27efa5d69da163f699b58f8cf30cc7a8">operator()</a>(W w1, W w2) 
<a name="l05146"></a>05146     {
<a name="l05147"></a>05147         W r = 0;
<a name="l05148"></a>05148         <a class="code" href="a00120.html#ga967f6a5264f47d8adb93f6bdf8cdc129">BM_INCWORD_BITCOUNT</a>(r, w1 &amp; (~w2));
<a name="l05149"></a>05149         <span class="keywordflow">return</span> r;
<a name="l05150"></a>05150     }
<a name="l05151"></a>05151 };
<a name="l05152"></a>05152 <span class="comment"></span>
<a name="l05153"></a>05153 <span class="comment">/// Bit SUB BA functor</span>
<a name="l05154"></a><a class="code" href="a00021.html">05154</a> <span class="comment"></span><span class="keyword">template</span>&lt;<span class="keyword">typename</span> W&gt; <span class="keyword">struct </span><a class="code" href="a00021.html" title="Bit SUB BA functor.">bit_COUNT_SUB_BA</a>
<a name="l05155"></a>05155 {
<a name="l05156"></a><a class="code" href="a00021.html#af182abdd0dc2c8e13c2ee8c7e91ee086">05156</a>     W <a class="code" href="a00021.html#af182abdd0dc2c8e13c2ee8c7e91ee086">operator()</a>(W w1, W w2) 
<a name="l05157"></a>05157     {
<a name="l05158"></a>05158         W r = 0;
<a name="l05159"></a>05159         <a class="code" href="a00120.html#ga967f6a5264f47d8adb93f6bdf8cdc129">BM_INCWORD_BITCOUNT</a>(r, w2 &amp; (~w1));
<a name="l05160"></a>05160         <span class="keywordflow">return</span> r;
<a name="l05161"></a>05161     }
<a name="l05162"></a>05162 };
<a name="l05163"></a>05163 <span class="comment"></span>
<a name="l05164"></a>05164 <span class="comment">/// Bit COUNT A functor</span>
<a name="l05165"></a><a class="code" href="a00016.html">05165</a> <span class="comment"></span><span class="keyword">template</span>&lt;<span class="keyword">typename</span> W&gt; <span class="keyword">struct </span><a class="code" href="a00016.html" title="Bit COUNT A functor.">bit_COUNT_A</a>
<a name="l05166"></a>05166 {
<a name="l05167"></a><a class="code" href="a00016.html#afb9ecfc944e0e77280c15eb566ed7823">05167</a>     W <a class="code" href="a00016.html#afb9ecfc944e0e77280c15eb566ed7823">operator()</a>(W w1, W w2) 
<a name="l05168"></a>05168     {
<a name="l05169"></a>05169         W r = 0;
<a name="l05170"></a>05170         <a class="code" href="a00120.html#ga967f6a5264f47d8adb93f6bdf8cdc129">BM_INCWORD_BITCOUNT</a>(r, w1);
<a name="l05171"></a>05171         <span class="keywordflow">return</span> r;
<a name="l05172"></a>05172     }
<a name="l05173"></a>05173 };
<a name="l05174"></a>05174 <span class="comment"></span>
<a name="l05175"></a>05175 <span class="comment">/// Bit COUNT B functor</span>
<a name="l05176"></a><a class="code" href="a00018.html">05176</a> <span class="comment"></span><span class="keyword">template</span>&lt;<span class="keyword">typename</span> W&gt; <span class="keyword">struct </span><a class="code" href="a00018.html" title="Bit COUNT B functor.">bit_COUNT_B</a>
<a name="l05177"></a>05177 {
<a name="l05178"></a><a class="code" href="a00018.html#a93802670706a36aae11a651ac68c2b6d">05178</a>     W <a class="code" href="a00018.html#a93802670706a36aae11a651ac68c2b6d">operator()</a>(W w1, W w2) 
<a name="l05179"></a>05179     {
<a name="l05180"></a>05180         W r = 0;
<a name="l05181"></a>05181         <a class="code" href="a00120.html#ga967f6a5264f47d8adb93f6bdf8cdc129">BM_INCWORD_BITCOUNT</a>(r, w2);
<a name="l05182"></a>05182         <span class="keywordflow">return</span> r;
<a name="l05183"></a>05183     }
<a name="l05184"></a>05184 };
<a name="l05185"></a>05185 
<a name="l05186"></a>05186 <span class="keyword">typedef</span> 
<a name="l05187"></a><a class="code" href="a00115.html#a18a8f03b151ca3a6d5e39e7709fb6c7c">05187</a> void (*<a class="code" href="a00115.html#a18a8f03b151ca3a6d5e39e7709fb6c7c">gap_operation_to_bitset_func_type</a>)(<span class="keywordtype">unsigned</span>*, 
<a name="l05188"></a>05188                                           <span class="keyword">const</span> <a class="code" href="a00115.html#ac654d6319039a86546d235a236fc7cf6">gap_word_t</a>*);
<a name="l05189"></a>05189 
<a name="l05190"></a>05190 <span class="keyword">typedef</span> 
<a name="l05191"></a><a class="code" href="a00115.html#a8402de852093e5b23b5825f1974b9c12">05191</a> <a class="code" href="a00115.html#ac654d6319039a86546d235a236fc7cf6">gap_word_t</a>* (*gap_operation_func_type)(<span class="keyword">const</span> <a class="code" href="a00115.html#ac654d6319039a86546d235a236fc7cf6">gap_word_t</a>* BMRESTRICT,
<a name="l05192"></a>05192                                        <span class="keyword">const</span> <a class="code" href="a00115.html#ac654d6319039a86546d235a236fc7cf6">gap_word_t</a>* BMRESTRICT,
<a name="l05193"></a>05193                                        <a class="code" href="a00115.html#ac654d6319039a86546d235a236fc7cf6">gap_word_t</a>*       BMRESTRICT,
<a name="l05194"></a>05194                                        <span class="keywordtype">unsigned</span>&amp; );
<a name="l05195"></a>05195 
<a name="l05196"></a>05196 <span class="keyword">typedef</span>
<a name="l05197"></a><a class="code" href="a00115.html#ad93f96a77f223240b8c6b8f81c5db840">05197</a> <a class="code" href="a00115.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a> (*<a class="code" href="a00115.html#ad93f96a77f223240b8c6b8f81c5db840">bit_operation_count_func_type</a>)(<span class="keyword">const</span> <a class="code" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a>* BMRESTRICT,
<a name="l05198"></a>05198                                           <span class="keyword">const</span> <a class="code" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a>* BMRESTRICT, 
<a name="l05199"></a>05199                                           <span class="keyword">const</span> <a class="code" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a>* BMRESTRICT);
<a name="l05200"></a>05200 
<a name="l05201"></a>05201 
<a name="l05202"></a>05202 <span class="keyword">template</span>&lt;<span class="keywordtype">bool</span> T&gt; 
<a name="l05203"></a><a class="code" href="a00076.html">05203</a> <span class="keyword">struct </span><a class="code" href="a00076.html">operation_functions</a>
<a name="l05204"></a>05204 {
<a name="l05205"></a>05205     <span class="keyword">static</span> 
<a name="l05206"></a><a class="code" href="a00076.html#aee09fac26fae4f59affa6ef4eeaea757">05206</a>         <a class="code" href="a00115.html#a18a8f03b151ca3a6d5e39e7709fb6c7c">gap_operation_to_bitset_func_type</a> <a class="code" href="a00076.html#aee09fac26fae4f59affa6ef4eeaea757">gap2bit_table_</a>[<a class="code" href="a00115.html#a76b70d2b9182a6dcac151d1bd9ec6109ad894d257a23664720dbf4155153a1e5c">bm::set_END</a>];
<a name="l05207"></a>05207     <span class="keyword">static</span> 
<a name="l05208"></a><a class="code" href="a00076.html#aed0f01bb28a3bc16c7362d9fdb0e34b1">05208</a>         <a class="code" href="a00115.html#a8402de852093e5b23b5825f1974b9c12">gap_operation_func_type</a> <a class="code" href="a00076.html#aed0f01bb28a3bc16c7362d9fdb0e34b1">gapop_table_</a>[<a class="code" href="a00115.html#a76b70d2b9182a6dcac151d1bd9ec6109ad894d257a23664720dbf4155153a1e5c">bm::set_END</a>];
<a name="l05209"></a>05209     <span class="keyword">static</span>
<a name="l05210"></a><a class="code" href="a00076.html#a7c99937be5149113db2007bc554fbfb6">05210</a>         <a class="code" href="a00115.html#ad93f96a77f223240b8c6b8f81c5db840">bit_operation_count_func_type</a> <a class="code" href="a00076.html#a7c99937be5149113db2007bc554fbfb6">bit_op_count_table_</a>[<a class="code" href="a00115.html#a76b70d2b9182a6dcac151d1bd9ec6109ad894d257a23664720dbf4155153a1e5c">bm::set_END</a>];
<a name="l05211"></a>05211 
<a name="l05212"></a>05212     <span class="keyword">static</span>
<a name="l05213"></a><a class="code" href="a00076.html#a691347341c16758acd97a7cebaf2d28e">05213</a>     <a class="code" href="a00115.html#a18a8f03b151ca3a6d5e39e7709fb6c7c">gap_operation_to_bitset_func_type</a> <a class="code" href="a00076.html#a691347341c16758acd97a7cebaf2d28e">gap_op_to_bit</a>(<span class="keywordtype">unsigned</span> i)
<a name="l05214"></a>05214     {
<a name="l05215"></a>05215         <span class="keywordflow">return</span> <a class="code" href="a00076.html#aee09fac26fae4f59affa6ef4eeaea757">gap2bit_table_</a>[i];
<a name="l05216"></a>05216     }
<a name="l05217"></a>05217 
<a name="l05218"></a>05218     <span class="keyword">static</span>
<a name="l05219"></a><a class="code" href="a00076.html#adc10260f808b51e3870e1bbc7e5dffd4">05219</a>     <a class="code" href="a00115.html#a8402de852093e5b23b5825f1974b9c12">gap_operation_func_type</a> <a class="code" href="a00076.html#adc10260f808b51e3870e1bbc7e5dffd4">gap_operation</a>(<span class="keywordtype">unsigned</span> i)
<a name="l05220"></a>05220     {
<a name="l05221"></a>05221         <span class="keywordflow">return</span> <a class="code" href="a00076.html#aed0f01bb28a3bc16c7362d9fdb0e34b1">gapop_table_</a>[i];
<a name="l05222"></a>05222     }
<a name="l05223"></a>05223 
<a name="l05224"></a>05224     <span class="keyword">static</span>
<a name="l05225"></a><a class="code" href="a00076.html#a4fc04066445af644759bf65ebf765760">05225</a>     <a class="code" href="a00115.html#ad93f96a77f223240b8c6b8f81c5db840">bit_operation_count_func_type</a> <a class="code" href="a00076.html#a4fc04066445af644759bf65ebf765760">bit_operation_count</a>(<span class="keywordtype">unsigned</span> i)
<a name="l05226"></a>05226     {
<a name="l05227"></a>05227         <span class="keywordflow">return</span> <a class="code" href="a00076.html#a7c99937be5149113db2007bc554fbfb6">bit_op_count_table_</a>[i];
<a name="l05228"></a>05228     }
<a name="l05229"></a>05229 };
<a name="l05230"></a>05230 
<a name="l05231"></a>05231 <span class="keyword">template</span>&lt;<span class="keywordtype">bool</span> T&gt;
<a name="l05232"></a>05232 <a class="code" href="a00115.html#a18a8f03b151ca3a6d5e39e7709fb6c7c">gap_operation_to_bitset_func_type</a> 
<a name="l05233"></a>05233 operation_functions&lt;T&gt;::gap2bit_table_[<a class="code" href="a00115.html#a76b70d2b9182a6dcac151d1bd9ec6109ad894d257a23664720dbf4155153a1e5c">bm::set_END</a>] = {
<a name="l05234"></a>05234     &amp;gap_and_to_bitset&lt;bm::gap_word_t&gt;,    <span class="comment">// set_AND</span>
<a name="l05235"></a>05235     &amp;gap_add_to_bitset&lt;bm::gap_word_t&gt;,    <span class="comment">// set_OR</span>
<a name="l05236"></a>05236     &amp;gap_sub_to_bitset&lt;bm::gap_word_t&gt;,    <span class="comment">// set_SUB</span>
<a name="l05237"></a>05237     &amp;gap_xor_to_bitset&lt;bm::gap_word_t&gt;,    <span class="comment">// set_XOR</span>
<a name="l05238"></a>05238     0
<a name="l05239"></a>05239 };
<a name="l05240"></a>05240 
<a name="l05241"></a>05241 <span class="keyword">template</span>&lt;<span class="keywordtype">bool</span> T&gt;
<a name="l05242"></a>05242 <a class="code" href="a00115.html#a8402de852093e5b23b5825f1974b9c12">gap_operation_func_type</a> 
<a name="l05243"></a>05243 operation_functions&lt;T&gt;::gapop_table_[<a class="code" href="a00115.html#a76b70d2b9182a6dcac151d1bd9ec6109ad894d257a23664720dbf4155153a1e5c">bm::set_END</a>] = {
<a name="l05244"></a>05244     &amp;<a class="code" href="a00119.html#gac18d7da0492983802511999a4ad0764a" title="GAP AND operation.">gap_operation_and</a>,    <span class="comment">// set_AND</span>
<a name="l05245"></a>05245     &amp;<a class="code" href="a00119.html#gacda280af8910ae5fde37731a3a7a1226" title="GAP OR operation.">gap_operation_or</a>,     <span class="comment">// set_OR</span>
<a name="l05246"></a>05246     &amp;<a class="code" href="a00119.html#gabe4c83e5e162c38e297116dd1cd05ac4" title="GAP SUB (AND NOT) operation.">gap_operation_sub</a>,    <span class="comment">// set_SUB</span>
<a name="l05247"></a>05247     &amp;<a class="code" href="a00119.html#ga72d2d3933b4410413eeb02e9ee0a910d" title="GAP XOR operation.">gap_operation_xor</a>,    <span class="comment">// set_XOR</span>
<a name="l05248"></a>05248     0
<a name="l05249"></a>05249 };
<a name="l05250"></a>05250 
<a name="l05251"></a>05251 
<a name="l05252"></a>05252 <span class="keyword">template</span>&lt;<span class="keywordtype">bool</span> T&gt;
<a name="l05253"></a>05253 <a class="code" href="a00115.html#ad93f96a77f223240b8c6b8f81c5db840">bit_operation_count_func_type</a> 
<a name="l05254"></a>05254 operation_functions&lt;T&gt;::bit_op_count_table_[<a class="code" href="a00115.html#a76b70d2b9182a6dcac151d1bd9ec6109ad894d257a23664720dbf4155153a1e5c">bm::set_END</a>] = {
<a name="l05255"></a>05255     0,                            <span class="comment">// set_AND</span>
<a name="l05256"></a>05256     0,                            <span class="comment">// set_OR</span>
<a name="l05257"></a>05257     0,                            <span class="comment">// set_SUB</span>
<a name="l05258"></a>05258     0,                            <span class="comment">// set_XOR</span>
<a name="l05259"></a>05259     0,                            <span class="comment">// set_ASSIGN</span>
<a name="l05260"></a>05260     0,                            <span class="comment">// set_COUNT</span>
<a name="l05261"></a>05261     &amp;<a class="code" href="a00120.html#ga9765914087df2fc22ec18db8128f2a12" title="Performs bitblock AND operation and calculates bitcount of the result.">bit_operation_and_count</a>,     <span class="comment">// set_COUNT_AND</span>
<a name="l05262"></a>05262     &amp;<a class="code" href="a00120.html#gace08ab77feefb638daee164ee83118bc" title="Performs bitblock XOR operation and calculates bitcount of the result.">bit_operation_xor_count</a>,     <span class="comment">// set_COUNT_XOR</span>
<a name="l05263"></a>05263     &amp;<a class="code" href="a00120.html#ga5a267aff3b56cc6dadf5a3a338e00a1d" title="Performs bitblock OR operation and calculates bitcount of the result.">bit_operation_or_count</a>,      <span class="comment">// set_COUNT_OR</span>
<a name="l05264"></a>05264     &amp;<a class="code" href="a00120.html#gaabb39bf01bf973cb7bf3648873921ab7" title="Performs bitblock SUB operation and calculates bitcount of the result.">bit_operation_sub_count</a>,     <span class="comment">// set_COUNT_SUB_AB</span>
<a name="l05265"></a>05265     &amp;<a class="code" href="a00120.html#ga53867faf377db72324b858a37063c0b8" title="Performs inverted bitblock SUB operation and calculates bitcount of the result.">bit_operation_sub_count_inv</a>, <span class="comment">// set_COUNT_SUB_BA</span>
<a name="l05266"></a>05266     0,                            <span class="comment">// set_COUNT_A</span>
<a name="l05267"></a>05267     0,                            <span class="comment">// set_COUNT_B</span>
<a name="l05268"></a>05268 };
<a name="l05269"></a>05269 
<a name="l05270"></a>05270 } <span class="comment">// namespace bm</span>
<a name="l05271"></a>05271 
<a name="l05272"></a>05272 <span class="preprocessor">#endif</span>
</pre></div></div>
<hr size="1"/><address style="text-align: right;"><small>Generated on Sun Apr 25 09:37:27 2010 for BitMagic by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
