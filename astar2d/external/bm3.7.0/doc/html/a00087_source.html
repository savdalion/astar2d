<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BitMagic: bm.h Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
<h1>bm.h</h1><a href="a00087.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="preprocessor">#ifndef BM__H__INCLUDED__</span>
<a name="l00002"></a>00002 <span class="preprocessor"></span><span class="preprocessor">#define BM__H__INCLUDED__</span>
<a name="l00003"></a>00003 <span class="preprocessor"></span><span class="comment">/*</span>
<a name="l00004"></a>00004 <span class="comment">Copyright(c) 2002-2010 Anatoliy Kuznetsov(anatoliy_kuznetsov at yahoo.com)</span>
<a name="l00005"></a>00005 <span class="comment"></span>
<a name="l00006"></a>00006 <span class="comment">Permission is hereby granted, free of charge, to any person </span>
<a name="l00007"></a>00007 <span class="comment">obtaining a copy of this software and associated documentation </span>
<a name="l00008"></a>00008 <span class="comment">files (the &quot;Software&quot;), to deal in the Software without restriction, </span>
<a name="l00009"></a>00009 <span class="comment">including without limitation the rights to use, copy, modify, merge, </span>
<a name="l00010"></a>00010 <span class="comment">publish, distribute, sublicense, and/or sell copies of the Software, </span>
<a name="l00011"></a>00011 <span class="comment">and to permit persons to whom the Software is furnished to do so, </span>
<a name="l00012"></a>00012 <span class="comment">subject to the following conditions:</span>
<a name="l00013"></a>00013 <span class="comment"></span>
<a name="l00014"></a>00014 <span class="comment">The above copyright notice and this permission notice shall be included </span>
<a name="l00015"></a>00015 <span class="comment">in all copies or substantial portions of the Software.</span>
<a name="l00016"></a>00016 <span class="comment"></span>
<a name="l00017"></a>00017 <span class="comment">THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, </span>
<a name="l00018"></a>00018 <span class="comment">EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES </span>
<a name="l00019"></a>00019 <span class="comment">OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. </span>
<a name="l00020"></a>00020 <span class="comment">IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, </span>
<a name="l00021"></a>00021 <span class="comment">DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, </span>
<a name="l00022"></a>00022 <span class="comment">ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR </span>
<a name="l00023"></a>00023 <span class="comment">OTHER DEALINGS IN THE SOFTWARE.</span>
<a name="l00024"></a>00024 <span class="comment"></span>
<a name="l00025"></a>00025 <span class="comment">For more information please visit:  http://bmagic.sourceforge.net</span>
<a name="l00026"></a>00026 <span class="comment"></span>
<a name="l00027"></a>00027 <span class="comment">*/</span>
<a name="l00028"></a>00028 
<a name="l00029"></a>00029 
<a name="l00030"></a>00030 <span class="comment">// define BM_NO_STL if you use BM in &quot;STL free&quot; environment and want</span>
<a name="l00031"></a>00031 <span class="comment">// to disable any references to STL headers</span>
<a name="l00032"></a>00032 <span class="preprocessor">#ifndef BM_NO_STL</span>
<a name="l00033"></a>00033 <span class="preprocessor"></span><span class="preprocessor"># include &lt;iterator&gt;</span>
<a name="l00034"></a>00034 <span class="preprocessor">#endif</span>
<a name="l00035"></a>00035 <span class="preprocessor"></span>
<a name="l00036"></a>00036 <span class="preprocessor">#ifdef _MSC_VER</span>
<a name="l00037"></a>00037 <span class="preprocessor"></span><span class="preprocessor">#pragma warning( push )</span>
<a name="l00038"></a>00038 <span class="preprocessor"></span><span class="preprocessor">#pragma warning( disable : 4311 4312 4127)</span>
<a name="l00039"></a>00039 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00040"></a>00040 <span class="preprocessor"></span>
<a name="l00041"></a>00041 
<a name="l00042"></a>00042 <span class="preprocessor">#ifdef BMSSE42OPT</span>
<a name="l00043"></a>00043 <span class="preprocessor"></span><span class="preprocessor"># ifdef BM64OPT</span>
<a name="l00044"></a>00044 <span class="preprocessor"></span><span class="preprocessor">#   undef BM64OPT</span>
<a name="l00045"></a><a class="code" href="a00087.html#a79160de599e55f5070417d858cced751">00045</a> <span class="preprocessor"></span><span class="preprocessor">#   define BM64_SSE4</span>
<a name="l00046"></a>00046 <span class="preprocessor"></span><span class="preprocessor"># endif</span>
<a name="l00047"></a>00047 <span class="preprocessor"></span><span class="preprocessor"># undef BMSSE2OPT</span>
<a name="l00048"></a>00048 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00049"></a>00049 <span class="preprocessor"></span>
<a name="l00050"></a>00050 
<a name="l00051"></a>00051 <span class="preprocessor">#include &quot;<a class="code" href="a00091.html">bmconst.h</a>&quot;</span>
<a name="l00052"></a>00052 <span class="preprocessor">#include &quot;<a class="code" href="a00092.html">bmdef.h</a>&quot;</span>
<a name="l00053"></a>00053 
<a name="l00054"></a>00054 
<a name="l00055"></a>00055 <span class="preprocessor">#ifdef BMSSE42OPT</span>
<a name="l00056"></a><a class="code" href="a00087.html#aa2c8ca7e259c278f3a9605205679de03">00056</a> <span class="preprocessor"></span><span class="preprocessor"># define BMVECTOPT</span>
<a name="l00057"></a>00057 <span class="preprocessor"></span><span class="preprocessor"># include &quot;<a class="code" href="a00098.html">bmsse4.h</a>&quot;</span>
<a name="l00058"></a>00058 <span class="preprocessor">#endif</span>
<a name="l00059"></a>00059 <span class="preprocessor"></span>
<a name="l00060"></a>00060 <span class="preprocessor">#ifdef BMSSE2OPT</span>
<a name="l00061"></a>00061 <span class="preprocessor"></span><span class="preprocessor"># undef BM64OPT</span>
<a name="l00062"></a>00062 <span class="preprocessor"></span><span class="preprocessor"># define BMVECTOPT</span>
<a name="l00063"></a>00063 <span class="preprocessor"></span><span class="preprocessor"># include &quot;<a class="code" href="a00097.html">bmsse2.h</a>&quot;</span>
<a name="l00064"></a>00064 <span class="preprocessor">#endif</span>
<a name="l00065"></a>00065 <span class="preprocessor"></span>
<a name="l00066"></a>00066 
<a name="l00067"></a>00067 <span class="preprocessor">#include &quot;bmfwd.h&quot;</span>
<a name="l00068"></a>00068 <span class="preprocessor">#include &quot;<a class="code" href="a00093.html">bmfunc.h</a>&quot;</span>
<a name="l00069"></a>00069 <span class="preprocessor">#include &quot;<a class="code" href="a00104.html">encoding.h</a>&quot;</span>
<a name="l00070"></a>00070 <span class="preprocessor">#include &quot;<a class="code" href="a00090.html">bmalloc.h</a>&quot;</span>
<a name="l00071"></a>00071 <span class="preprocessor">#include &quot;bmblocks.h&quot;</span>
<a name="l00072"></a>00072 
<a name="l00073"></a><a class="code" href="a00115.html">00073</a> <span class="keyword">namespace </span>bm
<a name="l00074"></a>00074 {
<a name="l00075"></a>00075 
<a name="l00076"></a>00076 
<a name="l00077"></a>00077 <span class="preprocessor">#ifdef BMCOUNTOPT</span>
<a name="l00078"></a>00078 <span class="preprocessor"></span>
<a name="l00079"></a>00079 <span class="preprocessor"># define BMCOUNT_INC ++count_;</span>
<a name="l00080"></a>00080 <span class="preprocessor"></span><span class="preprocessor"># define BMCOUNT_DEC --count_;</span>
<a name="l00081"></a>00081 <span class="preprocessor"></span><span class="preprocessor"># define BMCOUNT_VALID(x) count_is_valid_ = x;</span>
<a name="l00082"></a>00082 <span class="preprocessor"></span><span class="preprocessor"># define BMCOUNT_SET(x) count_ = x; count_is_valid_ = true;</span>
<a name="l00083"></a>00083 <span class="preprocessor"></span><span class="preprocessor"># define BMCOUNT_ADJ(x) if (x) ++count_; else --count_;</span>
<a name="l00084"></a>00084 <span class="preprocessor"></span>
<a name="l00085"></a>00085 <span class="preprocessor">#else</span>
<a name="l00086"></a>00086 <span class="preprocessor"></span>
<a name="l00087"></a><a class="code" href="a00087.html#a911e3d9e9a293cafab1396a8700288e9">00087</a> <span class="preprocessor"># define BMCOUNT_INC</span>
<a name="l00088"></a><a class="code" href="a00087.html#a809c66152f5967c1a1eb51e006206630">00088</a> <span class="preprocessor"></span><span class="preprocessor"># define BMCOUNT_DEC</span>
<a name="l00089"></a><a class="code" href="a00087.html#a835c3ed1c5956735e59744cff81244dc">00089</a> <span class="preprocessor"></span><span class="preprocessor"># define BMCOUNT_VALID(x)</span>
<a name="l00090"></a><a class="code" href="a00087.html#a1fbebc7fe3c22d768ff6e240437ee8f4">00090</a> <span class="preprocessor"></span><span class="preprocessor"># define BMCOUNT_SET(x)</span>
<a name="l00091"></a><a class="code" href="a00087.html#aef4146eb86de042a6c34717f87b16c10">00091</a> <span class="preprocessor"></span><span class="preprocessor"># define BMCOUNT_ADJ(x)</span>
<a name="l00092"></a>00092 <span class="preprocessor"></span>
<a name="l00093"></a>00093 <span class="preprocessor">#endif</span>
<a name="l00094"></a>00094 <span class="preprocessor"></span>
<a name="l00095"></a>00095 
<a name="l00096"></a>00096 
<a name="l00097"></a>00097 <span class="comment">//typedef bm::miniset&lt;bm::block_allocator, bm::set_total_blocks&gt; mem_save_set;</span>
<a name="l00098"></a>00098 
<a name="l00099"></a>00099 <span class="comment"></span>
<a name="l00100"></a>00100 <span class="comment">/** @defgroup bmagic BitMagic C++ Library</span>
<a name="l00101"></a>00101 <span class="comment"> *  For more information please visit:  http://bmagic.sourceforge.net</span>
<a name="l00102"></a>00102 <span class="comment"> *  </span>
<a name="l00103"></a>00103 <span class="comment"> */</span>
<a name="l00104"></a>00104 
<a name="l00105"></a>00105 <span class="comment"></span>
<a name="l00106"></a>00106 <span class="comment">/** @defgroup bvector The Main bvector&lt;&gt; Group</span>
<a name="l00107"></a>00107 <span class="comment"> *  This is the main group. It includes bvector template: front end of the bm library.</span>
<a name="l00108"></a>00108 <span class="comment"> *  @ingroup bmagic </span>
<a name="l00109"></a>00109 <span class="comment"> */</span>
<a name="l00110"></a>00110 
<a name="l00111"></a>00111 
<a name="l00112"></a>00112 
<a name="l00113"></a>00113 <span class="comment"></span>
<a name="l00114"></a>00114 <span class="comment">/*!</span>
<a name="l00115"></a>00115 <span class="comment">   @brief bitvector with runtime compression of bits.</span>
<a name="l00116"></a>00116 <span class="comment">   @ingroup bvector</span>
<a name="l00117"></a>00117 <span class="comment">*/</span>
<a name="l00118"></a>00118 
<a name="l00119"></a>00119 <span class="keyword">template</span>&lt;<span class="keyword">class</span> Alloc&gt; 
<a name="l00120"></a><a class="code" href="a00043.html">00120</a> <span class="keyword">class </span><a class="code" href="a00043.html" title="bitvector with runtime compression of bits.">bvector</a>
<a name="l00121"></a>00121 {
<a name="l00122"></a>00122 <span class="keyword">public</span>:
<a name="l00123"></a>00123 
<a name="l00124"></a><a class="code" href="a00043.html#ad1dbe63690fd5cd2b1e064795d3f1b6c">00124</a>     <span class="keyword">typedef</span> Alloc  <a class="code" href="a00043.html#ad1dbe63690fd5cd2b1e064795d3f1b6c">allocator_type</a>;
<a name="l00125"></a><a class="code" href="a00043.html#a6fdfeafe05217c31cdc9140b7642b611">00125</a>     <span class="keyword">typedef</span> blocks_manager&lt;Alloc&gt;      <a class="code" href="a00043.html#a6fdfeafe05217c31cdc9140b7642b611">blocks_manager_type</a>;<span class="comment"></span>
<a name="l00126"></a>00126 <span class="comment">    /** Type used to count bits in the bit vector */</span>
<a name="l00127"></a><a class="code" href="a00043.html#a405dd9ed048c935c84a5086ec8ba3649">00127</a>     <span class="keyword">typedef</span> <a class="code" href="a00115.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a>                   <a class="code" href="a00043.html#a405dd9ed048c935c84a5086ec8ba3649" title="Type used to count bits in the bit vector.">size_type</a>; 
<a name="l00128"></a>00128 <span class="comment"></span>
<a name="l00129"></a>00129 <span class="comment">    /** Statistical information about bitset&apos;s memory allocation details. */</span>
<a name="l00130"></a><a class="code" href="a00085.html">00130</a>     <span class="keyword">struct </span><a class="code" href="a00085.html" title="Statistical information about bitset&amp;#39;s memory allocation details.">statistics</a> : <span class="keyword">public</span> <a class="code" href="a00042.html" title="Structure with statistical information about bitset&amp;#39;s memory allocation details...">bv_statistics</a>
<a name="l00131"></a>00131     {};
<a name="l00132"></a>00132 <span class="comment"></span>
<a name="l00133"></a>00133 <span class="comment">    /**</span>
<a name="l00134"></a>00134 <span class="comment">        @brief Class reference implements an object for bit assignment.</span>
<a name="l00135"></a>00135 <span class="comment">        Since C++ does not provide with build-in bit type supporting l-value </span>
<a name="l00136"></a>00136 <span class="comment">        operations we have to emulate it.</span>
<a name="l00137"></a>00137 <span class="comment"></span>
<a name="l00138"></a>00138 <span class="comment">        @ingroup bvector</span>
<a name="l00139"></a>00139 <span class="comment">    */</span>
<a name="l00140"></a><a class="code" href="a00080.html">00140</a>     <span class="keyword">class </span><a class="code" href="a00080.html" title="Class reference implements an object for bit assignment.">reference</a>
<a name="l00141"></a>00141     {
<a name="l00142"></a>00142     <span class="keyword">public</span>:
<a name="l00143"></a><a class="code" href="a00080.html#a58db0955217c58c7ba327e3474d975f5">00143</a>         <a class="code" href="a00080.html#a58db0955217c58c7ba327e3474d975f5">reference</a>(<a class="code" href="a00043.html" title="bitvector with runtime compression of bits.">bvector&lt;Alloc&gt;</a>&amp; bv, <a class="code" href="a00115.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a> position) 
<a name="l00144"></a>00144         : bv_(bv),
<a name="l00145"></a>00145           position_(position)
<a name="l00146"></a>00146         {}
<a name="l00147"></a>00147 
<a name="l00148"></a><a class="code" href="a00080.html#a13f4391ca35675eb8773b550ec21ddfe">00148</a>         <a class="code" href="a00080.html#a58db0955217c58c7ba327e3474d975f5">reference</a>(<span class="keyword">const</span> <a class="code" href="a00080.html" title="Class reference implements an object for bit assignment.">reference</a>&amp; ref)
<a name="l00149"></a>00149         : bv_(ref.bv_), 
<a name="l00150"></a>00150           position_(ref.position_)
<a name="l00151"></a>00151         {
<a name="l00152"></a>00152             bv_.set(position_, ref.bv_.get_bit(position_));
<a name="l00153"></a>00153         }
<a name="l00154"></a>00154         
<a name="l00155"></a><a class="code" href="a00080.html#a4e9db79e3ac29ada86a9d70773033f4b">00155</a>         <a class="code" href="a00080.html#a4e9db79e3ac29ada86a9d70773033f4b">operator bool</a>()<span class="keyword"> const</span>
<a name="l00156"></a>00156 <span class="keyword">        </span>{
<a name="l00157"></a>00157             <span class="keywordflow">return</span> bv_.get_bit(position_);
<a name="l00158"></a>00158         }
<a name="l00159"></a>00159 
<a name="l00160"></a><a class="code" href="a00080.html#a1a02a69bf6a001e8f03b5e93fefb831c">00160</a>         <span class="keyword">const</span> <a class="code" href="a00080.html" title="Class reference implements an object for bit assignment.">reference</a>&amp; <a class="code" href="a00080.html#a1a02a69bf6a001e8f03b5e93fefb831c">operator=</a>(<span class="keyword">const</span> <a class="code" href="a00080.html" title="Class reference implements an object for bit assignment.">reference</a>&amp; ref)<span class="keyword"> const</span>
<a name="l00161"></a>00161 <span class="keyword">        </span>{
<a name="l00162"></a>00162             bv_.set(position_, (<span class="keywordtype">bool</span>)ref);
<a name="l00163"></a>00163             <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00164"></a>00164         }
<a name="l00165"></a>00165 
<a name="l00166"></a><a class="code" href="a00080.html#a9545924dec0ccd61eb3f035fd71933d6">00166</a>         <span class="keyword">const</span> <a class="code" href="a00080.html" title="Class reference implements an object for bit assignment.">reference</a>&amp; <a class="code" href="a00080.html#a1a02a69bf6a001e8f03b5e93fefb831c">operator=</a>(<span class="keywordtype">bool</span> value)<span class="keyword"> const</span>
<a name="l00167"></a>00167 <span class="keyword">        </span>{
<a name="l00168"></a>00168             bv_.set(position_, value);
<a name="l00169"></a>00169             <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00170"></a>00170         }
<a name="l00171"></a>00171 
<a name="l00172"></a><a class="code" href="a00080.html#adce705ebc8c11981db414b20c3d962cc">00172</a>         <span class="keywordtype">bool</span> <a class="code" href="a00080.html#adce705ebc8c11981db414b20c3d962cc">operator==</a>(<span class="keyword">const</span> <a class="code" href="a00080.html" title="Class reference implements an object for bit assignment.">reference</a>&amp; ref)<span class="keyword"> const</span>
<a name="l00173"></a>00173 <span class="keyword">        </span>{
<a name="l00174"></a>00174             <span class="keywordflow">return</span> bool(*<span class="keyword">this</span>) == bool(ref);
<a name="l00175"></a>00175         }
<a name="l00176"></a>00176 <span class="comment"></span>
<a name="l00177"></a>00177 <span class="comment">        /*! Bitwise AND. Performs operation: bit = bit AND value */</span>
<a name="l00178"></a><a class="code" href="a00080.html#a44c0e8d91b2d32d4759d91bf111b8a6b">00178</a>         <span class="keyword">const</span> <a class="code" href="a00080.html" title="Class reference implements an object for bit assignment.">reference</a>&amp; <a class="code" href="a00080.html#a44c0e8d91b2d32d4759d91bf111b8a6b">operator&amp;=</a>(<span class="keywordtype">bool</span> value)<span class="keyword"> const</span>
<a name="l00179"></a>00179 <span class="keyword">        </span>{
<a name="l00180"></a>00180             bv_.set_bit_and(position_, value);
<a name="l00181"></a>00181             <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00182"></a>00182         }
<a name="l00183"></a>00183 <span class="comment"></span>
<a name="l00184"></a>00184 <span class="comment">        /*! Bitwise OR. Performs operation: bit = bit OR value */</span>
<a name="l00185"></a><a class="code" href="a00080.html#a2356e5a6bd1429f9c3d2998a76be9989">00185</a>         <span class="keyword">const</span> <a class="code" href="a00080.html" title="Class reference implements an object for bit assignment.">reference</a>&amp; <a class="code" href="a00080.html#a2356e5a6bd1429f9c3d2998a76be9989">operator|=</a>(<span class="keywordtype">bool</span> value)<span class="keyword"> const</span>
<a name="l00186"></a>00186 <span class="keyword">        </span>{
<a name="l00187"></a>00187             <span class="keywordflow">if</span> (value != bv_.get_bit(position_))
<a name="l00188"></a>00188             {
<a name="l00189"></a>00189                 bv_.set_bit(position_);
<a name="l00190"></a>00190             }
<a name="l00191"></a>00191             <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00192"></a>00192         }
<a name="l00193"></a>00193 <span class="comment"></span>
<a name="l00194"></a>00194 <span class="comment">        /*! Bitwise exclusive-OR (XOR). Performs operation: bit = bit XOR value */</span>
<a name="l00195"></a><a class="code" href="a00080.html#a1e793999a7c3f75a642cb33d04063b07">00195</a>         <span class="keyword">const</span> <a class="code" href="a00080.html" title="Class reference implements an object for bit assignment.">reference</a>&amp; <a class="code" href="a00080.html#a1e793999a7c3f75a642cb33d04063b07">operator^=</a>(<span class="keywordtype">bool</span> value)<span class="keyword"> const</span>
<a name="l00196"></a>00196 <span class="keyword">        </span>{
<a name="l00197"></a>00197             bv_.set(position_, value != bv_.get_bit(position_));
<a name="l00198"></a>00198             <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00199"></a>00199         }
<a name="l00200"></a>00200 <span class="comment"></span>
<a name="l00201"></a>00201 <span class="comment">        /*! Logical Not operator */</span>
<a name="l00202"></a><a class="code" href="a00080.html#a8e9f49487c7958c0d0f88c1998b41258">00202</a>         <span class="keywordtype">bool</span> <a class="code" href="a00080.html#a8e9f49487c7958c0d0f88c1998b41258">operator!</a>()<span class="keyword"> const</span>
<a name="l00203"></a>00203 <span class="keyword">        </span>{
<a name="l00204"></a>00204             <span class="keywordflow">return</span> !bv_.get_bit(position_);
<a name="l00205"></a>00205         }
<a name="l00206"></a>00206 <span class="comment"></span>
<a name="l00207"></a>00207 <span class="comment">        /*! Bit Not operator */</span>
<a name="l00208"></a><a class="code" href="a00080.html#aa1266905549047b773b428e1573b88da">00208</a>         <span class="keywordtype">bool</span> <a class="code" href="a00080.html#aa1266905549047b773b428e1573b88da">operator~</a>()<span class="keyword"> const</span>
<a name="l00209"></a>00209 <span class="keyword">        </span>{
<a name="l00210"></a>00210             <span class="keywordflow">return</span> !bv_.get_bit(position_);
<a name="l00211"></a>00211         }
<a name="l00212"></a>00212 <span class="comment"></span>
<a name="l00213"></a>00213 <span class="comment">        /*! Negates the bit value */</span>
<a name="l00214"></a><a class="code" href="a00080.html#a0084e627fc63eb348cc81a5525112b1a">00214</a>         <a class="code" href="a00080.html" title="Class reference implements an object for bit assignment.">reference</a>&amp; <a class="code" href="a00080.html#a0084e627fc63eb348cc81a5525112b1a">flip</a>()
<a name="l00215"></a>00215         {
<a name="l00216"></a>00216             bv_.flip(position_);
<a name="l00217"></a>00217             <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00218"></a>00218         }
<a name="l00219"></a>00219 
<a name="l00220"></a>00220     <span class="keyword">private</span>:
<a name="l00221"></a>00221         <a class="code" href="a00043.html" title="bitvector with runtime compression of bits.">bvector&lt;Alloc&gt;</a>&amp;   bv_;       <span class="comment">//!&lt; Reference variable on the parent.</span>
<a name="l00222"></a>00222 <span class="comment"></span>        <a class="code" href="a00115.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a>          position_; <span class="comment">//!&lt; Position in the parent bitvector.</span>
<a name="l00223"></a>00223 <span class="comment"></span>    };
<a name="l00224"></a>00224 
<a name="l00225"></a><a class="code" href="a00043.html#a04d7ea71a6e69abb26e03b31f93e6689">00225</a>     <span class="keyword">typedef</span> <span class="keywordtype">bool</span> <a class="code" href="a00043.html#a04d7ea71a6e69abb26e03b31f93e6689">const_reference</a>;
<a name="l00226"></a>00226 <span class="comment"></span>
<a name="l00227"></a>00227 <span class="comment">    /*!</span>
<a name="l00228"></a>00228 <span class="comment">        @brief Base class for all iterators.</span>
<a name="l00229"></a>00229 <span class="comment">        @ingroup bvector</span>
<a name="l00230"></a>00230 <span class="comment">    */</span>
<a name="l00231"></a><a class="code" href="a00071.html">00231</a>     <span class="keyword">class </span><a class="code" href="a00071.html" title="Base class for all iterators.">iterator_base</a>
<a name="l00232"></a>00232     {
<a name="l00233"></a><a class="code" href="a00071.html#a5bb8687c5e87638689649a12c54187cb">00233</a>     <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="a00043.html" title="bitvector with runtime compression of bits.">bvector</a>;
<a name="l00234"></a>00234     <span class="keyword">public</span>:
<a name="l00235"></a><a class="code" href="a00071.html#a175d1dfe3e3c6f69beb65ac8d6d8e714">00235</a>         <a class="code" href="a00071.html#a175d1dfe3e3c6f69beb65ac8d6d8e714">iterator_base</a>() : <a class="code" href="a00071.html#a9d01206c2a1b6fafc5a74654367b763b" title="Pointer on parent bitvector.">bv_</a>(0), <a class="code" href="a00071.html#a00d4c7e92f4c22e158c5cd2e83ff0978" title="Bit position (bit idx).">position_</a>(bm::<a class="code" href="a00115.html#a104b924a1df81542db2a6296fbf26a65">id_max</a>), <a class="code" href="a00071.html#abd6a28fb9b028876ef2d4007ac90e52b" title="Block pointer.(NULL-invalid).">block_</a>(0) {}
<a name="l00236"></a>00236 
<a name="l00237"></a><a class="code" href="a00071.html#a197a2684096a418d1aae10d587f065fc">00237</a>         <span class="keywordtype">bool</span> <a class="code" href="a00071.html#a197a2684096a418d1aae10d587f065fc">operator==</a>(<span class="keyword">const</span> <a class="code" href="a00071.html" title="Base class for all iterators.">iterator_base</a>&amp; it)<span class="keyword"> const</span>
<a name="l00238"></a>00238 <span class="keyword">        </span>{
<a name="l00239"></a>00239             <span class="keywordflow">return</span> (<a class="code" href="a00071.html#a00d4c7e92f4c22e158c5cd2e83ff0978" title="Bit position (bit idx).">position_</a> == it.<a class="code" href="a00071.html#a00d4c7e92f4c22e158c5cd2e83ff0978" title="Bit position (bit idx).">position_</a>) &amp;&amp; (<a class="code" href="a00071.html#a9d01206c2a1b6fafc5a74654367b763b" title="Pointer on parent bitvector.">bv_</a> == it.<a class="code" href="a00071.html#a9d01206c2a1b6fafc5a74654367b763b" title="Pointer on parent bitvector.">bv_</a>);
<a name="l00240"></a>00240         }
<a name="l00241"></a>00241 
<a name="l00242"></a><a class="code" href="a00071.html#a2ac75793a73ae586e8e2b9809427474b">00242</a>         <span class="keywordtype">bool</span> <a class="code" href="a00071.html#a2ac75793a73ae586e8e2b9809427474b">operator!=</a>(<span class="keyword">const</span> <a class="code" href="a00071.html" title="Base class for all iterators.">iterator_base</a>&amp; it)<span class="keyword"> const</span>
<a name="l00243"></a>00243 <span class="keyword">        </span>{
<a name="l00244"></a>00244             <span class="keywordflow">return</span> ! <a class="code" href="a00071.html#a197a2684096a418d1aae10d587f065fc">operator==</a>(it);
<a name="l00245"></a>00245         }
<a name="l00246"></a>00246 
<a name="l00247"></a><a class="code" href="a00071.html#a7e8d1bbfb8fb9b85c7e9881e19c6f601">00247</a>         <span class="keywordtype">bool</span> <a class="code" href="a00071.html#a7e8d1bbfb8fb9b85c7e9881e19c6f601">operator &lt; </a>(<span class="keyword">const</span> <a class="code" href="a00071.html" title="Base class for all iterators.">iterator_base</a>&amp; it)<span class="keyword"> const</span>
<a name="l00248"></a>00248 <span class="keyword">        </span>{
<a name="l00249"></a>00249             <span class="keywordflow">return</span> <a class="code" href="a00071.html#a00d4c7e92f4c22e158c5cd2e83ff0978" title="Bit position (bit idx).">position_</a> &lt; it.<a class="code" href="a00071.html#a00d4c7e92f4c22e158c5cd2e83ff0978" title="Bit position (bit idx).">position_</a>;
<a name="l00250"></a>00250         }
<a name="l00251"></a>00251 
<a name="l00252"></a><a class="code" href="a00071.html#aa26c1d25d4a04930b6b049de317f2ab3">00252</a>         <span class="keywordtype">bool</span> <a class="code" href="a00071.html#aa26c1d25d4a04930b6b049de317f2ab3">operator &lt;= </a>(<span class="keyword">const</span> <a class="code" href="a00071.html" title="Base class for all iterators.">iterator_base</a>&amp; it)<span class="keyword"> const</span>
<a name="l00253"></a>00253 <span class="keyword">        </span>{
<a name="l00254"></a>00254             <span class="keywordflow">return</span> <a class="code" href="a00071.html#a00d4c7e92f4c22e158c5cd2e83ff0978" title="Bit position (bit idx).">position_</a> &lt;= it.<a class="code" href="a00071.html#a00d4c7e92f4c22e158c5cd2e83ff0978" title="Bit position (bit idx).">position_</a>;
<a name="l00255"></a>00255         }
<a name="l00256"></a>00256 
<a name="l00257"></a><a class="code" href="a00071.html#a1ed9a4e87e5ad384d6545defbe3a759c">00257</a>         <span class="keywordtype">bool</span> <a class="code" href="a00071.html#a1ed9a4e87e5ad384d6545defbe3a759c">operator &gt; </a>(<span class="keyword">const</span> <a class="code" href="a00071.html" title="Base class for all iterators.">iterator_base</a>&amp; it)<span class="keyword"> const</span>
<a name="l00258"></a>00258 <span class="keyword">        </span>{
<a name="l00259"></a>00259             <span class="keywordflow">return</span> <a class="code" href="a00071.html#a00d4c7e92f4c22e158c5cd2e83ff0978" title="Bit position (bit idx).">position_</a> &gt; it.<a class="code" href="a00071.html#a00d4c7e92f4c22e158c5cd2e83ff0978" title="Bit position (bit idx).">position_</a>;
<a name="l00260"></a>00260         }
<a name="l00261"></a>00261 
<a name="l00262"></a><a class="code" href="a00071.html#a67cb622009a05b82ef330edff376c486">00262</a>         <span class="keywordtype">bool</span> <a class="code" href="a00071.html#a67cb622009a05b82ef330edff376c486">operator &gt;= </a>(<span class="keyword">const</span> <a class="code" href="a00071.html" title="Base class for all iterators.">iterator_base</a>&amp; it)<span class="keyword"> const</span>
<a name="l00263"></a>00263 <span class="keyword">        </span>{
<a name="l00264"></a>00264             <span class="keywordflow">return</span> <a class="code" href="a00071.html#a00d4c7e92f4c22e158c5cd2e83ff0978" title="Bit position (bit idx).">position_</a> &gt;= it.<a class="code" href="a00071.html#a00d4c7e92f4c22e158c5cd2e83ff0978" title="Bit position (bit idx).">position_</a>;
<a name="l00265"></a>00265         }
<a name="l00266"></a>00266 <span class="comment"></span>
<a name="l00267"></a>00267 <span class="comment">        /**</span>
<a name="l00268"></a>00268 <span class="comment">           \fn bool bm::bvector::iterator_base::valid() const</span>
<a name="l00269"></a>00269 <span class="comment">           \brief Checks if iterator is still valid. Analog of != 0 comparison for pointers.</span>
<a name="l00270"></a>00270 <span class="comment">           \returns true if iterator is valid.</span>
<a name="l00271"></a>00271 <span class="comment">        */</span>
<a name="l00272"></a><a class="code" href="a00071.html#a244f7a540f602fc7b58e7efd3f7792a3">00272</a>         <span class="keywordtype">bool</span> <a class="code" href="a00071.html#a244f7a540f602fc7b58e7efd3f7792a3" title="Checks if iterator is still valid.">valid</a>()<span class="keyword"> const</span>
<a name="l00273"></a>00273 <span class="keyword">        </span>{
<a name="l00274"></a>00274             <span class="keywordflow">return</span> <a class="code" href="a00071.html#a00d4c7e92f4c22e158c5cd2e83ff0978" title="Bit position (bit idx).">position_</a> != <a class="code" href="a00115.html#a104b924a1df81542db2a6296fbf26a65">bm::id_max</a>;
<a name="l00275"></a>00275         }
<a name="l00276"></a>00276 <span class="comment"></span>
<a name="l00277"></a>00277 <span class="comment">        /**</span>
<a name="l00278"></a>00278 <span class="comment">           \fn bool bm::bvector::iterator_base::invalidate() </span>
<a name="l00279"></a>00279 <span class="comment">           \brief Turns iterator into an invalid state.</span>
<a name="l00280"></a>00280 <span class="comment">        */</span>
<a name="l00281"></a><a class="code" href="a00071.html#a42f86377bc0e8bcfd8cbace7bac704c1">00281</a>         <span class="keywordtype">void</span> <a class="code" href="a00071.html#a42f86377bc0e8bcfd8cbace7bac704c1" title="Turns iterator into an invalid state.">invalidate</a>()
<a name="l00282"></a>00282         {
<a name="l00283"></a>00283             <a class="code" href="a00071.html#a00d4c7e92f4c22e158c5cd2e83ff0978" title="Bit position (bit idx).">position_</a> = <a class="code" href="a00115.html#a104b924a1df81542db2a6296fbf26a65">bm::id_max</a>;
<a name="l00284"></a>00284         }
<a name="l00285"></a>00285 
<a name="l00286"></a>00286     <span class="keyword">public</span>:
<a name="l00287"></a>00287 <span class="comment"></span>
<a name="l00288"></a>00288 <span class="comment">        /** Information about current bitblock. */</span>
<a name="l00289"></a><a class="code" href="a00034.html">00289</a>         <span class="keyword">struct </span><a class="code" href="a00034.html" title="Information about current bitblock.">bitblock_descr</a>
<a name="l00290"></a>00290         {
<a name="l00291"></a><a class="code" href="a00034.html#ac712f263b9856997e000ab5a79ba736b">00291</a>             <span class="keyword">const</span> <a class="code" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a>*   <a class="code" href="a00034.html#ac712f263b9856997e000ab5a79ba736b" title="Word pointer.">ptr</a>;      <span class="comment">//!&lt; Word pointer.</span>
<a name="l00292"></a><a class="code" href="a00034.html#afeb7c68ceb3880636c9cd95da6a302e4">00292</a> <span class="comment"></span>            <span class="keywordtype">unsigned</span>            <a class="code" href="a00034.html#afeb7c68ceb3880636c9cd95da6a302e4" title="Unpacked list of ON bits.">bits</a>[32]; <span class="comment">//!&lt; Unpacked list of ON bits</span>
<a name="l00293"></a><a class="code" href="a00034.html#a187385a2fe380676a225a18efa655dee">00293</a> <span class="comment"></span>            <span class="keywordtype">unsigned</span>            <a class="code" href="a00034.html#a187385a2fe380676a225a18efa655dee" title="Current position in the bit list.">idx</a>;      <span class="comment">//!&lt; Current position in the bit list</span>
<a name="l00294"></a><a class="code" href="a00034.html#ad6bb471d5fb3f70178ba85560388f582">00294</a> <span class="comment"></span>            <span class="keywordtype">unsigned</span>            <a class="code" href="a00034.html#ad6bb471d5fb3f70178ba85560388f582" title="Number of ON bits.">cnt</a>;      <span class="comment">//!&lt; Number of ON bits</span>
<a name="l00295"></a><a class="code" href="a00034.html#a6587ae6bccb911ef7dbc17d07c7ca924">00295</a> <span class="comment"></span>            <a class="code" href="a00115.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a>            <a class="code" href="a00034.html#a6587ae6bccb911ef7dbc17d07c7ca924" title="Last bit position before.">pos</a>;      <span class="comment">//!&lt; Last bit position before </span>
<a name="l00296"></a>00296 <span class="comment"></span>        };
<a name="l00297"></a>00297 <span class="comment"></span>
<a name="l00298"></a>00298 <span class="comment">        /** Information about current DGAP block. */</span>
<a name="l00299"></a><a class="code" href="a00059.html">00299</a>         <span class="keyword">struct </span><a class="code" href="a00059.html" title="Information about current DGAP block.">dgap_descr</a>
<a name="l00300"></a>00300         {
<a name="l00301"></a><a class="code" href="a00059.html#a179f7bc7fe9401de6c28954438c02dac">00301</a>             <span class="keyword">const</span> <a class="code" href="a00115.html#ac654d6319039a86546d235a236fc7cf6">gap_word_t</a>*   <a class="code" href="a00059.html#a179f7bc7fe9401de6c28954438c02dac" title="Word pointer.">ptr</a>;       <span class="comment">//!&lt; Word pointer.</span>
<a name="l00302"></a><a class="code" href="a00059.html#a9f1e849e580ef100a78d1f5fb777a117">00302</a> <span class="comment"></span>            <a class="code" href="a00115.html#ac654d6319039a86546d235a236fc7cf6">gap_word_t</a>          <a class="code" href="a00059.html#a9f1e849e580ef100a78d1f5fb777a117" title="Current dgap length.">gap_len</a>;   <span class="comment">//!&lt; Current dgap length.</span>
<a name="l00303"></a>00303 <span class="comment"></span>        };
<a name="l00304"></a>00304 
<a name="l00305"></a>00305     <span class="keyword">protected</span>:
<a name="l00306"></a><a class="code" href="a00071.html#a9d01206c2a1b6fafc5a74654367b763b">00306</a>         <a class="code" href="a00043.html" title="bitvector with runtime compression of bits.">bm::bvector&lt;Alloc&gt;</a>*     <a class="code" href="a00071.html#a9d01206c2a1b6fafc5a74654367b763b" title="Pointer on parent bitvector.">bv_</a>;         <span class="comment">//!&lt; Pointer on parent bitvector</span>
<a name="l00307"></a><a class="code" href="a00071.html#a00d4c7e92f4c22e158c5cd2e83ff0978">00307</a> <span class="comment"></span>        <a class="code" href="a00115.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a>                <a class="code" href="a00071.html#a00d4c7e92f4c22e158c5cd2e83ff0978" title="Bit position (bit idx).">position_</a>;   <span class="comment">//!&lt; Bit position (bit idx)</span>
<a name="l00308"></a><a class="code" href="a00071.html#abd6a28fb9b028876ef2d4007ac90e52b">00308</a> <span class="comment"></span>        <span class="keyword">const</span> <a class="code" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a>*       <a class="code" href="a00071.html#abd6a28fb9b028876ef2d4007ac90e52b" title="Block pointer.(NULL-invalid).">block_</a>;      <span class="comment">//!&lt; Block pointer.(NULL-invalid)</span>
<a name="l00309"></a><a class="code" href="a00071.html#a6d7e22a16265c40422bc6c23e64e6d52">00309</a> <span class="comment"></span>        <span class="keywordtype">unsigned</span>                <a class="code" href="a00071.html#a6d7e22a16265c40422bc6c23e64e6d52" title="Type of block. 0-Bit, 1-GAP.">block_type_</a>; <span class="comment">//!&lt; Type of block. 0-Bit, 1-GAP</span>
<a name="l00310"></a><a class="code" href="a00071.html#a3c0a421fe09c6345a822e70e56dd8757">00310</a> <span class="comment"></span>        <span class="keywordtype">unsigned</span>                <a class="code" href="a00071.html#a3c0a421fe09c6345a822e70e56dd8757" title="Block index.">block_idx_</a>;  <span class="comment">//!&lt; Block index</span>
<a name="l00311"></a>00311 <span class="comment"></span><span class="comment"></span>
<a name="l00312"></a>00312 <span class="comment">        /*! Block type dependent information for current block. */</span>
<a name="l00313"></a><a class="code" href="a00039.html">00313</a>         <span class="keyword">union </span><a class="code" href="a00039.html">block_descr</a>
<a name="l00314"></a>00314         {
<a name="l00315"></a><a class="code" href="a00039.html#afdae70a22a7b7d8a0ae9e6728ec628ed">00315</a>             <a class="code" href="a00034.html" title="Information about current bitblock.">bitblock_descr</a>   <a class="code" href="a00039.html#afdae70a22a7b7d8a0ae9e6728ec628ed" title="BitBlock related info.">bit_</a>;  <span class="comment">//!&lt; BitBlock related info.</span>
<a name="l00316"></a><a class="code" href="a00039.html#a7f39ef2f352d0b449bfb6c2d9134fc56">00316</a> <span class="comment"></span>            <a class="code" href="a00059.html" title="Information about current DGAP block.">dgap_descr</a>       <a class="code" href="a00039.html#a7f39ef2f352d0b449bfb6c2d9134fc56" title="DGAP block related info.">gap_</a>;  <span class="comment">//!&lt; DGAP block related info.</span>
<a name="l00317"></a>00317 <span class="comment"></span>        } <a class="code" href="a00071.html#abf6c623a56e042c36de5a2d43bb0b065">bdescr_</a>;
<a name="l00318"></a>00318     };
<a name="l00319"></a>00319 <span class="comment"></span>
<a name="l00320"></a>00320 <span class="comment">    /*!</span>
<a name="l00321"></a>00321 <span class="comment">        @brief Output iterator iterator designed to set &quot;ON&quot; bits based on</span>
<a name="l00322"></a>00322 <span class="comment">        input sequence of integers (bit indeces).</span>
<a name="l00323"></a>00323 <span class="comment"></span>
<a name="l00324"></a>00324 <span class="comment">        STL container can be converted to bvector using this iterator</span>
<a name="l00325"></a>00325 <span class="comment">        Insert iterator guarantees the vector will be dynamically resized</span>
<a name="l00326"></a>00326 <span class="comment">        (set_bit does not do that).</span>
<a name="l00327"></a>00327 <span class="comment"></span>
<a name="l00328"></a>00328 <span class="comment">        @note</span>
<a name="l00329"></a>00329 <span class="comment">        If you have many bits to set it is a good idea to use output iterator</span>
<a name="l00330"></a>00330 <span class="comment">        instead of explicitly calling set, because iterator may implement</span>
<a name="l00331"></a>00331 <span class="comment">        some performance specific tricks to make sure bulk insert is fast.</span>
<a name="l00332"></a>00332 <span class="comment"></span>
<a name="l00333"></a>00333 <span class="comment">        @ingroup bvector</span>
<a name="l00334"></a>00334 <span class="comment">    */</span>
<a name="l00335"></a><a class="code" href="a00070.html">00335</a>     <span class="keyword">class </span><a class="code" href="a00070.html" title="Output iterator iterator designed to set &amp;quot;ON&amp;quot; bits based on input sequence...">insert_iterator</a>
<a name="l00336"></a>00336     {
<a name="l00337"></a>00337     <span class="keyword">public</span>:
<a name="l00338"></a>00338 <span class="preprocessor">#ifndef BM_NO_STL</span>
<a name="l00339"></a><a class="code" href="a00070.html#ae59e4c0b24ed971e72293cce0e16aafe">00339</a> <span class="preprocessor"></span>        <span class="keyword">typedef</span> std::output_iterator_tag  <a class="code" href="a00070.html#ae59e4c0b24ed971e72293cce0e16aafe">iterator_category</a>;
<a name="l00340"></a>00340 <span class="preprocessor">#endif</span>
<a name="l00341"></a><a class="code" href="a00070.html#adf606f22d2c0d880dc4da0581b6ba8be">00341</a> <span class="preprocessor"></span>        <span class="keyword">typedef</span> <span class="keywordtype">unsigned</span> <a class="code" href="a00070.html#adf606f22d2c0d880dc4da0581b6ba8be">value_type</a>;
<a name="l00342"></a><a class="code" href="a00070.html#a9990131d05b4e9582c0599a265c9dc03">00342</a>         <span class="keyword">typedef</span> <span class="keywordtype">void</span> <a class="code" href="a00070.html#a9990131d05b4e9582c0599a265c9dc03">difference_type</a>;
<a name="l00343"></a><a class="code" href="a00070.html#a305e0040bfb5bd1d2449e8605453f19d">00343</a>         <span class="keyword">typedef</span> <span class="keywordtype">void</span> <a class="code" href="a00070.html#a305e0040bfb5bd1d2449e8605453f19d">pointer</a>;
<a name="l00344"></a><a class="code" href="a00070.html#afaa12a19395698b0e981eec42808d46c">00344</a>         <span class="keyword">typedef</span> <span class="keywordtype">void</span> <a class="code" href="a00080.html" title="Class reference implements an object for bit assignment.">reference</a>;
<a name="l00345"></a>00345 
<a name="l00346"></a><a class="code" href="a00070.html#a33e1229435d0673a5076c05506cd604e">00346</a>         <a class="code" href="a00070.html#a33e1229435d0673a5076c05506cd604e">insert_iterator</a>(<a class="code" href="a00043.html" title="bitvector with runtime compression of bits.">bvector&lt;Alloc&gt;</a>&amp; <a class="code" href="a00043.html" title="bitvector with runtime compression of bits.">bvect</a>)
<a name="l00347"></a>00347             : <a class="code" href="a00070.html#a7e16f0ea4ae995ca5e3f9a9e70fb1df8">bvect_</a>(bvect), 
<a name="l00348"></a>00348               <a class="code" href="a00070.html#a982309066af61349005fefec22d9bf74">max_bit_</a>(bvect.<a class="code" href="a00043.html#aafa3b0f96b317810c2bba976c68ffeb7" title="return current size of the vector (bits)">size</a>())
<a name="l00349"></a>00349         {
<a name="l00350"></a>00350         }
<a name="l00351"></a>00351         
<a name="l00352"></a><a class="code" href="a00070.html#a39a9a79fe81e3bd85a2131c624b75f72">00352</a>         <a class="code" href="a00070.html" title="Output iterator iterator designed to set &amp;quot;ON&amp;quot; bits based on input sequence...">insert_iterator</a>&amp; <a class="code" href="a00070.html#a39a9a79fe81e3bd85a2131c624b75f72">operator=</a>(<a class="code" href="a00115.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a> n)
<a name="l00353"></a>00353         {
<a name="l00354"></a>00354             <a class="code" href="a00092.html#aa44515fab0ace8928d1cb82009a95bf8">BM_ASSERT</a>(n &lt; <a class="code" href="a00115.html#a104b924a1df81542db2a6296fbf26a65">bm::id_max</a>);
<a name="l00355"></a>00355 
<a name="l00356"></a>00356             <span class="keywordflow">if</span> (n &gt;= <a class="code" href="a00070.html#a982309066af61349005fefec22d9bf74">max_bit_</a>) 
<a name="l00357"></a>00357             {
<a name="l00358"></a>00358                 <a class="code" href="a00070.html#a982309066af61349005fefec22d9bf74">max_bit_</a> = n;
<a name="l00359"></a>00359                 <span class="keywordflow">if</span> (n &gt;= <a class="code" href="a00070.html#a7e16f0ea4ae995ca5e3f9a9e70fb1df8">bvect_</a>.size()) 
<a name="l00360"></a>00360                 {
<a name="l00361"></a>00361                     <a class="code" href="a00070.html#a7e16f0ea4ae995ca5e3f9a9e70fb1df8">bvect_</a>.resize(n + 1);
<a name="l00362"></a>00362                 }
<a name="l00363"></a>00363             }
<a name="l00364"></a>00364 
<a name="l00365"></a>00365             <a class="code" href="a00070.html#a7e16f0ea4ae995ca5e3f9a9e70fb1df8">bvect_</a>.set(n);
<a name="l00366"></a>00366             <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00367"></a>00367         }
<a name="l00368"></a>00368         <span class="comment"></span>
<a name="l00369"></a>00369 <span class="comment">        /*! Returns *this without doing anything (no-op) */</span>
<a name="l00370"></a><a class="code" href="a00070.html#a9fa9fabcb7fd5be60e8467b7f0dc9e33">00370</a>         <a class="code" href="a00070.html" title="Output iterator iterator designed to set &amp;quot;ON&amp;quot; bits based on input sequence...">insert_iterator</a>&amp; <a class="code" href="a00070.html#a9fa9fabcb7fd5be60e8467b7f0dc9e33">operator*</a>() { <span class="keywordflow">return</span> *<span class="keyword">this</span>; }<span class="comment"></span>
<a name="l00371"></a>00371 <span class="comment">        /*! Returns *this. This iterator does not move (no-op) */</span>
<a name="l00372"></a><a class="code" href="a00070.html#a97bd8dc3efecf5395ade1af96fe097ec">00372</a>         <a class="code" href="a00070.html" title="Output iterator iterator designed to set &amp;quot;ON&amp;quot; bits based on input sequence...">insert_iterator</a>&amp; <a class="code" href="a00070.html#a97bd8dc3efecf5395ade1af96fe097ec">operator++</a>() { <span class="keywordflow">return</span> *<span class="keyword">this</span>; }<span class="comment"></span>
<a name="l00373"></a>00373 <span class="comment">        /*! Returns *this. This iterator does not move (no-op)*/</span>
<a name="l00374"></a><a class="code" href="a00070.html#a3b163dce82eb9d84ad2857fd16915f88">00374</a>         <a class="code" href="a00070.html" title="Output iterator iterator designed to set &amp;quot;ON&amp;quot; bits based on input sequence...">insert_iterator</a>&amp; <a class="code" href="a00070.html#a3b163dce82eb9d84ad2857fd16915f88">operator++</a>(<span class="keywordtype">int</span>) { <span class="keywordflow">return</span> *<span class="keyword">this</span>; }
<a name="l00375"></a>00375         
<a name="l00376"></a>00376     <span class="keyword">protected</span>:
<a name="l00377"></a><a class="code" href="a00070.html#a7e16f0ea4ae995ca5e3f9a9e70fb1df8">00377</a>         <a class="code" href="a00043.html" title="bitvector with runtime compression of bits.">bm::bvector&lt;Alloc&gt;</a>&amp;   <a class="code" href="a00070.html#a7e16f0ea4ae995ca5e3f9a9e70fb1df8">bvect_</a>;
<a name="l00378"></a><a class="code" href="a00070.html#a982309066af61349005fefec22d9bf74">00378</a>         <a class="code" href="a00115.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a>              <a class="code" href="a00070.html#a982309066af61349005fefec22d9bf74">max_bit_</a>;
<a name="l00379"></a>00379     };
<a name="l00380"></a>00380 <span class="comment"></span>
<a name="l00381"></a>00381 <span class="comment">    /*!</span>
<a name="l00382"></a>00382 <span class="comment">        @brief Constant input iterator designed to enumerate &quot;ON&quot; bits</span>
<a name="l00383"></a>00383 <span class="comment">        @ingroup bvector</span>
<a name="l00384"></a>00384 <span class="comment">    */</span>
<a name="l00385"></a><a class="code" href="a00062.html">00385</a>     <span class="keyword">class </span><a class="code" href="a00062.html" title="Constant input iterator designed to enumerate &amp;quot;ON&amp;quot; bits.">enumerator</a> : <span class="keyword">public</span> <a class="code" href="a00071.html" title="Base class for all iterators.">iterator_base</a>
<a name="l00386"></a>00386     {
<a name="l00387"></a>00387     <span class="keyword">public</span>:
<a name="l00388"></a>00388 <span class="preprocessor">#ifndef BM_NO_STL</span>
<a name="l00389"></a><a class="code" href="a00062.html#a0b4b5de806c2d49c8673c8277ccda469">00389</a> <span class="preprocessor"></span>        <span class="keyword">typedef</span> std::input_iterator_tag  <a class="code" href="a00062.html#a0b4b5de806c2d49c8673c8277ccda469">iterator_category</a>;
<a name="l00390"></a>00390 <span class="preprocessor">#endif</span>
<a name="l00391"></a><a class="code" href="a00062.html#abedb41ab88bc6b5698c3ddb584297804">00391</a> <span class="preprocessor"></span>        <span class="keyword">typedef</span> <span class="keywordtype">unsigned</span>   <a class="code" href="a00062.html#abedb41ab88bc6b5698c3ddb584297804">value_type</a>;
<a name="l00392"></a><a class="code" href="a00062.html#ab2cf2cf9f0086dbc4993259a63ea9887">00392</a>         <span class="keyword">typedef</span> <span class="keywordtype">unsigned</span>   <a class="code" href="a00062.html#ab2cf2cf9f0086dbc4993259a63ea9887">difference_type</a>;
<a name="l00393"></a><a class="code" href="a00062.html#abe79cb4987e5ae6d19d537bc5d1c36eb">00393</a>         <span class="keyword">typedef</span> <span class="keywordtype">unsigned</span>*  <a class="code" href="a00062.html#abe79cb4987e5ae6d19d537bc5d1c36eb">pointer</a>;
<a name="l00394"></a><a class="code" href="a00062.html#a089380ce229f9e0e516fc78d4d3c564c">00394</a>         <span class="keyword">typedef</span> <span class="keywordtype">unsigned</span>&amp;  <a class="code" href="a00080.html" title="Class reference implements an object for bit assignment.">reference</a>;
<a name="l00395"></a>00395 
<a name="l00396"></a>00396     <span class="keyword">public</span>:
<a name="l00397"></a><a class="code" href="a00062.html#a65ece4406a11a16c31910f8723174b35">00397</a>         <a class="code" href="a00062.html#a65ece4406a11a16c31910f8723174b35">enumerator</a>() : <a class="code" href="a00071.html" title="Base class for all iterators.">iterator_base</a>() {}
<a name="l00398"></a><a class="code" href="a00062.html#ae6e5be0e18b3920ff812f6852bf344ae">00398</a>         <a class="code" href="a00062.html#a65ece4406a11a16c31910f8723174b35">enumerator</a>(<span class="keyword">const</span> <a class="code" href="a00043.html" title="bitvector with runtime compression of bits.">bvector&lt;Alloc&gt;</a>* <a class="code" href="a00043.html" title="bitvector with runtime compression of bits.">bvect</a>, <span class="keywordtype">int</span> position)
<a name="l00399"></a>00399             : <a class="code" href="a00071.html" title="Base class for all iterators.">iterator_base</a>()
<a name="l00400"></a>00400         { 
<a name="l00401"></a>00401             this-&gt;<a class="code" href="a00071.html#a9d01206c2a1b6fafc5a74654367b763b" title="Pointer on parent bitvector.">bv_</a> = <span class="keyword">const_cast&lt;</span><a class="code" href="a00043.html" title="bitvector with runtime compression of bits.">bvector&lt;Alloc&gt;</a>*<span class="keyword">&gt;</span>(bvect);
<a name="l00402"></a>00402             <span class="keywordflow">if</span> (position == 0)
<a name="l00403"></a>00403             {
<a name="l00404"></a>00404                 <a class="code" href="a00062.html#ab5f82bf49e4add7708405c067485187a">go_first</a>();
<a name="l00405"></a>00405             }
<a name="l00406"></a>00406             <span class="keywordflow">else</span>
<a name="l00407"></a>00407             {
<a name="l00408"></a>00408                 this-&gt;<a class="code" href="a00071.html#a42f86377bc0e8bcfd8cbace7bac704c1" title="Turns iterator into an invalid state.">invalidate</a>();
<a name="l00409"></a>00409             }
<a name="l00410"></a>00410         }
<a name="l00411"></a>00411 
<a name="l00412"></a><a class="code" href="a00062.html#a356186a7b8c3669328df310d0c9fce27">00412</a>         <a class="code" href="a00115.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a> <a class="code" href="a00062.html#a356186a7b8c3669328df310d0c9fce27">operator*</a>()<span class="keyword"> const</span>
<a name="l00413"></a>00413 <span class="keyword">        </span>{ 
<a name="l00414"></a>00414             <span class="keywordflow">return</span> this-&gt;<a class="code" href="a00071.html#a00d4c7e92f4c22e158c5cd2e83ff0978" title="Bit position (bit idx).">position_</a>; 
<a name="l00415"></a>00415         }
<a name="l00416"></a>00416 
<a name="l00417"></a><a class="code" href="a00062.html#ab4682ff035a2604b5d1c5bb468a71791">00417</a>         <a class="code" href="a00115.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a> <a class="code" href="a00062.html#ab4682ff035a2604b5d1c5bb468a71791">value</a>()<span class="keyword"> const</span>
<a name="l00418"></a>00418 <span class="keyword">        </span>{
<a name="l00419"></a>00419             <span class="keywordflow">return</span> this-&gt;<a class="code" href="a00071.html#a00d4c7e92f4c22e158c5cd2e83ff0978" title="Bit position (bit idx).">position_</a>;
<a name="l00420"></a>00420         }
<a name="l00421"></a>00421 
<a name="l00422"></a><a class="code" href="a00062.html#a7a5fb8afe0333ded5c5af2ee52bd1fda">00422</a>         <a class="code" href="a00062.html" title="Constant input iterator designed to enumerate &amp;quot;ON&amp;quot; bits.">enumerator</a>&amp; <a class="code" href="a00062.html#a7a5fb8afe0333ded5c5af2ee52bd1fda">operator++</a>()
<a name="l00423"></a>00423         {
<a name="l00424"></a>00424             <span class="keywordflow">return</span> this-&gt;<a class="code" href="a00062.html#a19ad94d501d95e65f23cb47f4f356a85">go_up</a>();
<a name="l00425"></a>00425         }
<a name="l00426"></a>00426 
<a name="l00427"></a><a class="code" href="a00062.html#a224769f356182e91182e410c59381e15">00427</a>         <a class="code" href="a00062.html" title="Constant input iterator designed to enumerate &amp;quot;ON&amp;quot; bits.">enumerator</a> <a class="code" href="a00062.html#a7a5fb8afe0333ded5c5af2ee52bd1fda">operator++</a>(<span class="keywordtype">int</span>)
<a name="l00428"></a>00428         {
<a name="l00429"></a>00429             <a class="code" href="a00062.html" title="Constant input iterator designed to enumerate &amp;quot;ON&amp;quot; bits.">enumerator</a> tmp = *<span class="keyword">this</span>;
<a name="l00430"></a>00430             this-&gt;<a class="code" href="a00062.html#a19ad94d501d95e65f23cb47f4f356a85">go_up</a>();
<a name="l00431"></a>00431             <span class="keywordflow">return</span> tmp;
<a name="l00432"></a>00432         }
<a name="l00433"></a>00433 
<a name="l00434"></a>00434 
<a name="l00435"></a><a class="code" href="a00062.html#ab5f82bf49e4add7708405c067485187a">00435</a>         <span class="keywordtype">void</span> <a class="code" href="a00062.html#ab5f82bf49e4add7708405c067485187a">go_first</a>()
<a name="l00436"></a>00436         {
<a name="l00437"></a>00437             <a class="code" href="a00092.html#aa44515fab0ace8928d1cb82009a95bf8">BM_ASSERT</a>(this-&gt;<a class="code" href="a00071.html#a9d01206c2a1b6fafc5a74654367b763b" title="Pointer on parent bitvector.">bv_</a>);
<a name="l00438"></a>00438 
<a name="l00439"></a>00439 <span class="preprocessor">        #ifdef BMCOUNTOPT</span>
<a name="l00440"></a>00440 <span class="preprocessor"></span>            <span class="keywordflow">if</span> (this-&gt;<a class="code" href="a00071.html#a9d01206c2a1b6fafc5a74654367b763b" title="Pointer on parent bitvector.">bv_</a>-&gt;count_is_valid_ &amp;&amp; 
<a name="l00441"></a>00441                 this-&gt;bv_-&gt;count_ == 0)
<a name="l00442"></a>00442             {
<a name="l00443"></a>00443                 this-&gt;<a class="code" href="a00071.html#a42f86377bc0e8bcfd8cbace7bac704c1" title="Turns iterator into an invalid state.">invalidate</a>();
<a name="l00444"></a>00444                 <span class="keywordflow">return</span>;
<a name="l00445"></a>00445             }
<a name="l00446"></a>00446 <span class="preprocessor">        #endif</span>
<a name="l00447"></a>00447 <span class="preprocessor"></span>
<a name="l00448"></a>00448             <a class="code" href="a00043.html#a6fdfeafe05217c31cdc9140b7642b611">blocks_manager_type</a>* bman = &amp;(this-&gt;<a class="code" href="a00071.html#a9d01206c2a1b6fafc5a74654367b763b" title="Pointer on parent bitvector.">bv_</a>-&gt;blockman_);
<a name="l00449"></a>00449             <a class="code" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a>*** blk_root = bman-&gt;blocks_root();
<a name="l00450"></a>00450 
<a name="l00451"></a>00451             this-&gt;<a class="code" href="a00071.html#a3c0a421fe09c6345a822e70e56dd8757" title="Block index.">block_idx_</a> = this-&gt;<a class="code" href="a00071.html#a00d4c7e92f4c22e158c5cd2e83ff0978" title="Bit position (bit idx).">position_</a>= 0;
<a name="l00452"></a>00452             <span class="keywordtype">unsigned</span> i, j;
<a name="l00453"></a>00453 
<a name="l00454"></a>00454             <span class="keywordflow">for</span> (i = 0; i &lt; bman-&gt;top_block_size(); ++i)
<a name="l00455"></a>00455             {
<a name="l00456"></a>00456                 <a class="code" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a>** blk_blk = blk_root[i];
<a name="l00457"></a>00457 
<a name="l00458"></a>00458                 <span class="keywordflow">if</span> (blk_blk == 0) <span class="comment">// not allocated</span>
<a name="l00459"></a>00459                 {
<a name="l00460"></a>00460                     this-&gt;<a class="code" href="a00071.html#a3c0a421fe09c6345a822e70e56dd8757" title="Block index.">block_idx_</a> += <a class="code" href="a00115.html#a40ad34d6c46a2fb20ba2baa7f95d80b4">bm::set_array_size</a>;
<a name="l00461"></a>00461                     this-&gt;<a class="code" href="a00071.html#a00d4c7e92f4c22e158c5cd2e83ff0978" title="Bit position (bit idx).">position_</a> += <a class="code" href="a00115.html#a4dedd13a7b8a27c5067b20118002f025">bm::bits_in_array</a>;
<a name="l00462"></a>00462                     <span class="keywordflow">continue</span>;
<a name="l00463"></a>00463                 }
<a name="l00464"></a>00464 
<a name="l00465"></a>00465 
<a name="l00466"></a>00466                 <span class="keywordflow">for</span> (j = 0; j &lt; <a class="code" href="a00115.html#a40ad34d6c46a2fb20ba2baa7f95d80b4">bm::set_array_size</a>; ++j,++(this-&gt;<a class="code" href="a00071.html#a3c0a421fe09c6345a822e70e56dd8757" title="Block index.">block_idx_</a>))
<a name="l00467"></a>00467                 {
<a name="l00468"></a>00468                     this-&gt;<a class="code" href="a00071.html#abd6a28fb9b028876ef2d4007ac90e52b" title="Block pointer.(NULL-invalid).">block_</a> = blk_blk[j];
<a name="l00469"></a>00469 
<a name="l00470"></a>00470                     <span class="keywordflow">if</span> (this-&gt;<a class="code" href="a00071.html#abd6a28fb9b028876ef2d4007ac90e52b" title="Block pointer.(NULL-invalid).">block_</a> == 0)
<a name="l00471"></a>00471                     {
<a name="l00472"></a>00472                         this-&gt;<a class="code" href="a00071.html#a00d4c7e92f4c22e158c5cd2e83ff0978" title="Bit position (bit idx).">position_</a> += <a class="code" href="a00115.html#ae9916f69ced0347d94472d7944ea0e45">bits_in_block</a>;
<a name="l00473"></a>00473                         <span class="keywordflow">continue</span>;
<a name="l00474"></a>00474                     }
<a name="l00475"></a>00475 
<a name="l00476"></a>00476                     <span class="keywordflow">if</span> (<a class="code" href="a00092.html#a7bc243edc0a5e82979d6bf63f4debb9a">BM_IS_GAP</a>(this-&gt;<a class="code" href="a00071.html#abd6a28fb9b028876ef2d4007ac90e52b" title="Block pointer.(NULL-invalid).">block_</a>))
<a name="l00477"></a>00477                     {
<a name="l00478"></a>00478                         this-&gt;<a class="code" href="a00071.html#a6d7e22a16265c40422bc6c23e64e6d52" title="Type of block. 0-Bit, 1-GAP.">block_type_</a> = 1;
<a name="l00479"></a>00479                         <span class="keywordflow">if</span> (search_in_gapblock())
<a name="l00480"></a>00480                         {
<a name="l00481"></a>00481                             <span class="keywordflow">return</span>;
<a name="l00482"></a>00482                         }
<a name="l00483"></a>00483                     }
<a name="l00484"></a>00484                     <span class="keywordflow">else</span>
<a name="l00485"></a>00485                     {
<a name="l00486"></a>00486                         this-&gt;<a class="code" href="a00071.html#a6d7e22a16265c40422bc6c23e64e6d52" title="Type of block. 0-Bit, 1-GAP.">block_type_</a> = 0;
<a name="l00487"></a>00487                         <span class="keywordflow">if</span> (search_in_bitblock())
<a name="l00488"></a>00488                         {
<a name="l00489"></a>00489                             <span class="keywordflow">return</span>;
<a name="l00490"></a>00490                         }
<a name="l00491"></a>00491                     }
<a name="l00492"></a>00492             
<a name="l00493"></a>00493                 } <span class="comment">// for j</span>
<a name="l00494"></a>00494 
<a name="l00495"></a>00495             } <span class="comment">// for i</span>
<a name="l00496"></a>00496 
<a name="l00497"></a>00497             this-&gt;<a class="code" href="a00071.html#a42f86377bc0e8bcfd8cbace7bac704c1" title="Turns iterator into an invalid state.">invalidate</a>();
<a name="l00498"></a>00498         }
<a name="l00499"></a>00499 
<a name="l00500"></a><a class="code" href="a00062.html#a19ad94d501d95e65f23cb47f4f356a85">00500</a>         <a class="code" href="a00062.html" title="Constant input iterator designed to enumerate &amp;quot;ON&amp;quot; bits.">enumerator</a>&amp; <a class="code" href="a00062.html#a19ad94d501d95e65f23cb47f4f356a85">go_up</a>()
<a name="l00501"></a>00501         {
<a name="l00502"></a>00502             <span class="comment">// Current block search.</span>
<a name="l00503"></a>00503             ++this-&gt;<a class="code" href="a00071.html#a00d4c7e92f4c22e158c5cd2e83ff0978" title="Bit position (bit idx).">position_</a>;
<a name="l00504"></a>00504             <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="a00039.html">iterator_base::block_descr</a> block_descr_type;
<a name="l00505"></a>00505             
<a name="l00506"></a>00506             block_descr_type* bdescr = &amp;(this-&gt;<a class="code" href="a00071.html#abf6c623a56e042c36de5a2d43bb0b065">bdescr_</a>);
<a name="l00507"></a>00507 
<a name="l00508"></a>00508             <span class="keywordflow">switch</span> (this-&gt;<a class="code" href="a00071.html#a6d7e22a16265c40422bc6c23e64e6d52" title="Type of block. 0-Bit, 1-GAP.">block_type_</a>)
<a name="l00509"></a>00509             {
<a name="l00510"></a>00510             <span class="keywordflow">case</span> 0:   <span class="comment">//  BitBlock</span>
<a name="l00511"></a>00511                 {
<a name="l00512"></a>00512 
<a name="l00513"></a>00513                 <span class="comment">// check if we can get the value from the </span>
<a name="l00514"></a>00514                 <span class="comment">// bits cache</span>
<a name="l00515"></a>00515 
<a name="l00516"></a>00516                 <span class="keywordtype">unsigned</span> idx = ++(bdescr-&gt;bit_.idx);
<a name="l00517"></a>00517                 <span class="keywordflow">if</span> (idx &lt; bdescr-&gt;bit_.cnt)
<a name="l00518"></a>00518                 {
<a name="l00519"></a>00519                     this-&gt;<a class="code" href="a00071.html#a00d4c7e92f4c22e158c5cd2e83ff0978" title="Bit position (bit idx).">position_</a> = bdescr-&gt;bit_.pos + 
<a name="l00520"></a>00520                                       bdescr-&gt;bit_.bits[idx];
<a name="l00521"></a>00521                     <span class="keywordflow">return</span> *<span class="keyword">this</span>; 
<a name="l00522"></a>00522                 }
<a name="l00523"></a>00523                 this-&gt;<a class="code" href="a00071.html#a00d4c7e92f4c22e158c5cd2e83ff0978" title="Bit position (bit idx).">position_</a> += 31 - bdescr-&gt;bit_.bits[--idx];
<a name="l00524"></a>00524 
<a name="l00525"></a>00525                 <span class="keyword">const</span> <a class="code" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a>* pend = this-&gt;<a class="code" href="a00071.html#abd6a28fb9b028876ef2d4007ac90e52b" title="Block pointer.(NULL-invalid).">block_</a> + <a class="code" href="a00115.html#a91319dbc0d0e1bf3a3efc4d92bac7972">bm::set_block_size</a>;
<a name="l00526"></a>00526 
<a name="l00527"></a>00527                 <span class="keywordflow">while</span> (++(bdescr-&gt;bit_.ptr) &lt; pend)
<a name="l00528"></a>00528                 {
<a name="l00529"></a>00529                     <a class="code" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> w = *(bdescr-&gt;bit_.ptr);
<a name="l00530"></a>00530                     <span class="keywordflow">if</span> (w)
<a name="l00531"></a>00531                     {
<a name="l00532"></a>00532                         bdescr-&gt;bit_.idx = 0;
<a name="l00533"></a>00533                         bdescr-&gt;bit_.pos = this-&gt;<a class="code" href="a00071.html#a00d4c7e92f4c22e158c5cd2e83ff0978" title="Bit position (bit idx).">position_</a>;
<a name="l00534"></a>00534                         bdescr-&gt;bit_.cnt = <a class="code" href="a00120.html#ga3c81f6bff8866ec3ed0a94903eee96b7" title="Unpacks word into list of ON bit indexes (quad-bit based).">bm::bit_list_4</a>(w, bdescr-&gt;bit_.bits); 
<a name="l00535"></a>00535                         this-&gt;<a class="code" href="a00071.html#a00d4c7e92f4c22e158c5cd2e83ff0978" title="Bit position (bit idx).">position_</a> += bdescr-&gt;bit_.bits[0];
<a name="l00536"></a>00536                         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00537"></a>00537                     }
<a name="l00538"></a>00538                     <span class="keywordflow">else</span>
<a name="l00539"></a>00539                     {
<a name="l00540"></a>00540                         this-&gt;<a class="code" href="a00071.html#a00d4c7e92f4c22e158c5cd2e83ff0978" title="Bit position (bit idx).">position_</a> += 32;
<a name="l00541"></a>00541                     }
<a name="l00542"></a>00542                 }
<a name="l00543"></a>00543     
<a name="l00544"></a>00544                 }
<a name="l00545"></a>00545                 <span class="keywordflow">break</span>;
<a name="l00546"></a>00546 
<a name="l00547"></a>00547             <span class="keywordflow">case</span> 1:   <span class="comment">// DGAP Block</span>
<a name="l00548"></a>00548                 {
<a name="l00549"></a>00549                     <span class="keywordflow">if</span> (--(bdescr-&gt;gap_.gap_len))
<a name="l00550"></a>00550                     {
<a name="l00551"></a>00551                         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00552"></a>00552                     }
<a name="l00553"></a>00553 
<a name="l00554"></a>00554                     <span class="comment">// next gap is &quot;OFF&quot; by definition.</span>
<a name="l00555"></a>00555                     <span class="keywordflow">if</span> (*(bdescr-&gt;gap_.ptr) == <a class="code" href="a00115.html#ad0b8714080144ac70197840ff96752b7">bm::gap_max_bits</a> - 1)
<a name="l00556"></a>00556                     {
<a name="l00557"></a>00557                         <span class="keywordflow">break</span>;
<a name="l00558"></a>00558                     }
<a name="l00559"></a>00559                     <a class="code" href="a00115.html#ac654d6319039a86546d235a236fc7cf6">gap_word_t</a> prev = *(bdescr-&gt;gap_.ptr);
<a name="l00560"></a>00560                     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> val = *(++(bdescr-&gt;gap_.ptr));
<a name="l00561"></a>00561 
<a name="l00562"></a>00562                     this-&gt;<a class="code" href="a00071.html#a00d4c7e92f4c22e158c5cd2e83ff0978" title="Bit position (bit idx).">position_</a> += val - prev;
<a name="l00563"></a>00563                     <span class="comment">// next gap is now &quot;ON&quot;</span>
<a name="l00564"></a>00564 
<a name="l00565"></a>00565                     <span class="keywordflow">if</span> (*(bdescr-&gt;gap_.ptr) == <a class="code" href="a00115.html#ad0b8714080144ac70197840ff96752b7">bm::gap_max_bits</a> - 1)
<a name="l00566"></a>00566                     {
<a name="l00567"></a>00567                         <span class="keywordflow">break</span>;
<a name="l00568"></a>00568                     }
<a name="l00569"></a>00569                     prev = *(bdescr-&gt;gap_.ptr);
<a name="l00570"></a>00570                     val = *(++(bdescr-&gt;gap_.ptr));
<a name="l00571"></a>00571                     bdescr-&gt;gap_.gap_len = (<a class="code" href="a00115.html#ac654d6319039a86546d235a236fc7cf6">gap_word_t</a>)val - prev;
<a name="l00572"></a>00572                     <span class="keywordflow">return</span> *<span class="keyword">this</span>;  <span class="comment">// next &quot;ON&quot; found;</span>
<a name="l00573"></a>00573                 }
<a name="l00574"></a>00574 
<a name="l00575"></a>00575             <span class="keywordflow">default</span>:
<a name="l00576"></a>00576                 <a class="code" href="a00092.html#aa44515fab0ace8928d1cb82009a95bf8">BM_ASSERT</a>(0);
<a name="l00577"></a>00577 
<a name="l00578"></a>00578             } <span class="comment">// switch</span>
<a name="l00579"></a>00579 
<a name="l00580"></a>00580 
<a name="l00581"></a>00581             <span class="comment">// next bit not present in the current block</span>
<a name="l00582"></a>00582             <span class="comment">// keep looking in the next blocks.</span>
<a name="l00583"></a>00583             ++(this-&gt;<a class="code" href="a00071.html#a3c0a421fe09c6345a822e70e56dd8757" title="Block index.">block_idx_</a>);
<a name="l00584"></a>00584             <span class="keywordtype">unsigned</span> i = this-&gt;<a class="code" href="a00071.html#a3c0a421fe09c6345a822e70e56dd8757" title="Block index.">block_idx_</a> &gt;&gt; <a class="code" href="a00115.html#ac1ff8647a089c751ec330cecee01907e">bm::set_array_shift</a>;
<a name="l00585"></a>00585             <span class="keywordtype">unsigned</span> top_block_size = this-&gt;<a class="code" href="a00071.html#a9d01206c2a1b6fafc5a74654367b763b" title="Pointer on parent bitvector.">bv_</a>-&gt;blockman_.top_block_size();
<a name="l00586"></a>00586             <span class="keywordflow">for</span> (; i &lt; top_block_size; ++i)
<a name="l00587"></a>00587             {
<a name="l00588"></a>00588                 <a class="code" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a>** blk_blk = this-&gt;<a class="code" href="a00071.html#a9d01206c2a1b6fafc5a74654367b763b" title="Pointer on parent bitvector.">bv_</a>-&gt;blockman_.blocks_root()[i];
<a name="l00589"></a>00589                 <span class="keywordflow">if</span> (blk_blk == 0)
<a name="l00590"></a>00590                 {
<a name="l00591"></a>00591                     this-&gt;<a class="code" href="a00071.html#a3c0a421fe09c6345a822e70e56dd8757" title="Block index.">block_idx_</a> += <a class="code" href="a00115.html#a40ad34d6c46a2fb20ba2baa7f95d80b4">bm::set_array_size</a>;
<a name="l00592"></a>00592                     this-&gt;<a class="code" href="a00071.html#a00d4c7e92f4c22e158c5cd2e83ff0978" title="Bit position (bit idx).">position_</a> += <a class="code" href="a00115.html#a4dedd13a7b8a27c5067b20118002f025">bm::bits_in_array</a>;
<a name="l00593"></a>00593                     <span class="keywordflow">continue</span>;
<a name="l00594"></a>00594                 }
<a name="l00595"></a>00595 
<a name="l00596"></a>00596                 <span class="keywordtype">unsigned</span> j = this-&gt;<a class="code" href="a00071.html#a3c0a421fe09c6345a822e70e56dd8757" title="Block index.">block_idx_</a> &amp; <a class="code" href="a00115.html#a00ffa7b38d7fcc7e522d864991a6de68">bm::set_array_mask</a>;
<a name="l00597"></a>00597 
<a name="l00598"></a>00598                 <span class="keywordflow">for</span>(; j &lt; <a class="code" href="a00115.html#a40ad34d6c46a2fb20ba2baa7f95d80b4">bm::set_array_size</a>; ++j, ++(this-&gt;<a class="code" href="a00071.html#a3c0a421fe09c6345a822e70e56dd8757" title="Block index.">block_idx_</a>))
<a name="l00599"></a>00599                 {
<a name="l00600"></a>00600                     this-&gt;<a class="code" href="a00071.html#abd6a28fb9b028876ef2d4007ac90e52b" title="Block pointer.(NULL-invalid).">block_</a> = blk_blk[j];
<a name="l00601"></a>00601 
<a name="l00602"></a>00602                     <span class="keywordflow">if</span> (this-&gt;<a class="code" href="a00071.html#abd6a28fb9b028876ef2d4007ac90e52b" title="Block pointer.(NULL-invalid).">block_</a> == 0)
<a name="l00603"></a>00603                     {
<a name="l00604"></a>00604                         this-&gt;<a class="code" href="a00071.html#a00d4c7e92f4c22e158c5cd2e83ff0978" title="Bit position (bit idx).">position_</a> += <a class="code" href="a00115.html#ae9916f69ced0347d94472d7944ea0e45">bm::bits_in_block</a>;
<a name="l00605"></a>00605                         <span class="keywordflow">continue</span>;
<a name="l00606"></a>00606                     }
<a name="l00607"></a>00607 
<a name="l00608"></a>00608                     <span class="keywordflow">if</span> (<a class="code" href="a00092.html#a7bc243edc0a5e82979d6bf63f4debb9a">BM_IS_GAP</a>(this-&gt;<a class="code" href="a00071.html#abd6a28fb9b028876ef2d4007ac90e52b" title="Block pointer.(NULL-invalid).">block_</a>))
<a name="l00609"></a>00609                     {
<a name="l00610"></a>00610                         this-&gt;<a class="code" href="a00071.html#a6d7e22a16265c40422bc6c23e64e6d52" title="Type of block. 0-Bit, 1-GAP.">block_type_</a> = 1;
<a name="l00611"></a>00611                         <span class="keywordflow">if</span> (search_in_gapblock())
<a name="l00612"></a>00612                         {
<a name="l00613"></a>00613                             <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00614"></a>00614                         }
<a name="l00615"></a>00615                     }
<a name="l00616"></a>00616                     <span class="keywordflow">else</span>
<a name="l00617"></a>00617                     {
<a name="l00618"></a>00618                         this-&gt;<a class="code" href="a00071.html#a6d7e22a16265c40422bc6c23e64e6d52" title="Type of block. 0-Bit, 1-GAP.">block_type_</a> = 0;
<a name="l00619"></a>00619                         <span class="keywordflow">if</span> (search_in_bitblock())
<a name="l00620"></a>00620                         {
<a name="l00621"></a>00621                             <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00622"></a>00622                         }
<a name="l00623"></a>00623                     }
<a name="l00624"></a>00624 
<a name="l00625"></a>00625             
<a name="l00626"></a>00626                 } <span class="comment">// for j</span>
<a name="l00627"></a>00627 
<a name="l00628"></a>00628             } <span class="comment">// for i</span>
<a name="l00629"></a>00629 
<a name="l00630"></a>00630 
<a name="l00631"></a>00631             this-&gt;<a class="code" href="a00071.html#a42f86377bc0e8bcfd8cbace7bac704c1" title="Turns iterator into an invalid state.">invalidate</a>();
<a name="l00632"></a>00632             <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00633"></a>00633         }
<a name="l00634"></a>00634 
<a name="l00635"></a>00635 
<a name="l00636"></a>00636     <span class="keyword">private</span>:
<a name="l00637"></a>00637         <span class="keywordtype">bool</span> search_in_bitblock()
<a name="l00638"></a>00638         {
<a name="l00639"></a>00639             <a class="code" href="a00092.html#aa44515fab0ace8928d1cb82009a95bf8">BM_ASSERT</a>(this-&gt;<a class="code" href="a00071.html#a6d7e22a16265c40422bc6c23e64e6d52" title="Type of block. 0-Bit, 1-GAP.">block_type_</a> == 0);
<a name="l00640"></a>00640             
<a name="l00641"></a>00641             <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="a00039.html">iterator_base::block_descr</a> block_descr_type;
<a name="l00642"></a>00642             block_descr_type* bdescr = &amp;(this-&gt;<a class="code" href="a00071.html#abf6c623a56e042c36de5a2d43bb0b065">bdescr_</a>);            
<a name="l00643"></a>00643 
<a name="l00644"></a>00644             <span class="comment">// now lets find the first bit in block.</span>
<a name="l00645"></a>00645             bdescr-&gt;bit_.ptr = this-&gt;<a class="code" href="a00071.html#abd6a28fb9b028876ef2d4007ac90e52b" title="Block pointer.(NULL-invalid).">block_</a>;
<a name="l00646"></a>00646 
<a name="l00647"></a>00647             <span class="keyword">const</span> <a class="code" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">word_t</a>* ptr_end = this-&gt;<a class="code" href="a00071.html#abd6a28fb9b028876ef2d4007ac90e52b" title="Block pointer.(NULL-invalid).">block_</a> + <a class="code" href="a00115.html#a91319dbc0d0e1bf3a3efc4d92bac7972">bm::set_block_size</a>;
<a name="l00648"></a>00648 
<a name="l00649"></a>00649             <span class="keywordflow">do</span>
<a name="l00650"></a>00650             {
<a name="l00651"></a>00651                 <span class="keyword">register</span> <a class="code" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> w = *(bdescr-&gt;bit_.ptr);
<a name="l00652"></a>00652 
<a name="l00653"></a>00653                 <span class="keywordflow">if</span> (w)  
<a name="l00654"></a>00654                 {
<a name="l00655"></a>00655                     bdescr-&gt;bit_.idx = 0;
<a name="l00656"></a>00656                     bdescr-&gt;bit_.pos = this-&gt;<a class="code" href="a00071.html#a00d4c7e92f4c22e158c5cd2e83ff0978" title="Bit position (bit idx).">position_</a>;
<a name="l00657"></a>00657                     bdescr-&gt;bit_.cnt = 
<a name="l00658"></a>00658                               <a class="code" href="a00120.html#ga3c81f6bff8866ec3ed0a94903eee96b7" title="Unpacks word into list of ON bit indexes (quad-bit based).">bm::bit_list_4</a>(w, bdescr-&gt;bit_.bits);
<a name="l00659"></a>00659                     this-&gt;<a class="code" href="a00071.html#a00d4c7e92f4c22e158c5cd2e83ff0978" title="Bit position (bit idx).">position_</a> += bdescr-&gt;bit_.bits[0];
<a name="l00660"></a>00660 
<a name="l00661"></a>00661                     <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00662"></a>00662                 }
<a name="l00663"></a>00663                 <span class="keywordflow">else</span>
<a name="l00664"></a>00664                 {
<a name="l00665"></a>00665                     this-&gt;<a class="code" href="a00071.html#a00d4c7e92f4c22e158c5cd2e83ff0978" title="Bit position (bit idx).">position_</a> += 32;
<a name="l00666"></a>00666                 }
<a name="l00667"></a>00667 
<a name="l00668"></a>00668             } 
<a name="l00669"></a>00669             <span class="keywordflow">while</span> (++(bdescr-&gt;bit_.ptr) &lt; ptr_end);
<a name="l00670"></a>00670 
<a name="l00671"></a>00671             <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00672"></a>00672         }
<a name="l00673"></a>00673 
<a name="l00674"></a>00674         <span class="keywordtype">bool</span> search_in_gapblock()
<a name="l00675"></a>00675         {
<a name="l00676"></a>00676             <a class="code" href="a00092.html#aa44515fab0ace8928d1cb82009a95bf8">BM_ASSERT</a>(this-&gt;<a class="code" href="a00071.html#a6d7e22a16265c40422bc6c23e64e6d52" title="Type of block. 0-Bit, 1-GAP.">block_type_</a> == 1);
<a name="l00677"></a>00677 
<a name="l00678"></a>00678             <span class="keyword">typedef</span> <span class="keyword">typename</span> iterator_base::block_descr block_descr_type;
<a name="l00679"></a>00679             block_descr_type* bdescr = &amp;(this-&gt;<a class="code" href="a00071.html#abf6c623a56e042c36de5a2d43bb0b065">bdescr_</a>);            
<a name="l00680"></a>00680 
<a name="l00681"></a>00681             bdescr-&gt;gap_.ptr = <a class="code" href="a00092.html#a6a7c8b8ee3f3b60ab907c1699acb7aa0">BMGAP_PTR</a>(this-&gt;<a class="code" href="a00071.html#abd6a28fb9b028876ef2d4007ac90e52b" title="Block pointer.(NULL-invalid).">block_</a>);
<a name="l00682"></a>00682             <span class="keywordtype">unsigned</span> bitval = *(bdescr-&gt;gap_.ptr) &amp; 1;
<a name="l00683"></a>00683 
<a name="l00684"></a>00684             ++(bdescr-&gt;gap_.ptr);
<a name="l00685"></a>00685 
<a name="l00686"></a>00686             <span class="keywordflow">for</span> (;<span class="keyword">true</span>;)
<a name="l00687"></a>00687             {
<a name="l00688"></a>00688                 <span class="keyword">register</span> <span class="keywordtype">unsigned</span> val = *(bdescr-&gt;gap_.ptr);
<a name="l00689"></a>00689 
<a name="l00690"></a>00690                 <span class="keywordflow">if</span> (bitval)
<a name="l00691"></a>00691                 {
<a name="l00692"></a>00692                     <a class="code" href="a00115.html#ac654d6319039a86546d235a236fc7cf6">gap_word_t</a>* <a class="code" href="a00043.html#ae19358b9022b2a870c4fa151dbf92a01" title="Returns enumerator pointing on the first non-zero bit.">first</a> = <a class="code" href="a00092.html#a6a7c8b8ee3f3b60ab907c1699acb7aa0">BMGAP_PTR</a>(this-&gt;<a class="code" href="a00071.html#abd6a28fb9b028876ef2d4007ac90e52b" title="Block pointer.(NULL-invalid).">block_</a>) + 1;
<a name="l00693"></a>00693                     <span class="keywordflow">if</span> (bdescr-&gt;gap_.ptr == first)
<a name="l00694"></a>00694                     {
<a name="l00695"></a>00695                         bdescr-&gt;gap_.gap_len = (<a class="code" href="a00115.html#ac654d6319039a86546d235a236fc7cf6">gap_word_t</a>)val + 1;
<a name="l00696"></a>00696                     }
<a name="l00697"></a>00697                     <span class="keywordflow">else</span>
<a name="l00698"></a>00698                     {
<a name="l00699"></a>00699                         bdescr-&gt;gap_.gap_len = 
<a name="l00700"></a>00700                              (<a class="code" href="a00115.html#ac654d6319039a86546d235a236fc7cf6">gap_word_t</a>)(val - *(bdescr-&gt;gap_.ptr-1));
<a name="l00701"></a>00701                     }
<a name="l00702"></a>00702            
<a name="l00703"></a>00703                     <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00704"></a>00704                 }
<a name="l00705"></a>00705                 this-&gt;<a class="code" href="a00071.html#a00d4c7e92f4c22e158c5cd2e83ff0978" title="Bit position (bit idx).">position_</a> += val + 1;
<a name="l00706"></a>00706 
<a name="l00707"></a>00707                 <span class="keywordflow">if</span> (val == <a class="code" href="a00115.html#ad0b8714080144ac70197840ff96752b7">bm::gap_max_bits</a> - 1)
<a name="l00708"></a>00708                 {
<a name="l00709"></a>00709                     <span class="keywordflow">break</span>;
<a name="l00710"></a>00710                 }
<a name="l00711"></a>00711 
<a name="l00712"></a>00712                 bitval ^= 1;
<a name="l00713"></a>00713                 ++(bdescr-&gt;gap_.ptr);
<a name="l00714"></a>00714 
<a name="l00715"></a>00715             }
<a name="l00716"></a>00716 
<a name="l00717"></a>00717             <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00718"></a>00718         }
<a name="l00719"></a>00719 
<a name="l00720"></a>00720     };
<a name="l00721"></a>00721     <span class="comment"></span>
<a name="l00722"></a>00722 <span class="comment">    /*!</span>
<a name="l00723"></a>00723 <span class="comment">        @brief Constant input iterator designed to enumerate &quot;ON&quot; bits</span>
<a name="l00724"></a>00724 <span class="comment">        counted_enumerator keeps bitcount, ie number of ON bits starting</span>
<a name="l00725"></a>00725 <span class="comment">        from the position 0 in the bit string up to the currently enumerated bit</span>
<a name="l00726"></a>00726 <span class="comment">        </span>
<a name="l00727"></a>00727 <span class="comment">        When increment operator called current position is increased by 1.</span>
<a name="l00728"></a>00728 <span class="comment">        </span>
<a name="l00729"></a>00729 <span class="comment">        @ingroup bvector</span>
<a name="l00730"></a>00730 <span class="comment">    */</span>
<a name="l00731"></a><a class="code" href="a00048.html">00731</a>     <span class="keyword">class </span><a class="code" href="a00048.html" title="Constant input iterator designed to enumerate &amp;quot;ON&amp;quot; bits counted_enumerator...">counted_enumerator</a> : <span class="keyword">public</span> <a class="code" href="a00062.html" title="Constant input iterator designed to enumerate &amp;quot;ON&amp;quot; bits.">enumerator</a>
<a name="l00732"></a>00732     {
<a name="l00733"></a>00733     <span class="keyword">public</span>:
<a name="l00734"></a>00734 <span class="preprocessor">#ifndef BM_NO_STL</span>
<a name="l00735"></a><a class="code" href="a00048.html#a81737a48b642224674e334f6652a70f9">00735</a> <span class="preprocessor"></span>        <span class="keyword">typedef</span> std::input_iterator_tag  <a class="code" href="a00048.html#a81737a48b642224674e334f6652a70f9">iterator_category</a>;
<a name="l00736"></a>00736 <span class="preprocessor">#endif</span>
<a name="l00737"></a><a class="code" href="a00048.html#aeb84baae4a271769e47982b2a5433f81">00737</a> <span class="preprocessor"></span>        <a class="code" href="a00048.html#aeb84baae4a271769e47982b2a5433f81">counted_enumerator</a>() : bit_count_(0){}
<a name="l00738"></a>00738         
<a name="l00739"></a><a class="code" href="a00048.html#ad8fa38a5522ae60c43c870726655e65b">00739</a>         <a class="code" href="a00048.html#aeb84baae4a271769e47982b2a5433f81">counted_enumerator</a>(<span class="keyword">const</span> <a class="code" href="a00062.html" title="Constant input iterator designed to enumerate &amp;quot;ON&amp;quot; bits.">enumerator</a>&amp; en)
<a name="l00740"></a>00740         : <a class="code" href="a00062.html" title="Constant input iterator designed to enumerate &amp;quot;ON&amp;quot; bits.">enumerator</a>(en)
<a name="l00741"></a>00741         {
<a name="l00742"></a>00742             <span class="keywordflow">if</span> (this-&gt;<a class="code" href="a00071.html#a244f7a540f602fc7b58e7efd3f7792a3" title="Checks if iterator is still valid.">valid</a>())
<a name="l00743"></a>00743                 bit_count_ = 1;
<a name="l00744"></a>00744         }
<a name="l00745"></a>00745         
<a name="l00746"></a><a class="code" href="a00048.html#aec0af117dedc5c145265e1416867c3b8">00746</a>         <a class="code" href="a00048.html" title="Constant input iterator designed to enumerate &amp;quot;ON&amp;quot; bits counted_enumerator...">counted_enumerator</a>&amp; <a class="code" href="a00048.html#aec0af117dedc5c145265e1416867c3b8">operator=</a>(<span class="keyword">const</span> <a class="code" href="a00062.html" title="Constant input iterator designed to enumerate &amp;quot;ON&amp;quot; bits.">enumerator</a>&amp; en)
<a name="l00747"></a>00747         {
<a name="l00748"></a>00748             <a class="code" href="a00062.html" title="Constant input iterator designed to enumerate &amp;quot;ON&amp;quot; bits.">enumerator</a>* me = <span class="keyword">this</span>;
<a name="l00749"></a>00749             *me = en;
<a name="l00750"></a>00750             <span class="keywordflow">if</span> (this-&gt;<a class="code" href="a00071.html#a244f7a540f602fc7b58e7efd3f7792a3" title="Checks if iterator is still valid.">valid</a>())
<a name="l00751"></a>00751                 this-&gt;bit_count_ = 1;
<a name="l00752"></a>00752             <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00753"></a>00753         }
<a name="l00754"></a>00754         
<a name="l00755"></a><a class="code" href="a00048.html#a96373b318286b3a5174ba0feeb5a3a2d">00755</a>         <a class="code" href="a00048.html" title="Constant input iterator designed to enumerate &amp;quot;ON&amp;quot; bits counted_enumerator...">counted_enumerator</a>&amp; <a class="code" href="a00048.html#a96373b318286b3a5174ba0feeb5a3a2d">operator++</a>()
<a name="l00756"></a>00756         {
<a name="l00757"></a>00757             this-&gt;<a class="code" href="a00062.html#a19ad94d501d95e65f23cb47f4f356a85">go_up</a>();
<a name="l00758"></a>00758             <span class="keywordflow">if</span> (this-&gt;<a class="code" href="a00071.html#a244f7a540f602fc7b58e7efd3f7792a3" title="Checks if iterator is still valid.">valid</a>())
<a name="l00759"></a>00759                 ++(this-&gt;bit_count_);
<a name="l00760"></a>00760             <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00761"></a>00761         }
<a name="l00762"></a>00762 
<a name="l00763"></a><a class="code" href="a00048.html#a4a9bc8c9aa843835820514da9fe3fc42">00763</a>         <a class="code" href="a00048.html" title="Constant input iterator designed to enumerate &amp;quot;ON&amp;quot; bits counted_enumerator...">counted_enumerator</a> <a class="code" href="a00048.html#a96373b318286b3a5174ba0feeb5a3a2d">operator++</a>(<span class="keywordtype">int</span>)
<a name="l00764"></a>00764         {
<a name="l00765"></a>00765             <a class="code" href="a00048.html" title="Constant input iterator designed to enumerate &amp;quot;ON&amp;quot; bits counted_enumerator...">counted_enumerator</a> tmp(*<span class="keyword">this</span>);
<a name="l00766"></a>00766             this-&gt;<a class="code" href="a00062.html#a19ad94d501d95e65f23cb47f4f356a85">go_up</a>();
<a name="l00767"></a>00767             <span class="keywordflow">if</span> (this-&gt;<a class="code" href="a00071.html#a244f7a540f602fc7b58e7efd3f7792a3" title="Checks if iterator is still valid.">valid</a>())
<a name="l00768"></a>00768                 ++bit_count_;
<a name="l00769"></a>00769             <span class="keywordflow">return</span> tmp;
<a name="l00770"></a>00770         }
<a name="l00771"></a>00771         <span class="comment"></span>
<a name="l00772"></a>00772 <span class="comment">        /*! @brief Number of bits ON starting from the .</span>
<a name="l00773"></a>00773 <span class="comment">        </span>
<a name="l00774"></a>00774 <span class="comment">            Method returns number of ON bits fromn the bit 0 to the current bit </span>
<a name="l00775"></a>00775 <span class="comment">            For the first bit in bitvector it is 1, for the second 2 </span>
<a name="l00776"></a>00776 <span class="comment">        */</span>
<a name="l00777"></a><a class="code" href="a00048.html#a7231556d77bdbb3ff9a290b56ed94002">00777</a>         <a class="code" href="a00115.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a> <a class="code" href="a00048.html#a7231556d77bdbb3ff9a290b56ed94002" title="Number of bits ON starting from the .">count</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> bit_count_; }
<a name="l00778"></a>00778         
<a name="l00779"></a>00779     <span class="keyword">private</span>:
<a name="l00780"></a>00780         <a class="code" href="a00115.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a>   bit_count_;
<a name="l00781"></a>00781     };
<a name="l00782"></a>00782 
<a name="l00783"></a><a class="code" href="a00043.html#aeec1461fca400b5b4313765eb9e94c73">00783</a>     <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="a00071.html" title="Base class for all iterators.">iterator_base</a>;
<a name="l00784"></a><a class="code" href="a00043.html#a71cabca9670588878381f72d16e059b8">00784</a>     <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="a00062.html" title="Constant input iterator designed to enumerate &amp;quot;ON&amp;quot; bits.">enumerator</a>;
<a name="l00785"></a>00785 
<a name="l00786"></a>00786 <span class="keyword">public</span>:
<a name="l00787"></a>00787 
<a name="l00788"></a>00788 <span class="preprocessor">#ifdef BMCOUNTOPT</span>
<a name="l00789"></a>00789 <span class="preprocessor"></span>    <a class="code" href="a00043.html#a159e3c2cb32e6d098eddd9d1eac21c88" title="Constructs bvector class.">bvector</a>(<a class="code" href="a00118.html#gad0b87b3b7292383a864d27feaf1c9eff" title="Block allocation strategies.">strategy</a>          strat      = <a class="code" href="a00118.html#ggad0b87b3b7292383a864d27feaf1c9effa40920ae0ef7b4411d60463d8f576b5ba" title="No GAP compression strategy. All new blocks are bit blocks.">BM_BIT</a>,
<a name="l00790"></a>00790             <span class="keyword">const</span> <a class="code" href="a00115.html#ac654d6319039a86546d235a236fc7cf6">gap_word_t</a>* glevel_len = <a class="code" href="a00066.html" title="Default GAP lengths table.">bm::gap_len_table&lt;true&gt;::_len</a>,
<a name="l00791"></a>00791             <a class="code" href="a00043.html#a405dd9ed048c935c84a5086ec8ba3649" title="Type used to count bits in the bit vector.">size_type</a>         bv_size    = <a class="code" href="a00115.html#a104b924a1df81542db2a6296fbf26a65">bm::id_max</a>,
<a name="l00792"></a>00792             <span class="keyword">const</span> Alloc&amp;      alloc      = Alloc()) 
<a name="l00793"></a>00793     : count_(0),
<a name="l00794"></a>00794       count_is_valid_(true),
<a name="l00795"></a>00795       blockman_(glevel_len, bv_size, alloc),
<a name="l00796"></a>00796       new_blocks_strat_(strat),
<a name="l00797"></a>00797       size_(bv_size)
<a name="l00798"></a>00798     {}
<a name="l00799"></a>00799 
<a name="l00800"></a>00800     <a class="code" href="a00043.html#a159e3c2cb32e6d098eddd9d1eac21c88" title="Constructs bvector class.">bvector</a>(<a class="code" href="a00043.html#a405dd9ed048c935c84a5086ec8ba3649" title="Type used to count bits in the bit vector.">size_type</a>         bv_size,
<a name="l00801"></a>00801             <a class="code" href="a00118.html#gad0b87b3b7292383a864d27feaf1c9eff" title="Block allocation strategies.">bm::strategy</a>      strat      = <a class="code" href="a00118.html#ggad0b87b3b7292383a864d27feaf1c9effa40920ae0ef7b4411d60463d8f576b5ba" title="No GAP compression strategy. All new blocks are bit blocks.">BM_BIT</a>,
<a name="l00802"></a>00802             <span class="keyword">const</span> <a class="code" href="a00115.html#ac654d6319039a86546d235a236fc7cf6">gap_word_t</a>* glevel_len = <a class="code" href="a00066.html" title="Default GAP lengths table.">bm::gap_len_table&lt;true&gt;::_len</a>,
<a name="l00803"></a>00803             <span class="keyword">const</span> Alloc&amp;      alloc = Alloc()) 
<a name="l00804"></a>00804     : count_(0),
<a name="l00805"></a>00805       count_is_valid_(true),
<a name="l00806"></a>00806       blockman_(glevel_len, bv_size, alloc),
<a name="l00807"></a>00807       new_blocks_strat_(strat),
<a name="l00808"></a>00808       size_(bv_size)
<a name="l00809"></a>00809     {}
<a name="l00810"></a>00810 
<a name="l00811"></a>00811 
<a name="l00812"></a>00812     <a class="code" href="a00043.html#a159e3c2cb32e6d098eddd9d1eac21c88" title="Constructs bvector class.">bvector</a>(<span class="keyword">const</span> <a class="code" href="a00043.html" title="bitvector with runtime compression of bits.">bm::bvector&lt;Alloc&gt;</a>&amp; <a class="code" href="a00043.html" title="bitvector with runtime compression of bits.">bvect</a>)
<a name="l00813"></a>00813      : count_(bvect.count_),
<a name="l00814"></a>00814        count_is_valid_(bvect.count_is_valid_),
<a name="l00815"></a>00815        blockman_(bvect.blockman_),
<a name="l00816"></a>00816        new_blocks_strat_(bvect.new_blocks_strat_),
<a name="l00817"></a>00817        size_(bvect.size_)
<a name="l00818"></a>00818     {}
<a name="l00819"></a>00819 
<a name="l00820"></a>00820 <span class="preprocessor">#else</span>
<a name="l00821"></a>00821 <span class="preprocessor"></span><span class="comment">    /*!</span>
<a name="l00822"></a>00822 <span class="comment">        \brief Constructs bvector class</span>
<a name="l00823"></a>00823 <span class="comment">        \param strat - operation mode strategy, </span>
<a name="l00824"></a>00824 <span class="comment">                       BM_BIT - default strategy, bvector use plain bitset </span>
<a name="l00825"></a>00825 <span class="comment">                       blocks, (performance oriented strategy).</span>
<a name="l00826"></a>00826 <span class="comment">                       BM_GAP - memory effitent strategy, bvector allocates </span>
<a name="l00827"></a>00827 <span class="comment">                       blocks as array of intervals(gaps) and convert blocks </span>
<a name="l00828"></a>00828 <span class="comment">                       into plain bitsets only when enthropy grows.</span>
<a name="l00829"></a>00829 <span class="comment">        \param glevel_len </span>
<a name="l00830"></a>00830 <span class="comment">           - pointer on C-style array keeping GAP block sizes. </span>
<a name="l00831"></a>00831 <span class="comment">            (Put bm::gap_len_table_min&lt;true&gt;::_len for GAP memory saving mode)</span>
<a name="l00832"></a>00832 <span class="comment">        \param bv_size </span>
<a name="l00833"></a>00833 <span class="comment">          - bvector size (number of bits addressable by bvector), bm::id_max means </span>
<a name="l00834"></a>00834 <span class="comment">          &quot;no limits&quot; (recommended). </span>
<a name="l00835"></a>00835 <span class="comment">          bit vector allocates this space dynamically on demand.</span>
<a name="l00836"></a>00836 <span class="comment"></span>
<a name="l00837"></a>00837 <span class="comment">        \sa bm::gap_len_table bm::gap_len_table_min set_new_blocks_strat</span>
<a name="l00838"></a>00838 <span class="comment">    */</span>
<a name="l00839"></a><a class="code" href="a00043.html#a159e3c2cb32e6d098eddd9d1eac21c88">00839</a>     <a class="code" href="a00043.html#a159e3c2cb32e6d098eddd9d1eac21c88" title="Constructs bvector class.">bvector</a>(<a class="code" href="a00118.html#gad0b87b3b7292383a864d27feaf1c9eff" title="Block allocation strategies.">strategy</a>          strat      = <a class="code" href="a00118.html#ggad0b87b3b7292383a864d27feaf1c9effa40920ae0ef7b4411d60463d8f576b5ba" title="No GAP compression strategy. All new blocks are bit blocks.">BM_BIT</a>,
<a name="l00840"></a>00840             <span class="keyword">const</span> <a class="code" href="a00115.html#ac654d6319039a86546d235a236fc7cf6">gap_word_t</a>* glevel_len = <a class="code" href="a00066.html" title="Default GAP lengths table.">bm::gap_len_table&lt;true&gt;::_len</a>,
<a name="l00841"></a>00841             <a class="code" href="a00043.html#a405dd9ed048c935c84a5086ec8ba3649" title="Type used to count bits in the bit vector.">size_type</a>         bv_size    = <a class="code" href="a00115.html#a104b924a1df81542db2a6296fbf26a65">bm::id_max</a>,
<a name="l00842"></a>00842             <span class="keyword">const</span> Alloc&amp;      alloc      = Alloc()) 
<a name="l00843"></a>00843     : blockman_(glevel_len, bv_size, alloc),
<a name="l00844"></a>00844       new_blocks_strat_(strat),
<a name="l00845"></a>00845       size_(bv_size)
<a name="l00846"></a>00846     {}
<a name="l00847"></a>00847 <span class="comment"></span>
<a name="l00848"></a>00848 <span class="comment">    /*!</span>
<a name="l00849"></a>00849 <span class="comment">        \brief Constructs bvector class</span>
<a name="l00850"></a>00850 <span class="comment">    */</span>
<a name="l00851"></a><a class="code" href="a00043.html#ae54e579bdddadece60dcfa519d18a1c5">00851</a>     <a class="code" href="a00043.html#a159e3c2cb32e6d098eddd9d1eac21c88" title="Constructs bvector class.">bvector</a>(<a class="code" href="a00043.html#a405dd9ed048c935c84a5086ec8ba3649" title="Type used to count bits in the bit vector.">size_type</a>         bv_size,
<a name="l00852"></a>00852             <a class="code" href="a00118.html#gad0b87b3b7292383a864d27feaf1c9eff" title="Block allocation strategies.">strategy</a>          strat      = <a class="code" href="a00118.html#ggad0b87b3b7292383a864d27feaf1c9effa40920ae0ef7b4411d60463d8f576b5ba" title="No GAP compression strategy. All new blocks are bit blocks.">BM_BIT</a>,
<a name="l00853"></a>00853             <span class="keyword">const</span> <a class="code" href="a00115.html#ac654d6319039a86546d235a236fc7cf6">gap_word_t</a>* glevel_len = <a class="code" href="a00066.html" title="Default GAP lengths table.">bm::gap_len_table&lt;true&gt;::_len</a>,
<a name="l00854"></a>00854             <span class="keyword">const</span> Alloc&amp;      alloc      = Alloc()) 
<a name="l00855"></a>00855     : blockman_(glevel_len, bv_size, alloc),
<a name="l00856"></a>00856       new_blocks_strat_(strat),
<a name="l00857"></a>00857       size_(bv_size)
<a name="l00858"></a>00858     {}
<a name="l00859"></a>00859 
<a name="l00860"></a>00860 
<a name="l00861"></a><a class="code" href="a00043.html#a608b979d18211645c625e1bcd41cf307">00861</a>     <a class="code" href="a00043.html#a159e3c2cb32e6d098eddd9d1eac21c88" title="Constructs bvector class.">bvector</a>(<span class="keyword">const</span> <a class="code" href="a00043.html" title="bitvector with runtime compression of bits.">bvector&lt;Alloc&gt;</a>&amp; <a class="code" href="a00043.html" title="bitvector with runtime compression of bits.">bvect</a>)
<a name="l00862"></a>00862         :  blockman_(bvect.blockman_),
<a name="l00863"></a>00863            new_blocks_strat_(bvect.new_blocks_strat_),
<a name="l00864"></a>00864            size_(bvect.size_)
<a name="l00865"></a>00865     {}
<a name="l00866"></a>00866 
<a name="l00867"></a>00867 <span class="preprocessor">#endif</span>
<a name="l00868"></a>00868 <span class="preprocessor"></span>
<a name="l00869"></a><a class="code" href="a00043.html#a3ffde9962a72e85ad2e6da29b397882e">00869</a>     <a class="code" href="a00043.html" title="bitvector with runtime compression of bits.">bvector</a>&amp; <a class="code" href="a00043.html#a3ffde9962a72e85ad2e6da29b397882e">operator=</a>(<span class="keyword">const</span> <a class="code" href="a00043.html" title="bitvector with runtime compression of bits.">bvector&lt;Alloc&gt;</a>&amp; <a class="code" href="a00043.html" title="bitvector with runtime compression of bits.">bvect</a>)
<a name="l00870"></a>00870     {
<a name="l00871"></a>00871         <a class="code" href="a00043.html#a4eab84a88eabdee3a3afd1792df76110" title="Clears every bit in the bitvector.">clear</a>(<span class="keyword">true</span>); <span class="comment">// memory free cleaning</span>
<a name="l00872"></a>00872         <a class="code" href="a00043.html#a56b7573c759e51c8943cf95a82a5b9d6" title="Change size of the bvector.">resize</a>(bvect.<a class="code" href="a00043.html#aafa3b0f96b317810c2bba976c68ffeb7" title="return current size of the vector (bits)">size</a>());
<a name="l00873"></a>00873         <a class="code" href="a00043.html#ae2baf80dfd32cd252991a97250989a5d" title="Logical OR operation.">bit_or</a>(bvect);
<a name="l00874"></a>00874         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00875"></a>00875     }
<a name="l00876"></a>00876 
<a name="l00877"></a><a class="code" href="a00043.html#a1917a8e264fd69c102d7232862707732">00877</a>     <a class="code" href="a00080.html" title="Class reference implements an object for bit assignment.">reference</a> <a class="code" href="a00043.html#a1917a8e264fd69c102d7232862707732">operator[]</a>(<a class="code" href="a00115.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a> n)
<a name="l00878"></a>00878     {
<a name="l00879"></a>00879         <a class="code" href="a00092.html#aa44515fab0ace8928d1cb82009a95bf8">BM_ASSERT</a>(n &lt; size_);
<a name="l00880"></a>00880         <span class="keywordflow">return</span> <a class="code" href="a00080.html" title="Class reference implements an object for bit assignment.">reference</a>(*<span class="keyword">this</span>, n);
<a name="l00881"></a>00881     }
<a name="l00882"></a>00882 
<a name="l00883"></a>00883 
<a name="l00884"></a><a class="code" href="a00043.html#acdac4abb22a23273dd3cfc3eda96210e">00884</a>     <span class="keywordtype">bool</span> <a class="code" href="a00043.html#a1917a8e264fd69c102d7232862707732">operator[]</a>(<a class="code" href="a00115.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a> n)<span class="keyword"> const</span>
<a name="l00885"></a>00885 <span class="keyword">    </span>{
<a name="l00886"></a>00886         <a class="code" href="a00092.html#aa44515fab0ace8928d1cb82009a95bf8">BM_ASSERT</a>(n &lt; size_);
<a name="l00887"></a>00887         <span class="keywordflow">return</span> <a class="code" href="a00043.html#a1f9a5978084af329274ba67ed85012f4" title="returns true if bit n is set and false is bit n is 0.">get_bit</a>(n);
<a name="l00888"></a>00888     }
<a name="l00889"></a>00889 
<a name="l00890"></a><a class="code" href="a00043.html#a0e3e3b899b9336b06bce622bd915df54">00890</a>     <span class="keywordtype">void</span> <a class="code" href="a00043.html#a0e3e3b899b9336b06bce622bd915df54">operator &amp;= </a>(<span class="keyword">const</span> <a class="code" href="a00043.html" title="bitvector with runtime compression of bits.">bvector&lt;Alloc&gt;</a>&amp; <a class="code" href="a00043.html" title="bitvector with runtime compression of bits.">bvect</a>)
<a name="l00891"></a>00891     {
<a name="l00892"></a>00892         <a class="code" href="a00043.html#a91a3bec58760e4a6ebb94cc990b45b92" title="Logical AND operation.">bit_and</a>(bvect);
<a name="l00893"></a>00893     }
<a name="l00894"></a>00894 
<a name="l00895"></a><a class="code" href="a00043.html#a4ab9925765353dc1be2c972d0a9fbb57">00895</a>     <span class="keywordtype">void</span> <a class="code" href="a00043.html#a4ab9925765353dc1be2c972d0a9fbb57">operator ^= </a>(<span class="keyword">const</span> <a class="code" href="a00043.html" title="bitvector with runtime compression of bits.">bvector&lt;Alloc&gt;</a>&amp; <a class="code" href="a00043.html" title="bitvector with runtime compression of bits.">bvect</a>)
<a name="l00896"></a>00896     {
<a name="l00897"></a>00897         <a class="code" href="a00043.html#a65a935b2d8b0d8c4732aef26ef40712d" title="Logical XOR operation.">bit_xor</a>(bvect);
<a name="l00898"></a>00898     }
<a name="l00899"></a>00899 
<a name="l00900"></a><a class="code" href="a00043.html#a94826f92e1e2c61c722f23723431e985">00900</a>     <span class="keywordtype">void</span> <a class="code" href="a00043.html#a94826f92e1e2c61c722f23723431e985">operator |= </a>(<span class="keyword">const</span> <a class="code" href="a00043.html" title="bitvector with runtime compression of bits.">bvector&lt;Alloc&gt;</a>&amp; <a class="code" href="a00043.html" title="bitvector with runtime compression of bits.">bvect</a>)
<a name="l00901"></a>00901     {
<a name="l00902"></a>00902         <a class="code" href="a00043.html#ae2baf80dfd32cd252991a97250989a5d" title="Logical OR operation.">bit_or</a>(bvect);
<a name="l00903"></a>00903     }
<a name="l00904"></a>00904 
<a name="l00905"></a><a class="code" href="a00043.html#a2387c3917132271a3148ab3bc81751ae">00905</a>     <span class="keywordtype">void</span> <a class="code" href="a00043.html#a2387c3917132271a3148ab3bc81751ae">operator -= </a>(<span class="keyword">const</span> <a class="code" href="a00043.html" title="bitvector with runtime compression of bits.">bvector&lt;Alloc&gt;</a>&amp; <a class="code" href="a00043.html" title="bitvector with runtime compression of bits.">bvect</a>)
<a name="l00906"></a>00906     {
<a name="l00907"></a>00907         <a class="code" href="a00043.html#af39d2f17f005e5028b1eb3007f8e0e0c" title="Logical SUB operation.">bit_sub</a>(bvect);
<a name="l00908"></a>00908     }
<a name="l00909"></a>00909 
<a name="l00910"></a><a class="code" href="a00043.html#aca15c6e120e4508171234775c46a4852">00910</a>     <span class="keywordtype">bool</span> operator &lt; (const bvector&lt;Alloc&gt;&amp; <a class="code" href="a00043.html" title="bitvector with runtime compression of bits.">bvect</a>) <span class="keyword">const</span>
<a name="l00911"></a>00911     {
<a name="l00912"></a>00912         <span class="keywordflow">return</span> <a class="code" href="a00043.html#a4dbc98ea637b352635549814982d4c28" title="Lexicographical comparison with a bitvector.">compare</a>(<a class="code" href="a00043.html" title="bitvector with runtime compression of bits.">bvect</a>) &lt; 0;
<a name="l00913"></a>00913     }
<a name="l00914"></a>00914 
<a name="l00915"></a><a class="code" href="a00043.html#a8e57dcd5d78915e4040a2492c26a0551">00915</a>     <span class="keywordtype">bool</span> operator &lt;= (const bvector&lt;Alloc&gt;&amp; <a class="code" href="a00043.html" title="bitvector with runtime compression of bits.">bvect</a>) <span class="keyword">const</span>
<a name="l00916"></a>00916     {
<a name="l00917"></a>00917         <span class="keywordflow">return</span> <a class="code" href="a00043.html#a4dbc98ea637b352635549814982d4c28" title="Lexicographical comparison with a bitvector.">compare</a>(<a class="code" href="a00043.html" title="bitvector with runtime compression of bits.">bvect</a>) &lt;= 0;
<a name="l00918"></a>00918     }
<a name="l00919"></a>00919 
<a name="l00920"></a><a class="code" href="a00043.html#a18453885f6baa9ec334a51f149734518">00920</a>     <span class="keywordtype">bool</span> <a class="code" href="a00043.html#a18453885f6baa9ec334a51f149734518">operator &gt; </a>(<span class="keyword">const</span> <a class="code" href="a00043.html" title="bitvector with runtime compression of bits.">bvector&lt;Alloc&gt;</a>&amp; <a class="code" href="a00043.html" title="bitvector with runtime compression of bits.">bvect</a>)<span class="keyword"> const</span>
<a name="l00921"></a>00921 <span class="keyword">    </span>{
<a name="l00922"></a>00922         <span class="keywordflow">return</span> <a class="code" href="a00043.html#a4dbc98ea637b352635549814982d4c28" title="Lexicographical comparison with a bitvector.">compare</a>(bvect) &gt; 0;
<a name="l00923"></a>00923     }
<a name="l00924"></a>00924 
<a name="l00925"></a><a class="code" href="a00043.html#a0b1f77a40c2bb966ddf8686c86276e7d">00925</a>     <span class="keywordtype">bool</span> <a class="code" href="a00043.html#a0b1f77a40c2bb966ddf8686c86276e7d">operator &gt;= </a>(<span class="keyword">const</span> <a class="code" href="a00043.html" title="bitvector with runtime compression of bits.">bvector&lt;Alloc&gt;</a>&amp; <a class="code" href="a00043.html" title="bitvector with runtime compression of bits.">bvect</a>)<span class="keyword"> const</span>
<a name="l00926"></a>00926 <span class="keyword">    </span>{
<a name="l00927"></a>00927         <span class="keywordflow">return</span> <a class="code" href="a00043.html#a4dbc98ea637b352635549814982d4c28" title="Lexicographical comparison with a bitvector.">compare</a>(bvect) &gt;= 0;
<a name="l00928"></a>00928     }
<a name="l00929"></a>00929 
<a name="l00930"></a><a class="code" href="a00043.html#a3c6f894bb905d01db1744a78d8d33de2">00930</a>     <span class="keywordtype">bool</span> <a class="code" href="a00043.html#a3c6f894bb905d01db1744a78d8d33de2">operator == </a>(<span class="keyword">const</span> <a class="code" href="a00043.html" title="bitvector with runtime compression of bits.">bvector&lt;Alloc&gt;</a>&amp; <a class="code" href="a00043.html" title="bitvector with runtime compression of bits.">bvect</a>)<span class="keyword"> const</span>
<a name="l00931"></a>00931 <span class="keyword">    </span>{
<a name="l00932"></a>00932         <span class="keywordflow">return</span> <a class="code" href="a00043.html#a4dbc98ea637b352635549814982d4c28" title="Lexicographical comparison with a bitvector.">compare</a>(bvect) == 0;
<a name="l00933"></a>00933     }
<a name="l00934"></a>00934 
<a name="l00935"></a><a class="code" href="a00043.html#aafd6b98d62daf7407eeba7f519b26bca">00935</a>     <span class="keywordtype">bool</span> <a class="code" href="a00043.html#aafd6b98d62daf7407eeba7f519b26bca">operator != </a>(<span class="keyword">const</span> <a class="code" href="a00043.html" title="bitvector with runtime compression of bits.">bvector&lt;Alloc&gt;</a>&amp; <a class="code" href="a00043.html" title="bitvector with runtime compression of bits.">bvect</a>)<span class="keyword"> const</span>
<a name="l00936"></a>00936 <span class="keyword">    </span>{
<a name="l00937"></a>00937         <span class="keywordflow">return</span> <a class="code" href="a00043.html#a4dbc98ea637b352635549814982d4c28" title="Lexicographical comparison with a bitvector.">compare</a>(bvect) != 0;
<a name="l00938"></a>00938     }
<a name="l00939"></a>00939 
<a name="l00940"></a><a class="code" href="a00043.html#a4262148d151cbfc50049d0f314bf9dbc">00940</a>     <a class="code" href="a00043.html" title="bitvector with runtime compression of bits.">bvector&lt;Alloc&gt;</a> <a class="code" href="a00043.html#a4262148d151cbfc50049d0f314bf9dbc">operator~</a>()<span class="keyword"> const</span>
<a name="l00941"></a>00941 <span class="keyword">    </span>{
<a name="l00942"></a>00942         <span class="keywordflow">return</span> <a class="code" href="a00043.html" title="bitvector with runtime compression of bits.">bvector&lt;Alloc&gt;</a>(*this).invert();
<a name="l00943"></a>00943     }
<a name="l00944"></a>00944     
<a name="l00945"></a><a class="code" href="a00043.html#a4c295a3188d7fc410ca636dc8e97bc6c">00945</a>     Alloc <a class="code" href="a00043.html#a4c295a3188d7fc410ca636dc8e97bc6c">get_allocator</a>()<span class="keyword"> const</span>
<a name="l00946"></a>00946 <span class="keyword">    </span>{
<a name="l00947"></a>00947         <span class="keywordflow">return</span> blockman_.get_allocator();
<a name="l00948"></a>00948     }
<a name="l00949"></a>00949 
<a name="l00950"></a>00950 <span class="comment"></span>
<a name="l00951"></a>00951 <span class="comment">    /*!</span>
<a name="l00952"></a>00952 <span class="comment">       \brief Sets bit n.</span>
<a name="l00953"></a>00953 <span class="comment">       \param n - index of the bit to be set. </span>
<a name="l00954"></a>00954 <span class="comment">       \param val - new bit value</span>
<a name="l00955"></a>00955 <span class="comment">       \return  TRUE if bit was changed</span>
<a name="l00956"></a>00956 <span class="comment">    */</span>
<a name="l00957"></a><a class="code" href="a00043.html#aecf79c2c05bda3445ade2e10b61066b7">00957</a>     <span class="keywordtype">bool</span> <a class="code" href="a00043.html#aecf79c2c05bda3445ade2e10b61066b7" title="Sets bit n.">set_bit</a>(<a class="code" href="a00115.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a> n, <span class="keywordtype">bool</span> val = <span class="keyword">true</span>)
<a name="l00958"></a>00958     {
<a name="l00959"></a>00959         <a class="code" href="a00092.html#aa44515fab0ace8928d1cb82009a95bf8">BM_ASSERT</a>(n &lt; size_);
<a name="l00960"></a>00960         <span class="keywordflow">return</span> set_bit_no_check(n, val);
<a name="l00961"></a>00961     }
<a name="l00962"></a>00962 <span class="comment"></span>
<a name="l00963"></a>00963 <span class="comment">    /*!</span>
<a name="l00964"></a>00964 <span class="comment">       \brief Sets bit n using bit AND with the provided value.</span>
<a name="l00965"></a>00965 <span class="comment">       \param n - index of the bit to be set. </span>
<a name="l00966"></a>00966 <span class="comment">       \param val - new bit value</span>
<a name="l00967"></a>00967 <span class="comment">       \return  TRUE if bit was changed</span>
<a name="l00968"></a>00968 <span class="comment">    */</span>
<a name="l00969"></a><a class="code" href="a00043.html#aae63c4aafd1215964477957b599f1502">00969</a>     <span class="keywordtype">bool</span> <a class="code" href="a00043.html#aae63c4aafd1215964477957b599f1502" title="Sets bit n using bit AND with the provided value.">set_bit_and</a>(<a class="code" href="a00115.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a> n, <span class="keywordtype">bool</span> val = <span class="keyword">true</span>)
<a name="l00970"></a>00970     {
<a name="l00971"></a>00971         <a class="code" href="a00092.html#aa44515fab0ace8928d1cb82009a95bf8">BM_ASSERT</a>(n &lt; size_);
<a name="l00972"></a>00972         <span class="keywordflow">return</span> and_bit_no_check(n, val);
<a name="l00973"></a>00973     }
<a name="l00974"></a>00974 <span class="comment"></span>
<a name="l00975"></a>00975 <span class="comment">    /*!</span>
<a name="l00976"></a>00976 <span class="comment">       \brief Sets bit n only if current value is equal to the condition</span>
<a name="l00977"></a>00977 <span class="comment">       \param n - index of the bit to be set. </span>
<a name="l00978"></a>00978 <span class="comment">       \param val - new bit value</span>
<a name="l00979"></a>00979 <span class="comment">       \param condition - expected current value</span>
<a name="l00980"></a>00980 <span class="comment">       \return TRUE if bit was changed</span>
<a name="l00981"></a>00981 <span class="comment">    */</span>
<a name="l00982"></a><a class="code" href="a00043.html#a9cd2b46e67549275f72517930f99e3ae">00982</a>     <span class="keywordtype">bool</span> <a class="code" href="a00043.html#a9cd2b46e67549275f72517930f99e3ae" title="Sets bit n only if current value is equal to the condition.">set_bit_conditional</a>(<a class="code" href="a00115.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a> n, <span class="keywordtype">bool</span> val, <span class="keywordtype">bool</span> condition)
<a name="l00983"></a>00983     {
<a name="l00984"></a>00984         <a class="code" href="a00092.html#aa44515fab0ace8928d1cb82009a95bf8">BM_ASSERT</a>(n &lt; size_);
<a name="l00985"></a>00985         <span class="keywordflow">if</span> (val == condition) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00986"></a>00986         <span class="keywordflow">return</span> set_bit_conditional_impl(n, val, condition);
<a name="l00987"></a>00987     }
<a name="l00988"></a>00988 
<a name="l00989"></a>00989 <span class="comment"></span>
<a name="l00990"></a>00990 <span class="comment">    /*!</span>
<a name="l00991"></a>00991 <span class="comment">        \brief Sets bit n if val is true, clears bit n if val is false</span>
<a name="l00992"></a>00992 <span class="comment">        \param n - index of the bit to be set</span>
<a name="l00993"></a>00993 <span class="comment">        \param val - new bit value</span>
<a name="l00994"></a>00994 <span class="comment">        \return *this</span>
<a name="l00995"></a>00995 <span class="comment">    */</span>
<a name="l00996"></a><a class="code" href="a00043.html#ad8ffbbabe883ea502ab5e5cf2b2f9e58">00996</a>     <a class="code" href="a00043.html" title="bitvector with runtime compression of bits.">bvector&lt;Alloc&gt;</a>&amp; <span class="keyword">set</span>(<a class="code" href="a00115.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a> n, <span class="keywordtype">bool</span> val = <span class="keyword">true</span>)
<a name="l00997"></a>00997     {
<a name="l00998"></a>00998         <a class="code" href="a00043.html#aecf79c2c05bda3445ade2e10b61066b7" title="Sets bit n.">set_bit</a>(n, val);
<a name="l00999"></a>00999         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l01000"></a>01000     }
<a name="l01001"></a>01001 
<a name="l01002"></a>01002 
<a name="l01003"></a>01003 <span class="comment"></span>
<a name="l01004"></a>01004 <span class="comment">    /*!</span>
<a name="l01005"></a>01005 <span class="comment">       \brief Sets every bit in this bitset to 1.</span>
<a name="l01006"></a>01006 <span class="comment">       \return *this</span>
<a name="l01007"></a>01007 <span class="comment">    */</span>
<a name="l01008"></a><a class="code" href="a00043.html#a87910722183e9fa8939af12c35eb8d05">01008</a>     <a class="code" href="a00043.html" title="bitvector with runtime compression of bits.">bvector&lt;Alloc&gt;</a>&amp; <span class="keyword">set</span>()
<a name="l01009"></a>01009     {
<a name="l01010"></a>01010         <a class="code" href="a00087.html#a835c3ed1c5956735e59744cff81244dc">BMCOUNT_VALID</a>(<span class="keyword">false</span>)
<a name="l01011"></a>01011         <a class="code" href="a00043.html#ae14650ede7559f896894f951810cadbf" title="Sets all bits in the specified closed interval [left,right] Interval must be inside...">set_range</a>(0, size_ - 1, <span class="keyword">true</span>);
<a name="l01012"></a>01012         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l01013"></a>01013     }
<a name="l01014"></a>01014 
<a name="l01015"></a>01015 <span class="comment"></span>
<a name="l01016"></a>01016 <span class="comment">    /*!</span>
<a name="l01017"></a>01017 <span class="comment">        \brief Sets all bits in the specified closed interval [left,right]</span>
<a name="l01018"></a>01018 <span class="comment">        Interval must be inside the bvector&apos;s size. </span>
<a name="l01019"></a>01019 <span class="comment">        This method DOES NOT resize vector.</span>
<a name="l01020"></a>01020 <span class="comment">        </span>
<a name="l01021"></a>01021 <span class="comment">        \param left  - interval start</span>
<a name="l01022"></a>01022 <span class="comment">        \param right - interval end (closed interval)</span>
<a name="l01023"></a>01023 <span class="comment">        \param value - value to set interval in</span>
<a name="l01024"></a>01024 <span class="comment">        </span>
<a name="l01025"></a>01025 <span class="comment">        \return *this</span>
<a name="l01026"></a>01026 <span class="comment">    */</span>
<a name="l01027"></a>01027     <a class="code" href="a00043.html" title="bitvector with runtime compression of bits.">bvector&lt;Alloc&gt;</a>&amp; <a class="code" href="a00043.html#ae14650ede7559f896894f951810cadbf" title="Sets all bits in the specified closed interval [left,right] Interval must be inside...">set_range</a>(<a class="code" href="a00115.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a> left,
<a name="l01028"></a>01028                               <a class="code" href="a00115.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a> right,
<a name="l01029"></a>01029                               <span class="keywordtype">bool</span>     value = <span class="keyword">true</span>);
<a name="l01030"></a>01030 
<a name="l01031"></a>01031     <span class="comment"></span>
<a name="l01032"></a>01032 <span class="comment">    /*! Function erturns insert iterator for this bitvector */</span>
<a name="l01033"></a><a class="code" href="a00043.html#a6fbb5c0bd6f4b05712ee7701dcd1fe1e">01033</a>     <a class="code" href="a00070.html" title="Output iterator iterator designed to set &amp;quot;ON&amp;quot; bits based on input sequence...">insert_iterator</a> <a class="code" href="a00043.html#a6fbb5c0bd6f4b05712ee7701dcd1fe1e">inserter</a>()
<a name="l01034"></a>01034     {
<a name="l01035"></a>01035         <span class="keywordflow">return</span> <a class="code" href="a00070.html" title="Output iterator iterator designed to set &amp;quot;ON&amp;quot; bits based on input sequence...">insert_iterator</a>(*<span class="keyword">this</span>);
<a name="l01036"></a>01036     }
<a name="l01037"></a>01037 
<a name="l01038"></a>01038 <span class="comment"></span>
<a name="l01039"></a>01039 <span class="comment">    /*!</span>
<a name="l01040"></a>01040 <span class="comment">       \brief Clears bit n.</span>
<a name="l01041"></a>01041 <span class="comment">       \param n - bit&apos;s index to be cleaned.</span>
<a name="l01042"></a>01042 <span class="comment">    */</span>
<a name="l01043"></a><a class="code" href="a00043.html#aea454356c025be2bf654067257967d6f">01043</a>     <span class="keywordtype">void</span> <a class="code" href="a00043.html#aea454356c025be2bf654067257967d6f" title="Clears bit n.">clear_bit</a>(<a class="code" href="a00115.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a> n)
<a name="l01044"></a>01044     {
<a name="l01045"></a>01045         <span class="keyword">set</span>(n, <span class="keyword">false</span>);
<a name="l01046"></a>01046     }
<a name="l01047"></a>01047 
<a name="l01048"></a>01048 <span class="comment"></span>
<a name="l01049"></a>01049 <span class="comment">    /*!</span>
<a name="l01050"></a>01050 <span class="comment">       \brief Clears every bit in the bitvector.</span>
<a name="l01051"></a>01051 <span class="comment"></span>
<a name="l01052"></a>01052 <span class="comment">       \param free_mem if &quot;true&quot; (default) bvector frees the memory,</span>
<a name="l01053"></a>01053 <span class="comment">       otherwise sets blocks to 0.</span>
<a name="l01054"></a>01054 <span class="comment">    */</span>
<a name="l01055"></a><a class="code" href="a00043.html#a4eab84a88eabdee3a3afd1792df76110">01055</a>     <span class="keywordtype">void</span> <a class="code" href="a00043.html#a4eab84a88eabdee3a3afd1792df76110" title="Clears every bit in the bitvector.">clear</a>(<span class="keywordtype">bool</span> free_mem = <span class="keyword">false</span>)
<a name="l01056"></a>01056     {
<a name="l01057"></a>01057         blockman_.set_all_zero(free_mem);
<a name="l01058"></a>01058         <a class="code" href="a00087.html#a1fbebc7fe3c22d768ff6e240437ee8f4">BMCOUNT_SET</a>(0);
<a name="l01059"></a>01059     }
<a name="l01060"></a>01060 <span class="comment"></span>
<a name="l01061"></a>01061 <span class="comment">    /*!</span>
<a name="l01062"></a>01062 <span class="comment">       \brief Clears every bit in the bitvector.</span>
<a name="l01063"></a>01063 <span class="comment">       \return *this;</span>
<a name="l01064"></a>01064 <span class="comment">    */</span>
<a name="l01065"></a><a class="code" href="a00043.html#ac1280ff08a2b1f4377ca15df081781f8">01065</a>     <a class="code" href="a00043.html" title="bitvector with runtime compression of bits.">bvector&lt;Alloc&gt;</a>&amp; <a class="code" href="a00043.html#ac1280ff08a2b1f4377ca15df081781f8" title="Clears every bit in the bitvector.">reset</a>()
<a name="l01066"></a>01066     {
<a name="l01067"></a>01067         <a class="code" href="a00043.html#a4eab84a88eabdee3a3afd1792df76110" title="Clears every bit in the bitvector.">clear</a>();
<a name="l01068"></a>01068         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l01069"></a>01069     }
<a name="l01070"></a>01070 
<a name="l01071"></a>01071 <span class="comment"></span>
<a name="l01072"></a>01072 <span class="comment">    /*!</span>
<a name="l01073"></a>01073 <span class="comment">       \brief Returns count of bits which are 1.</span>
<a name="l01074"></a>01074 <span class="comment">       \return Total number of bits ON. </span>
<a name="l01075"></a>01075 <span class="comment">    */</span>
<a name="l01076"></a>01076     <a class="code" href="a00115.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a> <a class="code" href="a00043.html#aceb122f712580c4be455099784bea72f" title="Returns count of bits which are 1.">count</a>() <span class="keyword">const</span>;
<a name="l01077"></a>01077 <span class="comment"></span>
<a name="l01078"></a>01078 <span class="comment">    /**</span>
<a name="l01079"></a>01079 <span class="comment">        \brief Returns bvector&apos;s capacity (number of bits it can store)</span>
<a name="l01080"></a>01080 <span class="comment">    */</span>
<a name="l01081"></a><a class="code" href="a00043.html#a2537ea61fcdfa19bbf6e248d5ea2b462">01081</a>     <a class="code" href="a00043.html#a405dd9ed048c935c84a5086ec8ba3649" title="Type used to count bits in the bit vector.">size_type</a> <a class="code" href="a00043.html#a2537ea61fcdfa19bbf6e248d5ea2b462" title="Returns bvector&amp;#39;s capacity (number of bits it can store).">capacity</a>()<span class="keyword"> const </span>
<a name="l01082"></a>01082 <span class="keyword">    </span>{
<a name="l01083"></a>01083         <span class="keywordflow">return</span> blockman_.capacity();
<a name="l01084"></a>01084     }
<a name="l01085"></a>01085 <span class="comment"></span>
<a name="l01086"></a>01086 <span class="comment">    /*!</span>
<a name="l01087"></a>01087 <span class="comment">        \brief return current size of the vector (bits)</span>
<a name="l01088"></a>01088 <span class="comment">    */</span>
<a name="l01089"></a><a class="code" href="a00043.html#aafa3b0f96b317810c2bba976c68ffeb7">01089</a>     <a class="code" href="a00043.html#a405dd9ed048c935c84a5086ec8ba3649" title="Type used to count bits in the bit vector.">size_type</a> <a class="code" href="a00043.html#aafa3b0f96b317810c2bba976c68ffeb7" title="return current size of the vector (bits)">size</a>()<span class="keyword"> const </span>
<a name="l01090"></a>01090 <span class="keyword">    </span>{
<a name="l01091"></a>01091         <span class="keywordflow">return</span> size_;
<a name="l01092"></a>01092     }
<a name="l01093"></a>01093 <span class="comment"></span>
<a name="l01094"></a>01094 <span class="comment">    /*!</span>
<a name="l01095"></a>01095 <span class="comment">        \brief Change size of the bvector</span>
<a name="l01096"></a>01096 <span class="comment">        \param new_size - new size in bits</span>
<a name="l01097"></a>01097 <span class="comment">    */</span>
<a name="l01098"></a>01098     <span class="keywordtype">void</span> <a class="code" href="a00043.html#a56b7573c759e51c8943cf95a82a5b9d6" title="Change size of the bvector.">resize</a>(<a class="code" href="a00043.html#a405dd9ed048c935c84a5086ec8ba3649" title="Type used to count bits in the bit vector.">size_type</a> new_size);
<a name="l01099"></a>01099 <span class="comment"></span>
<a name="l01100"></a>01100 <span class="comment">    /*! \brief Computes bitcount values for all bvector blocks</span>
<a name="l01101"></a>01101 <span class="comment">        \param arr - pointer on array of block bit counts</span>
<a name="l01102"></a>01102 <span class="comment">        \return Index of the last block counted. </span>
<a name="l01103"></a>01103 <span class="comment">        This number +1 gives you number of arr elements initialized during the</span>
<a name="l01104"></a>01104 <span class="comment">        function call.</span>
<a name="l01105"></a>01105 <span class="comment">    */</span>
<a name="l01106"></a><a class="code" href="a00043.html#a263104a7d672eac16c0599ba236cb53a">01106</a>     <span class="keywordtype">unsigned</span> <a class="code" href="a00043.html#a263104a7d672eac16c0599ba236cb53a" title="Computes bitcount values for all bvector blocks.">count_blocks</a>(<span class="keywordtype">unsigned</span>* arr)<span class="keyword"> const</span>
<a name="l01107"></a>01107 <span class="keyword">    </span>{
<a name="l01108"></a>01108         <a class="code" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a>*** blk_root = blockman_.get_rootblock();
<a name="l01109"></a>01109         <span class="keyword">typename</span> blocks_manager_type::block_count_arr_func func(blockman_, &amp;(arr[0]));
<a name="l01110"></a>01110         <a class="code" href="a00115.html#a46953a43cfc3da7192d883b6dd822d99">for_each_nzblock</a>(blk_root, blockman_.effective_top_block_size(), 
<a name="l01111"></a>01111                          func);
<a name="l01112"></a>01112         <span class="keywordflow">return</span> func.last_block();
<a name="l01113"></a>01113     }
<a name="l01114"></a>01114 <span class="comment"></span>
<a name="l01115"></a>01115 <span class="comment">    /*!</span>
<a name="l01116"></a>01116 <span class="comment">       \brief Returns count of 1 bits in the given diapason.</span>
<a name="l01117"></a>01117 <span class="comment">       \param left - index of first bit start counting from</span>
<a name="l01118"></a>01118 <span class="comment">       \param right - index of last bit </span>
<a name="l01119"></a>01119 <span class="comment">       \param block_count_arr - optional parameter (bitcount by bvector blocks)</span>
<a name="l01120"></a>01120 <span class="comment">              calculated by count_blocks method. Used to improve performance of</span>
<a name="l01121"></a>01121 <span class="comment">              wide range searches</span>
<a name="l01122"></a>01122 <span class="comment">       \return Total number of bits ON. </span>
<a name="l01123"></a>01123 <span class="comment">    */</span>
<a name="l01124"></a>01124     <a class="code" href="a00115.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a> <a class="code" href="a00043.html#adb314a299b9a98954ba1fc5064f279c2" title="Returns count of 1 bits in the given diapason.">count_range</a>(<a class="code" href="a00115.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a> left, 
<a name="l01125"></a>01125                          <a class="code" href="a00115.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a> right, 
<a name="l01126"></a>01126                          <span class="keywordtype">unsigned</span>* block_count_arr=0) <span class="keyword">const</span>;
<a name="l01127"></a>01127 
<a name="l01128"></a>01128 
<a name="l01129"></a><a class="code" href="a00043.html#ad88ebd6c8f81a36679b26c6c7535da78">01129</a>     <a class="code" href="a00115.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a> <a class="code" href="a00043.html#ad88ebd6c8f81a36679b26c6c7535da78">recalc_count</a>()
<a name="l01130"></a>01130     {
<a name="l01131"></a>01131         <a class="code" href="a00087.html#a835c3ed1c5956735e59744cff81244dc">BMCOUNT_VALID</a>(<span class="keyword">false</span>)
<a name="l01132"></a>01132         <span class="keywordflow">return</span> <a class="code" href="a00043.html#aceb122f712580c4be455099784bea72f" title="Returns count of bits which are 1.">count</a>();
<a name="l01133"></a>01133     }
<a name="l01134"></a>01134     <span class="comment"></span>
<a name="l01135"></a>01135 <span class="comment">    /*!</span>
<a name="l01136"></a>01136 <span class="comment">        Disables count cache. Next call to count() or recalc_count()</span>
<a name="l01137"></a>01137 <span class="comment">        restores count caching.</span>
<a name="l01138"></a>01138 <span class="comment">        </span>
<a name="l01139"></a>01139 <span class="comment">        @note Works only if BMCOUNTOPT enabled(defined). </span>
<a name="l01140"></a>01140 <span class="comment">        Othewise does nothing.</span>
<a name="l01141"></a>01141 <span class="comment">    */</span>
<a name="l01142"></a><a class="code" href="a00043.html#af77c870f1b54b6b54a3f52d84c4cb3ae">01142</a>     <span class="keywordtype">void</span> <a class="code" href="a00043.html#af77c870f1b54b6b54a3f52d84c4cb3ae">forget_count</a>()
<a name="l01143"></a>01143     {
<a name="l01144"></a>01144         <a class="code" href="a00087.html#a835c3ed1c5956735e59744cff81244dc">BMCOUNT_VALID</a>(<span class="keyword">false</span>)    
<a name="l01145"></a>01145     }
<a name="l01146"></a>01146 <span class="comment"></span>
<a name="l01147"></a>01147 <span class="comment">    /*!</span>
<a name="l01148"></a>01148 <span class="comment">        \brief Inverts all bits.</span>
<a name="l01149"></a>01149 <span class="comment">    */</span>
<a name="l01150"></a>01150     <a class="code" href="a00043.html" title="bitvector with runtime compression of bits.">bvector&lt;Alloc&gt;</a>&amp; <a class="code" href="a00043.html#a27e95553f358ebebda6b521336682deb" title="Inverts all bits.">invert</a>();
<a name="l01151"></a>01151 
<a name="l01152"></a>01152 <span class="comment"></span>
<a name="l01153"></a>01153 <span class="comment">    /*!</span>
<a name="l01154"></a>01154 <span class="comment">       \brief returns true if bit n is set and false is bit n is 0. </span>
<a name="l01155"></a>01155 <span class="comment">       \param n - Index of the bit to check.</span>
<a name="l01156"></a>01156 <span class="comment">       \return Bit value (1 or 0)</span>
<a name="l01157"></a>01157 <span class="comment">    */</span>
<a name="l01158"></a>01158     <span class="keywordtype">bool</span> <a class="code" href="a00043.html#a1f9a5978084af329274ba67ed85012f4" title="returns true if bit n is set and false is bit n is 0.">get_bit</a>(<a class="code" href="a00115.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a> n) <span class="keyword">const</span>;
<a name="l01159"></a>01159 <span class="comment"></span>
<a name="l01160"></a>01160 <span class="comment">    /*!</span>
<a name="l01161"></a>01161 <span class="comment">       \brief returns true if bit n is set and false is bit n is 0. </span>
<a name="l01162"></a>01162 <span class="comment">       \param n - Index of the bit to check.</span>
<a name="l01163"></a>01163 <span class="comment">       \return Bit value (1 or 0)</span>
<a name="l01164"></a>01164 <span class="comment">    */</span>
<a name="l01165"></a><a class="code" href="a00043.html#aea83004c94ca2c61410a9f12bfd8359d">01165</a>     <span class="keywordtype">bool</span> <a class="code" href="a00043.html#aea83004c94ca2c61410a9f12bfd8359d" title="returns true if bit n is set and false is bit n is 0.">test</a>(<a class="code" href="a00115.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a> n)<span class="keyword"> const </span>
<a name="l01166"></a>01166 <span class="keyword">    </span>{ 
<a name="l01167"></a>01167         <span class="keywordflow">return</span> <a class="code" href="a00043.html#a1f9a5978084af329274ba67ed85012f4" title="returns true if bit n is set and false is bit n is 0.">get_bit</a>(n); 
<a name="l01168"></a>01168     }
<a name="l01169"></a>01169 <span class="comment"></span>
<a name="l01170"></a>01170 <span class="comment">    /*!</span>
<a name="l01171"></a>01171 <span class="comment">       \brief Returns true if any bits in this bitset are set, and otherwise returns false.</span>
<a name="l01172"></a>01172 <span class="comment">       \return true if any bit is set</span>
<a name="l01173"></a>01173 <span class="comment">    */</span>
<a name="l01174"></a><a class="code" href="a00043.html#a7f2f30a79922fad81e55944597d56c2e">01174</a>     <span class="keywordtype">bool</span> <a class="code" href="a00043.html#a7f2f30a79922fad81e55944597d56c2e" title="Returns true if any bits in this bitset are set, and otherwise returns false.">any</a>()<span class="keyword"> const</span>
<a name="l01175"></a>01175 <span class="keyword">    </span>{
<a name="l01176"></a>01176 <span class="preprocessor">    #ifdef BMCOUNTOPT</span>
<a name="l01177"></a>01177 <span class="preprocessor"></span>        <span class="keywordflow">if</span> (count_is_valid_ &amp;&amp; count_) <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l01178"></a>01178 <span class="preprocessor">    #endif</span>
<a name="l01179"></a>01179 <span class="preprocessor"></span>        
<a name="l01180"></a>01180         <a class="code" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">word_t</a>*** blk_root = blockman_.get_rootblock();
<a name="l01181"></a>01181         <span class="keywordflow">if</span> (!blk_root) 
<a name="l01182"></a>01182             <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l01183"></a>01183         <span class="keyword">typename</span> blocks_manager_type::block_any_func func(blockman_);
<a name="l01184"></a>01184         <span class="keywordflow">return</span> <a class="code" href="a00115.html#a5b4e99c8ed7b929be87bd5a1ad76fd37">for_each_nzblock_if</a>(blk_root, 
<a name="l01185"></a>01185                                    blockman_.effective_top_block_size(),
<a name="l01186"></a>01186                                    func);
<a name="l01187"></a>01187     }
<a name="l01188"></a>01188 <span class="comment"></span>
<a name="l01189"></a>01189 <span class="comment">    /*!</span>
<a name="l01190"></a>01190 <span class="comment">        \brief Returns true if no bits are set, otherwise returns false.</span>
<a name="l01191"></a>01191 <span class="comment">    */</span>
<a name="l01192"></a><a class="code" href="a00043.html#a7ca827458dc508130a8b1557a6fff9a9">01192</a>     <span class="keywordtype">bool</span> <a class="code" href="a00043.html#a7ca827458dc508130a8b1557a6fff9a9" title="Returns true if no bits are set, otherwise returns false.">none</a>()<span class="keyword"> const</span>
<a name="l01193"></a>01193 <span class="keyword">    </span>{
<a name="l01194"></a>01194         <span class="keywordflow">return</span> !<a class="code" href="a00043.html#a7f2f30a79922fad81e55944597d56c2e" title="Returns true if any bits in this bitset are set, and otherwise returns false.">any</a>();
<a name="l01195"></a>01195     }
<a name="l01196"></a>01196 <span class="comment"></span>
<a name="l01197"></a>01197 <span class="comment">    /*!</span>
<a name="l01198"></a>01198 <span class="comment">       \brief Flips bit n</span>
<a name="l01199"></a>01199 <span class="comment">       \return *this</span>
<a name="l01200"></a>01200 <span class="comment">    */</span>
<a name="l01201"></a><a class="code" href="a00043.html#ab2a75eb8e2857dd05a4fd45c545f9902">01201</a>     <a class="code" href="a00043.html" title="bitvector with runtime compression of bits.">bvector&lt;Alloc&gt;</a>&amp; <a class="code" href="a00043.html#aaf87e9eb001e03c8828c7a92d9ab4e90" title="Flips all bits.">flip</a>(<a class="code" href="a00115.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a> n) 
<a name="l01202"></a>01202     {
<a name="l01203"></a>01203         <span class="keyword">set</span>(n, !<a class="code" href="a00043.html#a1f9a5978084af329274ba67ed85012f4" title="returns true if bit n is set and false is bit n is 0.">get_bit</a>(n));
<a name="l01204"></a>01204         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l01205"></a>01205     }
<a name="l01206"></a>01206 <span class="comment"></span>
<a name="l01207"></a>01207 <span class="comment">    /*!</span>
<a name="l01208"></a>01208 <span class="comment">       \brief Flips all bits</span>
<a name="l01209"></a>01209 <span class="comment">       \return *this</span>
<a name="l01210"></a>01210 <span class="comment">    */</span>
<a name="l01211"></a><a class="code" href="a00043.html#aaf87e9eb001e03c8828c7a92d9ab4e90">01211</a>     <a class="code" href="a00043.html" title="bitvector with runtime compression of bits.">bvector&lt;Alloc&gt;</a>&amp; <a class="code" href="a00043.html#aaf87e9eb001e03c8828c7a92d9ab4e90" title="Flips all bits.">flip</a>() 
<a name="l01212"></a>01212     {
<a name="l01213"></a>01213         <span class="keywordflow">return</span> <a class="code" href="a00043.html#a27e95553f358ebebda6b521336682deb" title="Inverts all bits.">invert</a>();
<a name="l01214"></a>01214     }
<a name="l01215"></a>01215 <span class="comment"></span>
<a name="l01216"></a>01216 <span class="comment">    /*! \brief Exchanges content of bv and this bitvector.</span>
<a name="l01217"></a>01217 <span class="comment">    */</span>
<a name="l01218"></a><a class="code" href="a00043.html#ad1a7647461182e9ee2751c344a617c58">01218</a>     <span class="keywordtype">void</span> <a class="code" href="a00043.html#ad1a7647461182e9ee2751c344a617c58" title="Exchanges content of bv and this bitvector.">swap</a>(<a class="code" href="a00043.html" title="bitvector with runtime compression of bits.">bvector&lt;Alloc&gt;</a>&amp; bv)
<a name="l01219"></a>01219     {
<a name="l01220"></a>01220         <span class="keywordflow">if</span> (<span class="keyword">this</span> != &amp;bv) 
<a name="l01221"></a>01221         {
<a name="l01222"></a>01222             blockman_.swap(bv.blockman_);
<a name="l01223"></a>01223             <a class="code" href="a00115.html#afb2c1acc56270abb381741a709a2b17c" title="XOR swap two scalar variables.">bm::xor_swap</a>(size_,bv.size_);
<a name="l01224"></a>01224 <span class="preprocessor">    #ifdef BMCOUNTOPT</span>
<a name="l01225"></a>01225 <span class="preprocessor"></span>            <a class="code" href="a00087.html#a835c3ed1c5956735e59744cff81244dc">BMCOUNT_VALID</a>(<span class="keyword">false</span>)
<a name="l01226"></a>01226             bv.<a class="code" href="a00043.html#ad88ebd6c8f81a36679b26c6c7535da78">recalc_count</a>();
<a name="l01227"></a>01227 <span class="preprocessor">    #endif</span>
<a name="l01228"></a>01228 <span class="preprocessor"></span>        }
<a name="l01229"></a>01229     }
<a name="l01230"></a>01230 
<a name="l01231"></a>01231 <span class="comment"></span>
<a name="l01232"></a>01232 <span class="comment">    /*!</span>
<a name="l01233"></a>01233 <span class="comment">       \fn bm::id_t bvector::get_first() const</span>
<a name="l01234"></a>01234 <span class="comment">       \brief Gets number of first bit which is ON.</span>
<a name="l01235"></a>01235 <span class="comment">       \return Index of the first 1 bit.</span>
<a name="l01236"></a>01236 <span class="comment">       \sa get_next, extract_next</span>
<a name="l01237"></a>01237 <span class="comment">    */</span>
<a name="l01238"></a><a class="code" href="a00043.html#a73af6458613446fcfd042d0f5af83fcc">01238</a>     <a class="code" href="a00115.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a> <a class="code" href="a00043.html#a73af6458613446fcfd042d0f5af83fcc" title="Gets number of first bit which is ON.">get_first</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> check_or_next(0); }
<a name="l01239"></a>01239 <span class="comment"></span>
<a name="l01240"></a>01240 <span class="comment">    /*!</span>
<a name="l01241"></a>01241 <span class="comment">       \fn bm::id_t bvector::get_next(bm::id_t prev) const</span>
<a name="l01242"></a>01242 <span class="comment">       \brief Finds the number of the next bit ON.</span>
<a name="l01243"></a>01243 <span class="comment">       \param prev - Index of the previously found bit. </span>
<a name="l01244"></a>01244 <span class="comment">       \return Index of the next bit which is ON or 0 if not found.</span>
<a name="l01245"></a>01245 <span class="comment">       \sa get_first, extract_next</span>
<a name="l01246"></a>01246 <span class="comment">    */</span>
<a name="l01247"></a><a class="code" href="a00043.html#a06ed219419b4774ab73a982020760622">01247</a>     <a class="code" href="a00115.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a> <a class="code" href="a00043.html#a06ed219419b4774ab73a982020760622" title="Finds the number of the next bit ON.">get_next</a>(<a class="code" href="a00115.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a> prev)<span class="keyword"> const</span>
<a name="l01248"></a>01248 <span class="keyword">    </span>{
<a name="l01249"></a>01249         <span class="keywordflow">return</span> (++prev == <a class="code" href="a00115.html#a104b924a1df81542db2a6296fbf26a65">bm::id_max</a>) ? 0 : check_or_next(prev);
<a name="l01250"></a>01250     }
<a name="l01251"></a>01251 <span class="comment"></span>
<a name="l01252"></a>01252 <span class="comment">    /*!</span>
<a name="l01253"></a>01253 <span class="comment">       \fn bm::id_t bvector::extract_next(bm::id_t prev)</span>
<a name="l01254"></a>01254 <span class="comment">       \brief Finds the number of the next bit ON and sets it to 0.</span>
<a name="l01255"></a>01255 <span class="comment">       \param prev - Index of the previously found bit. </span>
<a name="l01256"></a>01256 <span class="comment">       \return Index of the next bit which is ON or 0 if not found.</span>
<a name="l01257"></a>01257 <span class="comment">       \sa get_first, get_next, </span>
<a name="l01258"></a>01258 <span class="comment">    */</span>
<a name="l01259"></a><a class="code" href="a00043.html#a30ff4b9bd8fdf35e40ba1eba67446e37">01259</a>     <a class="code" href="a00115.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a> <a class="code" href="a00043.html#a30ff4b9bd8fdf35e40ba1eba67446e37" title="Finds the number of the next bit ON and sets it to 0.">extract_next</a>(<a class="code" href="a00115.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a> prev)
<a name="l01260"></a>01260     {
<a name="l01261"></a>01261         <span class="keywordflow">return</span> (++prev == <a class="code" href="a00115.html#a104b924a1df81542db2a6296fbf26a65">bm::id_max</a>) ? 0 : check_or_next_extract(prev);
<a name="l01262"></a>01262     }
<a name="l01263"></a>01263 
<a name="l01264"></a>01264 <span class="comment"></span>
<a name="l01265"></a>01265 <span class="comment">    /*!</span>
<a name="l01266"></a>01266 <span class="comment">       @brief Calculates bitvector statistics.</span>
<a name="l01267"></a>01267 <span class="comment"></span>
<a name="l01268"></a>01268 <span class="comment">       @param st - pointer on statistics structure to be filled in. </span>
<a name="l01269"></a>01269 <span class="comment"></span>
<a name="l01270"></a>01270 <span class="comment">       Function fills statistics structure containing information about how </span>
<a name="l01271"></a>01271 <span class="comment">       this vector uses memory and estimation of max. amount of memory </span>
<a name="l01272"></a>01272 <span class="comment">       bvector needs to serialize itself.</span>
<a name="l01273"></a>01273 <span class="comment"></span>
<a name="l01274"></a>01274 <span class="comment">       @sa statistics</span>
<a name="l01275"></a>01275 <span class="comment">    */</span>
<a name="l01276"></a>01276     <span class="keywordtype">void</span> <a class="code" href="a00043.html#a61cd78a95b33d4759b5b8b535713dc50" title="Calculates bitvector statistics.">calc_stat</a>(<span class="keyword">struct</span> <a class="code" href="a00085.html" title="Statistical information about bitset&amp;#39;s memory allocation details.">bm::bvector&lt;Alloc&gt;::statistics</a>* st) <span class="keyword">const</span>;
<a name="l01277"></a>01277 <span class="comment"></span>
<a name="l01278"></a>01278 <span class="comment">    /*!</span>
<a name="l01279"></a>01279 <span class="comment">       \brief Logical OR operation.</span>
<a name="l01280"></a>01280 <span class="comment">       \param vect - Argument vector.</span>
<a name="l01281"></a>01281 <span class="comment">    */</span>
<a name="l01282"></a><a class="code" href="a00043.html#ae2baf80dfd32cd252991a97250989a5d">01282</a>     <a class="code" href="a00043.html" title="bitvector with runtime compression of bits.">bm::bvector&lt;Alloc&gt;</a>&amp; <a class="code" href="a00043.html#ae2baf80dfd32cd252991a97250989a5d" title="Logical OR operation.">bit_or</a>(<span class="keyword">const</span>  <a class="code" href="a00043.html" title="bitvector with runtime compression of bits.">bm::bvector&lt;Alloc&gt;</a>&amp; vect)
<a name="l01283"></a>01283     {
<a name="l01284"></a>01284         <a class="code" href="a00087.html#a835c3ed1c5956735e59744cff81244dc">BMCOUNT_VALID</a>(<span class="keyword">false</span>);
<a name="l01285"></a>01285         <a class="code" href="a00043.html#ae57f6d62d1f54eeaa604ae7ce53e0e0f">combine_operation</a>(vect, <a class="code" href="a00115.html#a42405343976ec931388381cea4092bf1a0c8cf0197857d0bd73a63037e2f2c5c5">BM_OR</a>);
<a name="l01286"></a>01286         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l01287"></a>01287     }
<a name="l01288"></a>01288 <span class="comment"></span>
<a name="l01289"></a>01289 <span class="comment">    /*!</span>
<a name="l01290"></a>01290 <span class="comment">       \brief Logical AND operation.</span>
<a name="l01291"></a>01291 <span class="comment">       \param vect - Argument vector.</span>
<a name="l01292"></a>01292 <span class="comment">    */</span>
<a name="l01293"></a><a class="code" href="a00043.html#a91a3bec58760e4a6ebb94cc990b45b92">01293</a>     <a class="code" href="a00043.html" title="bitvector with runtime compression of bits.">bm::bvector&lt;Alloc&gt;</a>&amp; <a class="code" href="a00043.html#a91a3bec58760e4a6ebb94cc990b45b92" title="Logical AND operation.">bit_and</a>(<span class="keyword">const</span> <a class="code" href="a00043.html" title="bitvector with runtime compression of bits.">bm::bvector&lt;Alloc&gt;</a>&amp; vect)
<a name="l01294"></a>01294     {
<a name="l01295"></a>01295         <a class="code" href="a00087.html#a835c3ed1c5956735e59744cff81244dc">BMCOUNT_VALID</a>(<span class="keyword">false</span>);
<a name="l01296"></a>01296         <a class="code" href="a00043.html#ae57f6d62d1f54eeaa604ae7ce53e0e0f">combine_operation</a>(vect, <a class="code" href="a00115.html#a42405343976ec931388381cea4092bf1a546fdf33b301e5b9bee0591522ed9250">BM_AND</a>);
<a name="l01297"></a>01297         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l01298"></a>01298     }
<a name="l01299"></a>01299 <span class="comment"></span>
<a name="l01300"></a>01300 <span class="comment">    /*!</span>
<a name="l01301"></a>01301 <span class="comment">       \brief Logical XOR operation.</span>
<a name="l01302"></a>01302 <span class="comment">       \param vect - Argument vector.</span>
<a name="l01303"></a>01303 <span class="comment">    */</span>
<a name="l01304"></a><a class="code" href="a00043.html#a65a935b2d8b0d8c4732aef26ef40712d">01304</a>     <a class="code" href="a00043.html" title="bitvector with runtime compression of bits.">bm::bvector&lt;Alloc&gt;</a>&amp; <a class="code" href="a00043.html#a65a935b2d8b0d8c4732aef26ef40712d" title="Logical XOR operation.">bit_xor</a>(<span class="keyword">const</span> <a class="code" href="a00043.html" title="bitvector with runtime compression of bits.">bm::bvector&lt;Alloc&gt;</a>&amp; vect)
<a name="l01305"></a>01305     {
<a name="l01306"></a>01306         <a class="code" href="a00087.html#a835c3ed1c5956735e59744cff81244dc">BMCOUNT_VALID</a>(<span class="keyword">false</span>);
<a name="l01307"></a>01307         <a class="code" href="a00043.html#ae57f6d62d1f54eeaa604ae7ce53e0e0f">combine_operation</a>(vect, <a class="code" href="a00115.html#a42405343976ec931388381cea4092bf1a45c2fe36efb72dc03f03a842d253f64c">BM_XOR</a>);
<a name="l01308"></a>01308         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l01309"></a>01309     }
<a name="l01310"></a>01310 <span class="comment"></span>
<a name="l01311"></a>01311 <span class="comment">    /*!</span>
<a name="l01312"></a>01312 <span class="comment">       \brief Logical SUB operation.</span>
<a name="l01313"></a>01313 <span class="comment">       \param vect - Argument vector.</span>
<a name="l01314"></a>01314 <span class="comment">    */</span>
<a name="l01315"></a><a class="code" href="a00043.html#af39d2f17f005e5028b1eb3007f8e0e0c">01315</a>     <a class="code" href="a00043.html" title="bitvector with runtime compression of bits.">bm::bvector&lt;Alloc&gt;</a>&amp; <a class="code" href="a00043.html#af39d2f17f005e5028b1eb3007f8e0e0c" title="Logical SUB operation.">bit_sub</a>(<span class="keyword">const</span> <a class="code" href="a00043.html" title="bitvector with runtime compression of bits.">bm::bvector&lt;Alloc&gt;</a>&amp; vect)
<a name="l01316"></a>01316     {
<a name="l01317"></a>01317         <a class="code" href="a00087.html#a835c3ed1c5956735e59744cff81244dc">BMCOUNT_VALID</a>(<span class="keyword">false</span>);
<a name="l01318"></a>01318         <a class="code" href="a00043.html#ae57f6d62d1f54eeaa604ae7ce53e0e0f">combine_operation</a>(vect, <a class="code" href="a00115.html#a42405343976ec931388381cea4092bf1a1df0f4de7126bb2f7ce69d7a005affb5">BM_SUB</a>);
<a name="l01319"></a>01319         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l01320"></a>01320     }
<a name="l01321"></a>01321 
<a name="l01322"></a>01322 <span class="comment"></span>
<a name="l01323"></a>01323 <span class="comment">    /*!</span>
<a name="l01324"></a>01324 <span class="comment">       \brief Sets new blocks allocation strategy.</span>
<a name="l01325"></a>01325 <span class="comment">       \param strat - Strategy code 0 - bitblocks allocation only.</span>
<a name="l01326"></a>01326 <span class="comment">                      1 - Blocks mutation mode (adaptive algorithm)</span>
<a name="l01327"></a>01327 <span class="comment">    */</span>
<a name="l01328"></a><a class="code" href="a00043.html#a653ee052b297a49c35344704df67a452">01328</a>     <span class="keywordtype">void</span> <a class="code" href="a00043.html#a653ee052b297a49c35344704df67a452" title="Sets new blocks allocation strategy.">set_new_blocks_strat</a>(<a class="code" href="a00118.html#gad0b87b3b7292383a864d27feaf1c9eff" title="Block allocation strategies.">strategy</a> strat) 
<a name="l01329"></a>01329     { 
<a name="l01330"></a>01330         new_blocks_strat_ = strat; 
<a name="l01331"></a>01331     }
<a name="l01332"></a>01332 <span class="comment"></span>
<a name="l01333"></a>01333 <span class="comment">    /*!</span>
<a name="l01334"></a>01334 <span class="comment">       \brief Returns blocks allocation strategy.</span>
<a name="l01335"></a>01335 <span class="comment">       \return - Strategy code 0 - bitblocks allocation only.</span>
<a name="l01336"></a>01336 <span class="comment">                 1 - Blocks mutation mode (adaptive algorithm)</span>
<a name="l01337"></a>01337 <span class="comment">       \sa set_new_blocks_strat</span>
<a name="l01338"></a>01338 <span class="comment">    */</span>
<a name="l01339"></a><a class="code" href="a00043.html#a1f0f6467c82e6f2385632565e765d524">01339</a>     <a class="code" href="a00118.html#gad0b87b3b7292383a864d27feaf1c9eff" title="Block allocation strategies.">strategy</a>  <a class="code" href="a00043.html#a1f0f6467c82e6f2385632565e765d524" title="Returns blocks allocation strategy.">get_new_blocks_strat</a>()<span class="keyword"> const </span>
<a name="l01340"></a>01340 <span class="keyword">    </span>{ 
<a name="l01341"></a>01341         <span class="keywordflow">return</span> new_blocks_strat_; 
<a name="l01342"></a>01342     }
<a name="l01343"></a>01343 
<a name="l01344"></a>01344 <span class="comment"></span>
<a name="l01345"></a>01345 <span class="comment">    /*! </span>
<a name="l01346"></a>01346 <span class="comment">        \brief Optimization mode</span>
<a name="l01347"></a>01347 <span class="comment">        Every next level means additional checks (better compression vs time)</span>
<a name="l01348"></a>01348 <span class="comment">        \sa optimize</span>
<a name="l01349"></a>01349 <span class="comment">    */</span>
<a name="l01350"></a><a class="code" href="a00043.html#a05f1e977cb5e6208838afc7e7b69e5f0">01350</a>     <span class="keyword">enum</span> <a class="code" href="a00043.html#a05f1e977cb5e6208838afc7e7b69e5f0" title="Optimization mode Every next level means additional checks (better compression vs...">optmode</a>
<a name="l01351"></a>01351     {
<a name="l01352"></a><a class="code" href="a00043.html#a05f1e977cb5e6208838afc7e7b69e5f0af7f71b9fa4aac73572f492b60df4dbbe">01352</a>         <a class="code" href="a00043.html#a05f1e977cb5e6208838afc7e7b69e5f0af7f71b9fa4aac73572f492b60df4dbbe" title="Free unused 0 blocks.">opt_free_0</a>    = 1, <span class="comment">///&lt; Free unused 0 blocks</span>
<a name="l01353"></a><a class="code" href="a00043.html#a05f1e977cb5e6208838afc7e7b69e5f0ad4c02e1ba1f9522be654e0e129ced2fc">01353</a> <span class="comment"></span>        <a class="code" href="a00043.html#a05f1e977cb5e6208838afc7e7b69e5f0ad4c02e1ba1f9522be654e0e129ced2fc" title="Free unused 0 and 1 blocks.">opt_free_01</a>   = 2, <span class="comment">///&lt; Free unused 0 and 1 blocks</span>
<a name="l01354"></a><a class="code" href="a00043.html#a05f1e977cb5e6208838afc7e7b69e5f0a99b64b2444e1a8b22a5e89b02dca6001">01354</a> <span class="comment"></span>        <a class="code" href="a00043.html#a05f1e977cb5e6208838afc7e7b69e5f0a99b64b2444e1a8b22a5e89b02dca6001" title="compress blocks when possible">opt_compress</a>  = 3  <span class="comment">///&lt; compress blocks when possible</span>
<a name="l01355"></a>01355 <span class="comment"></span>    };
<a name="l01356"></a>01356 <span class="comment"></span>
<a name="l01357"></a>01357 <span class="comment">    /*!</span>
<a name="l01358"></a>01358 <span class="comment">       \brief Optimize memory bitvector&apos;s memory allocation.</span>
<a name="l01359"></a>01359 <span class="comment">   </span>
<a name="l01360"></a>01360 <span class="comment">       Function analyze all blocks in the bitvector, compresses blocks </span>
<a name="l01361"></a>01361 <span class="comment">       with a regular structure, frees some memory. This function is recommended</span>
<a name="l01362"></a>01362 <span class="comment">       after a bulk modification of the bitvector using set_bit, clear_bit or</span>
<a name="l01363"></a>01363 <span class="comment">       logical operations.</span>
<a name="l01364"></a>01364 <span class="comment"></span>
<a name="l01365"></a>01365 <span class="comment">       Optionally function can calculate vector post optimization statistics</span>
<a name="l01366"></a>01366 <span class="comment">       </span>
<a name="l01367"></a>01367 <span class="comment">       @sa optmode, optimize_gap_size</span>
<a name="l01368"></a>01368 <span class="comment">    */</span>
<a name="l01369"></a>01369     <span class="keywordtype">void</span> <a class="code" href="a00043.html#a622e6827d799a561e2f0db28f7ac19d2" title="Optimize memory bitvector&amp;#39;s memory allocation.">optimize</a>(<a class="code" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a>* temp_block = 0, 
<a name="l01370"></a>01370                   <a class="code" href="a00043.html#a05f1e977cb5e6208838afc7e7b69e5f0" title="Optimization mode Every next level means additional checks (better compression vs...">optmode</a> opt_mode       = <a class="code" href="a00043.html#a05f1e977cb5e6208838afc7e7b69e5f0a99b64b2444e1a8b22a5e89b02dca6001" title="compress blocks when possible">opt_compress</a>,
<a name="l01371"></a>01371                   statistics* stat       = 0);
<a name="l01372"></a>01372 <span class="comment"></span>
<a name="l01373"></a>01373 <span class="comment">    /*!</span>
<a name="l01374"></a>01374 <span class="comment">       \brief Optimize sizes of GAP blocks</span>
<a name="l01375"></a>01375 <span class="comment"></span>
<a name="l01376"></a>01376 <span class="comment">       This method runs an analysis to find optimal GAP levels for the </span>
<a name="l01377"></a>01377 <span class="comment">       specific vector. Current GAP compression algorithm uses several fixed</span>
<a name="l01378"></a>01378 <span class="comment">       GAP sizes. By default bvector uses some reasonable preset. </span>
<a name="l01379"></a>01379 <span class="comment">    */</span>
<a name="l01380"></a>01380     <span class="keywordtype">void</span> <a class="code" href="a00043.html#aaa2d954f42ea75520b8795066302daab" title="Optimize sizes of GAP blocks.">optimize_gap_size</a>();
<a name="l01381"></a>01381 
<a name="l01382"></a>01382 <span class="comment"></span>
<a name="l01383"></a>01383 <span class="comment">    /*!</span>
<a name="l01384"></a>01384 <span class="comment">        @brief Sets new GAP lengths table. All GAP blocks will be reallocated </span>
<a name="l01385"></a>01385 <span class="comment">        to match the new scheme.</span>
<a name="l01386"></a>01386 <span class="comment"></span>
<a name="l01387"></a>01387 <span class="comment">        @param glevel_len - pointer on C-style array keeping GAP block sizes. </span>
<a name="l01388"></a>01388 <span class="comment">    */</span>
<a name="l01389"></a>01389     <span class="keywordtype">void</span> <a class="code" href="a00043.html#a14f9b220fec8e7b65e4e5ed2832af96b" title="Sets new GAP lengths table. All GAP blocks will be reallocated to match the new scheme...">set_gap_levels</a>(<span class="keyword">const</span> <a class="code" href="a00115.html#ac654d6319039a86546d235a236fc7cf6">gap_word_t</a>* glevel_len);
<a name="l01390"></a>01390 <span class="comment"></span>
<a name="l01391"></a>01391 <span class="comment">    /*!</span>
<a name="l01392"></a>01392 <span class="comment">        \brief Lexicographical comparison with a bitvector.</span>
<a name="l01393"></a>01393 <span class="comment"></span>
<a name="l01394"></a>01394 <span class="comment">        Function compares current bitvector with the provided argument </span>
<a name="l01395"></a>01395 <span class="comment">        bit by bit and returns -1 if our bitvector less than the argument, </span>
<a name="l01396"></a>01396 <span class="comment">        1 - greater, 0 - equal.</span>
<a name="l01397"></a>01397 <span class="comment">    */</span>
<a name="l01398"></a>01398     <span class="keywordtype">int</span> <a class="code" href="a00043.html#a4dbc98ea637b352635549814982d4c28" title="Lexicographical comparison with a bitvector.">compare</a>(<span class="keyword">const</span> <a class="code" href="a00043.html" title="bitvector with runtime compression of bits.">bvector&lt;Alloc&gt;</a>&amp; <a class="code" href="a00043.html" title="bitvector with runtime compression of bits.">bvect</a>) <span class="keyword">const</span>;
<a name="l01399"></a>01399 <span class="comment"></span>
<a name="l01400"></a>01400 <span class="comment">    /*! @brief Allocates temporary block of memory. </span>
<a name="l01401"></a>01401 <span class="comment"></span>
<a name="l01402"></a>01402 <span class="comment">        Temp block can be passed to bvector functions requiring some temp memory</span>
<a name="l01403"></a>01403 <span class="comment">        for their operation. (like serialize)</span>
<a name="l01404"></a>01404 <span class="comment">        </span>
<a name="l01405"></a>01405 <span class="comment">        @note method is marked const, but it&apos;s not quite true, since</span>
<a name="l01406"></a>01406 <span class="comment">        it can in some cases modify the state of the block allocator</span>
<a name="l01407"></a>01407 <span class="comment">        (if it has a state). (Can be important in MT programs).</span>
<a name="l01408"></a>01408 <span class="comment"></span>
<a name="l01409"></a>01409 <span class="comment">        @sa free_tempblock</span>
<a name="l01410"></a>01410 <span class="comment">    */</span>
<a name="l01411"></a><a class="code" href="a00043.html#a6017430e30c7317ae5ecb0ce1d7a09b2">01411</a>     <a class="code" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a>* <a class="code" href="a00043.html#a6017430e30c7317ae5ecb0ce1d7a09b2" title="Allocates temporary block of memory.">allocate_tempblock</a>()<span class="keyword"> const</span>
<a name="l01412"></a>01412 <span class="keyword">    </span>{
<a name="l01413"></a>01413         <a class="code" href="a00043.html#a6fdfeafe05217c31cdc9140b7642b611">blocks_manager_type</a>* bm = 
<a name="l01414"></a>01414             <span class="keyword">const_cast&lt;</span><a class="code" href="a00043.html#a6fdfeafe05217c31cdc9140b7642b611">blocks_manager_type</a>*<span class="keyword">&gt;</span>(&amp;blockman_);
<a name="l01415"></a>01415         <span class="keywordflow">return</span> bm-&gt;get_allocator().alloc_bit_block();
<a name="l01416"></a>01416     }
<a name="l01417"></a>01417 <span class="comment"></span>
<a name="l01418"></a>01418 <span class="comment">    /*! @brief Frees temporary block of memory. </span>
<a name="l01419"></a>01419 <span class="comment"></span>
<a name="l01420"></a>01420 <span class="comment">        @note method is marked const, but it&apos;s not quite true, since</span>
<a name="l01421"></a>01421 <span class="comment">        it can in some cases modify the state of the block allocator</span>
<a name="l01422"></a>01422 <span class="comment">        (if it has a state). (Can be important in MT programs).</span>
<a name="l01423"></a>01423 <span class="comment"></span>
<a name="l01424"></a>01424 <span class="comment">        @sa allocate_tempblock</span>
<a name="l01425"></a>01425 <span class="comment">    */</span>
<a name="l01426"></a><a class="code" href="a00043.html#a71e406dcb927082f2970ccbc3b95aec0">01426</a>     <span class="keywordtype">void</span> <a class="code" href="a00043.html#a71e406dcb927082f2970ccbc3b95aec0" title="Frees temporary block of memory.">free_tempblock</a>(<a class="code" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a>* block)<span class="keyword"> const</span>
<a name="l01427"></a>01427 <span class="keyword">    </span>{
<a name="l01428"></a>01428         <a class="code" href="a00043.html#a6fdfeafe05217c31cdc9140b7642b611">blocks_manager_type</a>* bm = 
<a name="l01429"></a>01429             <span class="keyword">const_cast&lt;</span><a class="code" href="a00043.html#a6fdfeafe05217c31cdc9140b7642b611">blocks_manager_type</a>*<span class="keyword">&gt;</span>(&amp;blockman_);
<a name="l01430"></a>01430         bm-&gt;get_allocator().free_bit_block(block);
<a name="l01431"></a>01431     }
<a name="l01432"></a>01432 <span class="comment"></span>
<a name="l01433"></a>01433 <span class="comment">    /**</span>
<a name="l01434"></a>01434 <span class="comment">       \brief Returns enumerator pointing on the first non-zero bit.</span>
<a name="l01435"></a>01435 <span class="comment">    */</span>
<a name="l01436"></a><a class="code" href="a00043.html#ae19358b9022b2a870c4fa151dbf92a01">01436</a>     <a class="code" href="a00062.html" title="Constant input iterator designed to enumerate &amp;quot;ON&amp;quot; bits.">enumerator</a> <a class="code" href="a00043.html#ae19358b9022b2a870c4fa151dbf92a01" title="Returns enumerator pointing on the first non-zero bit.">first</a>()<span class="keyword"> const</span>
<a name="l01437"></a>01437 <span class="keyword">    </span>{
<a name="l01438"></a>01438         <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="a00062.html" title="Constant input iterator designed to enumerate &amp;quot;ON&amp;quot; bits.">bvector&lt;Alloc&gt;::enumerator</a> enumerator_type;
<a name="l01439"></a>01439         <span class="keywordflow">return</span> enumerator_type(<span class="keyword">this</span>, 0);
<a name="l01440"></a>01440     }
<a name="l01441"></a>01441 <span class="comment"></span>
<a name="l01442"></a>01442 <span class="comment">    /**</span>
<a name="l01443"></a>01443 <span class="comment">       \fn bvector::enumerator bvector::end() const</span>
<a name="l01444"></a>01444 <span class="comment">       \brief Returns enumerator pointing on the next bit after the last.</span>
<a name="l01445"></a>01445 <span class="comment">    */</span>
<a name="l01446"></a><a class="code" href="a00043.html#ad94dc3beb5a3c266c7612e46f5e0351b">01446</a>     <a class="code" href="a00062.html" title="Constant input iterator designed to enumerate &amp;quot;ON&amp;quot; bits.">enumerator</a> <a class="code" href="a00043.html#ad94dc3beb5a3c266c7612e46f5e0351b" title="Returns enumerator pointing on the next bit after the last.">end</a>()<span class="keyword"> const</span>
<a name="l01447"></a>01447 <span class="keyword">    </span>{
<a name="l01448"></a>01448         <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="a00062.html" title="Constant input iterator designed to enumerate &amp;quot;ON&amp;quot; bits.">bvector&lt;Alloc&gt;::enumerator</a> enumerator_type;
<a name="l01449"></a>01449         <span class="keywordflow">return</span> enumerator_type(<span class="keyword">this</span>, 1);
<a name="l01450"></a>01450     }
<a name="l01451"></a>01451 
<a name="l01452"></a>01452 
<a name="l01453"></a><a class="code" href="a00043.html#a094da2120fda810d06fb576ac78ff502">01453</a>     <span class="keyword">const</span> <a class="code" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a>* <a class="code" href="a00043.html#a094da2120fda810d06fb576ac78ff502">get_block</a>(<span class="keywordtype">unsigned</span> nb)<span class="keyword"> const </span>
<a name="l01454"></a>01454 <span class="keyword">    </span>{ 
<a name="l01455"></a>01455         <span class="keywordflow">return</span> blockman_.get_block(nb); 
<a name="l01456"></a>01456     }
<a name="l01457"></a>01457     
<a name="l01458"></a>01458     <span class="keywordtype">void</span> <a class="code" href="a00043.html#ae57f6d62d1f54eeaa604ae7ce53e0e0f">combine_operation</a>(<span class="keyword">const</span> <a class="code" href="a00043.html" title="bitvector with runtime compression of bits.">bm::bvector&lt;Alloc&gt;</a>&amp; <a class="code" href="a00043.html" title="bitvector with runtime compression of bits.">bvect</a>, 
<a name="l01459"></a>01459                             <a class="code" href="a00115.html#a42405343976ec931388381cea4092bf1" title="Bit operations enumeration.">bm::operation</a>            opcode);
<a name="l01460"></a>01460     
<a name="l01461"></a>01461 <span class="keyword">private</span>:
<a name="l01462"></a>01462 
<a name="l01463"></a>01463     <a class="code" href="a00115.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a> check_or_next(<a class="code" href="a00115.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a> prev) <span class="keyword">const</span>;
<a name="l01464"></a>01464     <span class="comment"></span>
<a name="l01465"></a>01465 <span class="comment">    /// check if specified bit is 1, and set it to 0</span>
<a name="l01466"></a>01466 <span class="comment">    /// if specified bit is 0, scan for the next 1 and returns it</span>
<a name="l01467"></a>01467 <span class="comment">    /// if no 1 found returns 0</span>
<a name="l01468"></a>01468 <span class="comment"></span>    <a class="code" href="a00115.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a> check_or_next_extract(<a class="code" href="a00115.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a> prev);
<a name="l01469"></a>01469 <span class="comment"></span>
<a name="l01470"></a>01470 <span class="comment">    /**</span>
<a name="l01471"></a>01471 <span class="comment">        \brief Set specified bit without checking preconditions (size, etc)</span>
<a name="l01472"></a>01472 <span class="comment">    */</span>
<a name="l01473"></a>01473     <span class="keywordtype">bool</span> set_bit_no_check(<a class="code" href="a00115.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a> n, <span class="keywordtype">bool</span> val);
<a name="l01474"></a>01474 <span class="comment"></span>
<a name="l01475"></a>01475 <span class="comment">    /**</span>
<a name="l01476"></a>01476 <span class="comment">        \brief AND specified bit without checking preconditions (size, etc)</span>
<a name="l01477"></a>01477 <span class="comment">    */</span>
<a name="l01478"></a>01478     <span class="keywordtype">bool</span> and_bit_no_check(<a class="code" href="a00115.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a> n, <span class="keywordtype">bool</span> val);
<a name="l01479"></a>01479 
<a name="l01480"></a>01480     <span class="keywordtype">bool</span> set_bit_conditional_impl(<a class="code" href="a00115.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a> n, <span class="keywordtype">bool</span> val, <span class="keywordtype">bool</span> condition);
<a name="l01481"></a>01481 
<a name="l01482"></a>01482 
<a name="l01483"></a>01483     <span class="keywordtype">void</span> combine_operation_with_block(<span class="keywordtype">unsigned</span> nb,
<a name="l01484"></a>01484                                       <span class="keywordtype">unsigned</span> gap,
<a name="l01485"></a>01485                                       <a class="code" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a>* blk,
<a name="l01486"></a>01486                                       <span class="keyword">const</span> <a class="code" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a>* arg_blk,
<a name="l01487"></a>01487                                       <span class="keywordtype">int</span> arg_gap,
<a name="l01488"></a>01488                                       <a class="code" href="a00115.html#a42405343976ec931388381cea4092bf1" title="Bit operations enumeration.">bm::operation</a> opcode);
<a name="l01489"></a>01489 <span class="keyword">public</span>:
<a name="l01490"></a><a class="code" href="a00043.html#a85f14d49321128ed4dc319949ab2cca9">01490</a>     <span class="keywordtype">void</span> combine_operation_with_block(<span class="keywordtype">unsigned</span> nb,
<a name="l01491"></a>01491                                       <span class="keyword">const</span> <a class="code" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a>* arg_blk,
<a name="l01492"></a>01492                                       <span class="keywordtype">int</span> arg_gap,
<a name="l01493"></a>01493                                       <a class="code" href="a00115.html#a42405343976ec931388381cea4092bf1" title="Bit operations enumeration.">bm::operation</a> opcode)
<a name="l01494"></a>01494     {
<a name="l01495"></a>01495         <a class="code" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a>* blk = <span class="keyword">const_cast&lt;</span><a class="code" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a>*<span class="keyword">&gt;</span>(<a class="code" href="a00043.html#a094da2120fda810d06fb576ac78ff502">get_block</a>(nb));
<a name="l01496"></a>01496         <span class="keywordtype">bool</span> gap = <a class="code" href="a00092.html#a7bc243edc0a5e82979d6bf63f4debb9a">BM_IS_GAP</a>(blk);
<a name="l01497"></a>01497         combine_operation_with_block(nb, gap, blk, arg_blk, arg_gap, opcode);
<a name="l01498"></a>01498     }
<a name="l01499"></a>01499 <span class="keyword">private</span>:
<a name="l01500"></a>01500     <span class="keywordtype">void</span> <a class="code" href="a00115.html#a5e19a65218d5423e3ae1e426ac37a378" title="Internal function computes different distance metrics.">combine_count_operation_with_block</a>(<span class="keywordtype">unsigned</span> nb,
<a name="l01501"></a>01501                                             <span class="keyword">const</span> <a class="code" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a>* arg_blk,
<a name="l01502"></a>01502                                             <span class="keywordtype">int</span> arg_gap,
<a name="l01503"></a>01503                                             <a class="code" href="a00115.html#a42405343976ec931388381cea4092bf1" title="Bit operations enumeration.">bm::operation</a> opcode)
<a name="l01504"></a>01504     {
<a name="l01505"></a>01505         <span class="keyword">const</span> <a class="code" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a>* blk = <a class="code" href="a00043.html#a094da2120fda810d06fb576ac78ff502">get_block</a>(nb);
<a name="l01506"></a>01506         <span class="keywordtype">bool</span> gap = <a class="code" href="a00092.html#a7bc243edc0a5e82979d6bf63f4debb9a">BM_IS_GAP</a>(blk);
<a name="l01507"></a>01507         <a class="code" href="a00115.html#a5e19a65218d5423e3ae1e426ac37a378" title="Internal function computes different distance metrics.">combine_count_operation_with_block</a>(nb, gap, blk, arg_blk, arg_gap, opcode);
<a name="l01508"></a>01508     }
<a name="l01509"></a>01509 
<a name="l01510"></a>01510 <span class="comment"></span>
<a name="l01511"></a>01511 <span class="comment">    /**</span>
<a name="l01512"></a>01512 <span class="comment">       \brief Extends GAP block to the next level or converts it to bit block.</span>
<a name="l01513"></a>01513 <span class="comment">       \param nb - Block&apos;s linear index.</span>
<a name="l01514"></a>01514 <span class="comment">       \param blk - Blocks&apos;s pointer </span>
<a name="l01515"></a>01515 <span class="comment">    */</span>
<a name="l01516"></a>01516     <span class="keywordtype">void</span> extend_gap_block(<span class="keywordtype">unsigned</span> nb, <a class="code" href="a00115.html#ac654d6319039a86546d235a236fc7cf6">gap_word_t</a>* blk)
<a name="l01517"></a>01517     {
<a name="l01518"></a>01518         blockman_.extend_gap_block(nb, blk);
<a name="l01519"></a>01519     }
<a name="l01520"></a>01520 <span class="comment"></span>
<a name="l01521"></a>01521 <span class="comment">    /**</span>
<a name="l01522"></a>01522 <span class="comment">       \brief Set range without validity checking</span>
<a name="l01523"></a>01523 <span class="comment">    */</span>
<a name="l01524"></a>01524     <span class="keywordtype">void</span> set_range_no_check(<a class="code" href="a00115.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a> left,
<a name="l01525"></a>01525                             <a class="code" href="a00115.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a> right,
<a name="l01526"></a>01526                             <span class="keywordtype">bool</span>     value);
<a name="l01527"></a>01527 <span class="keyword">public</span>:
<a name="l01528"></a>01528 
<a name="l01529"></a><a class="code" href="a00043.html#a9714e6ae14a0162fa0b748cd09df162d">01529</a>     <span class="keyword">const</span> <a class="code" href="a00043.html#a6fdfeafe05217c31cdc9140b7642b611">blocks_manager_type</a>&amp; <a class="code" href="a00043.html#a9714e6ae14a0162fa0b748cd09df162d">get_blocks_manager</a>()<span class="keyword"> const</span>
<a name="l01530"></a>01530 <span class="keyword">    </span>{
<a name="l01531"></a>01531         <span class="keywordflow">return</span> blockman_;
<a name="l01532"></a>01532     }
<a name="l01533"></a>01533 
<a name="l01534"></a><a class="code" href="a00043.html#afe10cd231a9fe147810ba8d359cefac1">01534</a>     <a class="code" href="a00043.html#a6fdfeafe05217c31cdc9140b7642b611">blocks_manager_type</a>&amp; <a class="code" href="a00043.html#a9714e6ae14a0162fa0b748cd09df162d">get_blocks_manager</a>()
<a name="l01535"></a>01535     {
<a name="l01536"></a>01536         <span class="keywordflow">return</span> blockman_;
<a name="l01537"></a>01537     }
<a name="l01538"></a>01538 
<a name="l01539"></a>01539 
<a name="l01540"></a>01540 <span class="keyword">private</span>:
<a name="l01541"></a>01541 
<a name="l01542"></a>01542 <span class="comment">// This block defines two additional hidden variables used for bitcount</span>
<a name="l01543"></a>01543 <span class="comment">// optimization, in rare cases can make bitvector thread unsafe.</span>
<a name="l01544"></a>01544 <span class="preprocessor">#ifdef BMCOUNTOPT</span>
<a name="l01545"></a>01545 <span class="preprocessor"></span>    <span class="keyword">mutable</span> <a class="code" href="a00115.html#aa3824d882a037396370b16f2f0a8bf37">id_t</a>      count_;            <span class="comment">//!&lt; number of 1 bits in the vector</span>
<a name="l01546"></a>01546 <span class="comment"></span>    <span class="keyword">mutable</span> <span class="keywordtype">bool</span>      count_is_valid_;   <span class="comment">//!&lt; actualization flag</span>
<a name="l01547"></a>01547 <span class="comment"></span><span class="preprocessor">#endif</span>
<a name="l01548"></a>01548 <span class="preprocessor"></span>
<a name="l01549"></a>01549     <a class="code" href="a00043.html#a6fdfeafe05217c31cdc9140b7642b611">blocks_manager_type</a>  blockman_;         <span class="comment">//!&lt; bitblocks manager</span>
<a name="l01550"></a>01550 <span class="comment"></span>    <a class="code" href="a00118.html#gad0b87b3b7292383a864d27feaf1c9eff" title="Block allocation strategies.">strategy</a>             new_blocks_strat_; <span class="comment">//!&lt; block allocation strategy</span>
<a name="l01551"></a>01551 <span class="comment"></span>    <a class="code" href="a00043.html#a405dd9ed048c935c84a5086ec8ba3649" title="Type used to count bits in the bit vector.">size_type</a>            size_;             <span class="comment">//!&lt; size in bits</span>
<a name="l01552"></a>01552 <span class="comment"></span>};
<a name="l01553"></a>01553 
<a name="l01554"></a>01554 
<a name="l01555"></a>01555 
<a name="l01556"></a>01556 
<a name="l01557"></a>01557 
<a name="l01558"></a>01558 <span class="comment">//---------------------------------------------------------------------</span>
<a name="l01559"></a>01559 
<a name="l01560"></a>01560 <span class="keyword">template</span>&lt;<span class="keyword">class</span> Alloc&gt; 
<a name="l01561"></a><a class="code" href="a00115.html#a9642fa6fb00fb9de2406e1eaea44b88d">01561</a> <span class="keyword">inline</span> <a class="code" href="a00043.html" title="bitvector with runtime compression of bits.">bvector&lt;Alloc&gt;</a> <a class="code" href="a00115.html#a9642fa6fb00fb9de2406e1eaea44b88d">operator&amp; </a>(<span class="keyword">const</span> <a class="code" href="a00043.html" title="bitvector with runtime compression of bits.">bvector&lt;Alloc&gt;</a>&amp; v1,
<a name="l01562"></a>01562                                  <span class="keyword">const</span> <a class="code" href="a00043.html" title="bitvector with runtime compression of bits.">bvector&lt;Alloc&gt;</a>&amp; v2)
<a name="l01563"></a>01563 {
<a name="l01564"></a>01564 <span class="preprocessor">#ifdef BM_USE_EXPLICIT_TEMP</span>
<a name="l01565"></a>01565 <span class="preprocessor"></span>    <a class="code" href="a00043.html" title="bitvector with runtime compression of bits.">bvector&lt;Alloc, MS&gt;</a> ret(v1);
<a name="l01566"></a>01566     ret.<a class="code" href="a00043.html#a91a3bec58760e4a6ebb94cc990b45b92" title="Logical AND operation.">bit_and</a>(v2);
<a name="l01567"></a>01567     <span class="keywordflow">return</span> ret;
<a name="l01568"></a>01568 <span class="preprocessor">#else    </span>
<a name="l01569"></a>01569 <span class="preprocessor"></span>    <span class="keywordflow">return</span> <a class="code" href="a00043.html" title="bitvector with runtime compression of bits.">bvector&lt;Alloc&gt;</a>(v1).bit_and(v2);
<a name="l01570"></a>01570 <span class="preprocessor">#endif</span>
<a name="l01571"></a>01571 <span class="preprocessor"></span>}
<a name="l01572"></a>01572 
<a name="l01573"></a>01573 <span class="comment">//---------------------------------------------------------------------</span>
<a name="l01574"></a>01574 
<a name="l01575"></a>01575 <span class="keyword">template</span>&lt;<span class="keyword">class</span> Alloc&gt; 
<a name="l01576"></a><a class="code" href="a00115.html#acc5d3d9d78d8edbc6dba501c479c789e">01576</a> <span class="keyword">inline</span> <a class="code" href="a00043.html" title="bitvector with runtime compression of bits.">bvector&lt;Alloc&gt;</a> <a class="code" href="a00115.html#acc5d3d9d78d8edbc6dba501c479c789e">operator| </a>(<span class="keyword">const</span> <a class="code" href="a00043.html" title="bitvector with runtime compression of bits.">bvector&lt;Alloc&gt;</a>&amp; v1,
<a name="l01577"></a>01577                                  <span class="keyword">const</span> <a class="code" href="a00043.html" title="bitvector with runtime compression of bits.">bvector&lt;Alloc&gt;</a>&amp; v2)
<a name="l01578"></a>01578 {
<a name="l01579"></a>01579 <span class="preprocessor">#ifdef BM_USE_EXPLICIT_TEMP</span>
<a name="l01580"></a>01580 <span class="preprocessor"></span>    <a class="code" href="a00043.html" title="bitvector with runtime compression of bits.">bvector&lt;Alloc, MS&gt;</a> ret(v1);
<a name="l01581"></a>01581     ret.<a class="code" href="a00043.html#ae2baf80dfd32cd252991a97250989a5d" title="Logical OR operation.">bit_or</a>(v2);
<a name="l01582"></a>01582     <span class="keywordflow">return</span> ret;
<a name="l01583"></a>01583 <span class="preprocessor">#else    </span>
<a name="l01584"></a>01584 <span class="preprocessor"></span>    <span class="keywordflow">return</span> <a class="code" href="a00043.html" title="bitvector with runtime compression of bits.">bvector&lt;Alloc&gt;</a>(v1).bit_or(v2);
<a name="l01585"></a>01585 <span class="preprocessor">#endif</span>
<a name="l01586"></a>01586 <span class="preprocessor"></span>}
<a name="l01587"></a>01587 
<a name="l01588"></a>01588 <span class="comment">//---------------------------------------------------------------------</span>
<a name="l01589"></a>01589 
<a name="l01590"></a>01590 <span class="keyword">template</span>&lt;<span class="keyword">class</span> Alloc&gt; 
<a name="l01591"></a><a class="code" href="a00115.html#aeaf93e15a099b98ae8e314142c70f63a">01591</a> <span class="keyword">inline</span> <a class="code" href="a00043.html" title="bitvector with runtime compression of bits.">bvector&lt;Alloc&gt;</a> <a class="code" href="a00115.html#aeaf93e15a099b98ae8e314142c70f63a">operator^ </a>(<span class="keyword">const</span> <a class="code" href="a00043.html" title="bitvector with runtime compression of bits.">bvector&lt;Alloc&gt;</a>&amp; v1,
<a name="l01592"></a>01592                                  <span class="keyword">const</span> <a class="code" href="a00043.html" title="bitvector with runtime compression of bits.">bvector&lt;Alloc&gt;</a>&amp; v2)
<a name="l01593"></a>01593 {
<a name="l01594"></a>01594 <span class="preprocessor">#ifdef BM_USE_EXPLICIT_TEMP</span>
<a name="l01595"></a>01595 <span class="preprocessor"></span>    <a class="code" href="a00043.html" title="bitvector with runtime compression of bits.">bvector&lt;Alloc, MS&gt;</a> ret(v1);
<a name="l01596"></a>01596     ret.<a class="code" href="a00043.html#a65a935b2d8b0d8c4732aef26ef40712d" title="Logical XOR operation.">bit_xor</a>(v2);
<a name="l01597"></a>01597     <span class="keywordflow">return</span> ret;
<a name="l01598"></a>01598 <span class="preprocessor">#else    </span>
<a name="l01599"></a>01599 <span class="preprocessor"></span>    <span class="keywordflow">return</span> <a class="code" href="a00043.html" title="bitvector with runtime compression of bits.">bvector&lt;Alloc&gt;</a>(v1).bit_xor(v2);
<a name="l01600"></a>01600 <span class="preprocessor">#endif</span>
<a name="l01601"></a>01601 <span class="preprocessor"></span>}
<a name="l01602"></a>01602 
<a name="l01603"></a>01603 <span class="comment">//---------------------------------------------------------------------</span>
<a name="l01604"></a>01604 
<a name="l01605"></a>01605 <span class="keyword">template</span>&lt;<span class="keyword">class</span> Alloc&gt; 
<a name="l01606"></a><a class="code" href="a00115.html#ac7b828f11454f40bcd07e6abc60990f2">01606</a> <span class="keyword">inline</span> <a class="code" href="a00043.html" title="bitvector with runtime compression of bits.">bvector&lt;Alloc&gt;</a> <a class="code" href="a00115.html#ac7b828f11454f40bcd07e6abc60990f2">operator- </a>(<span class="keyword">const</span> <a class="code" href="a00043.html" title="bitvector with runtime compression of bits.">bvector&lt;Alloc&gt;</a>&amp; v1,
<a name="l01607"></a>01607                                  <span class="keyword">const</span> <a class="code" href="a00043.html" title="bitvector with runtime compression of bits.">bvector&lt;Alloc&gt;</a>&amp; v2)
<a name="l01608"></a>01608 {
<a name="l01609"></a>01609 <span class="preprocessor">#ifdef BM_USE_EXPLICIT_TEMP</span>
<a name="l01610"></a>01610 <span class="preprocessor"></span>    <a class="code" href="a00043.html" title="bitvector with runtime compression of bits.">bvector&lt;Alloc, MS&gt;</a> ret(v1);
<a name="l01611"></a>01611     ret.<a class="code" href="a00043.html#af39d2f17f005e5028b1eb3007f8e0e0c" title="Logical SUB operation.">bit_sub</a>(v2);
<a name="l01612"></a>01612     <span class="keywordflow">return</span> ret;
<a name="l01613"></a>01613 <span class="preprocessor">#else    </span>
<a name="l01614"></a>01614 <span class="preprocessor"></span>    <span class="keywordflow">return</span> <a class="code" href="a00043.html" title="bitvector with runtime compression of bits.">bvector&lt;Alloc&gt;</a>(v1).bit_sub(v2);
<a name="l01615"></a>01615 <span class="preprocessor">#endif</span>
<a name="l01616"></a>01616 <span class="preprocessor"></span>}
<a name="l01617"></a>01617 
<a name="l01618"></a>01618 
<a name="l01619"></a>01619 
<a name="l01620"></a>01620 
<a name="l01621"></a>01621 <span class="comment">// -----------------------------------------------------------------------</span>
<a name="l01622"></a>01622 
<a name="l01623"></a>01623 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Alloc&gt; 
<a name="l01624"></a><a class="code" href="a00043.html#ae14650ede7559f896894f951810cadbf">01624</a> <a class="code" href="a00043.html" title="bitvector with runtime compression of bits.">bvector&lt;Alloc&gt;</a>&amp; <a class="code" href="a00043.html#ae14650ede7559f896894f951810cadbf" title="Sets all bits in the specified closed interval [left,right] Interval must be inside...">bvector&lt;Alloc&gt;::set_range</a>(<a class="code" href="a00115.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a> left,
<a name="l01625"></a>01625                                           <a class="code" href="a00115.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a> right,
<a name="l01626"></a>01626                                           <span class="keywordtype">bool</span>     value)
<a name="l01627"></a>01627 {
<a name="l01628"></a>01628     <span class="keywordflow">if</span> (right &lt; left)
<a name="l01629"></a>01629     {
<a name="l01630"></a>01630         <span class="keywordflow">return</span> <a class="code" href="a00043.html#ae14650ede7559f896894f951810cadbf" title="Sets all bits in the specified closed interval [left,right] Interval must be inside...">set_range</a>(right, left, value);
<a name="l01631"></a>01631     }
<a name="l01632"></a>01632 
<a name="l01633"></a>01633     <a class="code" href="a00092.html#aa44515fab0ace8928d1cb82009a95bf8">BM_ASSERT</a>(left &lt; size_);
<a name="l01634"></a>01634     <a class="code" href="a00092.html#aa44515fab0ace8928d1cb82009a95bf8">BM_ASSERT</a>(right &lt; size_);
<a name="l01635"></a>01635 
<a name="l01636"></a>01636     <a class="code" href="a00087.html#a835c3ed1c5956735e59744cff81244dc">BMCOUNT_VALID</a>(<span class="keyword">false</span>)
<a name="l01637"></a>01637     <a class="code" href="a00092.html#a7e6f87ba3230dece2125af5c32e84b05">BM_SET_MMX_GUARD</a>
<a name="l01638"></a>01638 
<a name="l01639"></a>01639     set_range_no_check(left, right, value);
<a name="l01640"></a>01640 
<a name="l01641"></a>01641     <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l01642"></a>01642 }
<a name="l01643"></a>01643 
<a name="l01644"></a>01644 <span class="comment">// -----------------------------------------------------------------------</span>
<a name="l01645"></a>01645 
<a name="l01646"></a>01646 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Alloc&gt; 
<a name="l01647"></a><a class="code" href="a00043.html#aceb122f712580c4be455099784bea72f">01647</a> <a class="code" href="a00115.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a> <a class="code" href="a00043.html#aceb122f712580c4be455099784bea72f" title="Returns count of bits which are 1.">bvector&lt;Alloc&gt;::count</a>()<span class="keyword"> const</span>
<a name="l01648"></a>01648 <span class="keyword"></span>{
<a name="l01649"></a>01649 <span class="preprocessor">#ifdef BMCOUNTOPT</span>
<a name="l01650"></a>01650 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (count_is_valid_) <span class="keywordflow">return</span> count_;
<a name="l01651"></a>01651 <span class="preprocessor">#endif</span>
<a name="l01652"></a>01652 <span class="preprocessor"></span>    <a class="code" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">word_t</a>*** blk_root = blockman_.get_rootblock();
<a name="l01653"></a>01653     <span class="keywordflow">if</span> (!blk_root) 
<a name="l01654"></a>01654     {
<a name="l01655"></a>01655         <a class="code" href="a00087.html#a1fbebc7fe3c22d768ff6e240437ee8f4">BMCOUNT_SET</a>(0);
<a name="l01656"></a>01656         <span class="keywordflow">return</span> 0;
<a name="l01657"></a>01657     }    
<a name="l01658"></a>01658     <span class="keyword">typename</span> blocks_manager_type::block_count_func func(blockman_);
<a name="l01659"></a>01659     <a class="code" href="a00115.html#ac6f5529fcc26412fc796b85770aa3a26">for_each_nzblock2</a>(blk_root, blockman_.effective_top_block_size(), 
<a name="l01660"></a>01660                       func);
<a name="l01661"></a>01661 
<a name="l01662"></a>01662     <a class="code" href="a00087.html#a1fbebc7fe3c22d768ff6e240437ee8f4">BMCOUNT_SET</a>(func.count());
<a name="l01663"></a>01663     <span class="keywordflow">return</span> func.count();
<a name="l01664"></a>01664 }
<a name="l01665"></a>01665 
<a name="l01666"></a>01666 <span class="comment">// -----------------------------------------------------------------------</span>
<a name="l01667"></a>01667 
<a name="l01668"></a>01668 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Alloc&gt; 
<a name="l01669"></a><a class="code" href="a00043.html#a56b7573c759e51c8943cf95a82a5b9d6">01669</a> <span class="keywordtype">void</span> <a class="code" href="a00043.html#a56b7573c759e51c8943cf95a82a5b9d6" title="Change size of the bvector.">bvector&lt;Alloc&gt;::resize</a>(size_type new_size)
<a name="l01670"></a>01670 {
<a name="l01671"></a>01671     <span class="keywordflow">if</span> (size_ == new_size) <span class="keywordflow">return</span>; <span class="comment">// nothing to do</span>
<a name="l01672"></a>01672     <span class="keywordflow">if</span> (size_ &lt; new_size) <span class="comment">// size grows </span>
<a name="l01673"></a>01673     {
<a name="l01674"></a>01674         blockman_.reserve(new_size);
<a name="l01675"></a>01675         size_ = new_size;
<a name="l01676"></a>01676     }
<a name="l01677"></a>01677     <span class="keywordflow">else</span> <span class="comment">// shrink</span>
<a name="l01678"></a>01678     {
<a name="l01679"></a>01679         <a class="code" href="a00043.html#ae14650ede7559f896894f951810cadbf" title="Sets all bits in the specified closed interval [left,right] Interval must be inside...">set_range</a>(new_size, size_ - 1, <span class="keyword">false</span>); <span class="comment">// clear the tail</span>
<a name="l01680"></a>01680         size_ = new_size;
<a name="l01681"></a>01681     }
<a name="l01682"></a>01682 }
<a name="l01683"></a>01683 
<a name="l01684"></a>01684 <span class="comment">// -----------------------------------------------------------------------</span>
<a name="l01685"></a>01685 
<a name="l01686"></a>01686 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Alloc&gt; 
<a name="l01687"></a><a class="code" href="a00043.html#adb314a299b9a98954ba1fc5064f279c2">01687</a> <a class="code" href="a00115.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a> <a class="code" href="a00043.html#adb314a299b9a98954ba1fc5064f279c2" title="Returns count of 1 bits in the given diapason.">bvector&lt;Alloc&gt;::count_range</a>(<a class="code" href="a00115.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a> left, 
<a name="l01688"></a>01688                                          <a class="code" href="a00115.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a> right, 
<a name="l01689"></a>01689                                          <span class="keywordtype">unsigned</span>* block_count_arr)<span class="keyword"> const</span>
<a name="l01690"></a>01690 <span class="keyword"></span>{
<a name="l01691"></a>01691     <a class="code" href="a00092.html#aa44515fab0ace8928d1cb82009a95bf8">BM_ASSERT</a>(left &lt;= right);
<a name="l01692"></a>01692 
<a name="l01693"></a>01693     <span class="keywordtype">unsigned</span> <a class="code" href="a00043.html#aceb122f712580c4be455099784bea72f" title="Returns count of bits which are 1.">count</a> = 0;
<a name="l01694"></a>01694 
<a name="l01695"></a>01695     <span class="comment">// calculate logical number of start and destination blocks</span>
<a name="l01696"></a>01696     <span class="keywordtype">unsigned</span> nblock_left  = unsigned(left  &gt;&gt;  <a class="code" href="a00115.html#ad8723fbeea6290d3daa8917ea7ce9bb2">bm::set_block_shift</a>);
<a name="l01697"></a>01697     <span class="keywordtype">unsigned</span> nblock_right = unsigned(right &gt;&gt;  <a class="code" href="a00115.html#ad8723fbeea6290d3daa8917ea7ce9bb2">bm::set_block_shift</a>);
<a name="l01698"></a>01698 
<a name="l01699"></a>01699     <span class="keyword">const</span> <a class="code" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a>* block = blockman_.get_block(nblock_left);
<a name="l01700"></a>01700     <span class="keywordtype">bool</span> left_gap = <a class="code" href="a00092.html#a7bc243edc0a5e82979d6bf63f4debb9a">BM_IS_GAP</a>(block);
<a name="l01701"></a>01701 
<a name="l01702"></a>01702     <span class="keywordtype">unsigned</span> nbit_left  = unsigned(left  &amp; <a class="code" href="a00115.html#a201fb8b1f81b7487f1c1c129fc3d6557">bm::set_block_mask</a>); 
<a name="l01703"></a>01703     <span class="keywordtype">unsigned</span> nbit_right = unsigned(right &amp; bm::set_block_mask); 
<a name="l01704"></a>01704 
<a name="l01705"></a>01705     <span class="keywordtype">unsigned</span> r = 
<a name="l01706"></a>01706         (nblock_left == nblock_right) ? nbit_right : (<a class="code" href="a00115.html#ae9916f69ced0347d94472d7944ea0e45">bm::bits_in_block</a>-1);
<a name="l01707"></a>01707 
<a name="l01708"></a>01708     <span class="keyword">typename</span> blocks_manager_type::block_count_func func(blockman_);
<a name="l01709"></a>01709 
<a name="l01710"></a>01710     <span class="keywordflow">if</span> (block)
<a name="l01711"></a>01711     {
<a name="l01712"></a>01712         <span class="keywordflow">if</span> ((nbit_left == 0) &amp;&amp; (r == (<a class="code" href="a00115.html#ae9916f69ced0347d94472d7944ea0e45">bm::bits_in_block</a>-1))) <span class="comment">// whole block</span>
<a name="l01713"></a>01713         {
<a name="l01714"></a>01714             <span class="keywordflow">if</span> (block_count_arr)
<a name="l01715"></a>01715             {
<a name="l01716"></a>01716                 count += block_count_arr[nblock_left];
<a name="l01717"></a>01717             }
<a name="l01718"></a>01718             <span class="keywordflow">else</span>
<a name="l01719"></a>01719             {
<a name="l01720"></a>01720                 func(block);<span class="comment">//, nblock_left);</span>
<a name="l01721"></a>01721             }
<a name="l01722"></a>01722         }
<a name="l01723"></a>01723         <span class="keywordflow">else</span>
<a name="l01724"></a>01724         {
<a name="l01725"></a>01725             <span class="keywordflow">if</span> (left_gap)
<a name="l01726"></a>01726             {
<a name="l01727"></a>01727                 count += <a class="code" href="a00115.html#a7324ebded429e15361f62117a2ff18d1" title="Counts 1 bits in GAP buffer in the closed [left, right] diapason.">gap_bit_count_range</a>(<a class="code" href="a00092.html#a6a7c8b8ee3f3b60ab907c1699acb7aa0">BMGAP_PTR</a>(block), 
<a name="l01728"></a>01728                                             (<a class="code" href="a00115.html#ac654d6319039a86546d235a236fc7cf6">gap_word_t</a>)nbit_left,
<a name="l01729"></a>01729                                             (<a class="code" href="a00115.html#ac654d6319039a86546d235a236fc7cf6">gap_word_t</a>)r);
<a name="l01730"></a>01730             }
<a name="l01731"></a>01731             <span class="keywordflow">else</span>
<a name="l01732"></a>01732             {
<a name="l01733"></a>01733                 count += <a class="code" href="a00120.html#ga2485f707b2629c5ce7681cf9fe385b91">bit_block_calc_count_range</a>(block, nbit_left, r);
<a name="l01734"></a>01734             }
<a name="l01735"></a>01735         }
<a name="l01736"></a>01736     }
<a name="l01737"></a>01737 
<a name="l01738"></a>01738     <span class="keywordflow">if</span> (nblock_left == nblock_right)  <span class="comment">// in one block</span>
<a name="l01739"></a>01739     {
<a name="l01740"></a>01740         <span class="keywordflow">return</span> count + func.count();
<a name="l01741"></a>01741     }
<a name="l01742"></a>01742 
<a name="l01743"></a>01743     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> nb = nblock_left+1; nb &lt; nblock_right; ++nb)
<a name="l01744"></a>01744     {
<a name="l01745"></a>01745         block = blockman_.get_block(nb);
<a name="l01746"></a>01746         <span class="keywordflow">if</span> (block_count_arr)
<a name="l01747"></a>01747         {
<a name="l01748"></a>01748             count += block_count_arr[nb];
<a name="l01749"></a>01749         }
<a name="l01750"></a>01750         <span class="keywordflow">else</span> 
<a name="l01751"></a>01751         {
<a name="l01752"></a>01752             <span class="keywordflow">if</span> (block)
<a name="l01753"></a>01753                 func(block);
<a name="l01754"></a>01754         }
<a name="l01755"></a>01755     }
<a name="l01756"></a>01756     count += func.count();
<a name="l01757"></a>01757 
<a name="l01758"></a>01758     block = blockman_.get_block(nblock_right);
<a name="l01759"></a>01759     <span class="keywordtype">bool</span> right_gap = <a class="code" href="a00092.html#a7bc243edc0a5e82979d6bf63f4debb9a">BM_IS_GAP</a>(block);
<a name="l01760"></a>01760 
<a name="l01761"></a>01761     <span class="keywordflow">if</span> (block)
<a name="l01762"></a>01762     {
<a name="l01763"></a>01763         <span class="keywordflow">if</span> (right_gap)
<a name="l01764"></a>01764         {
<a name="l01765"></a>01765             count += <a class="code" href="a00115.html#a7324ebded429e15361f62117a2ff18d1" title="Counts 1 bits in GAP buffer in the closed [left, right] diapason.">gap_bit_count_range</a>(<a class="code" href="a00092.html#a6a7c8b8ee3f3b60ab907c1699acb7aa0">BMGAP_PTR</a>(block),
<a name="l01766"></a>01766                                         (<a class="code" href="a00115.html#ac654d6319039a86546d235a236fc7cf6">gap_word_t</a>)0,
<a name="l01767"></a>01767                                         (<a class="code" href="a00115.html#ac654d6319039a86546d235a236fc7cf6">gap_word_t</a>)nbit_right);
<a name="l01768"></a>01768         }
<a name="l01769"></a>01769         <span class="keywordflow">else</span>
<a name="l01770"></a>01770         {
<a name="l01771"></a>01771             count += <a class="code" href="a00120.html#ga2485f707b2629c5ce7681cf9fe385b91">bit_block_calc_count_range</a>(block, 0, nbit_right);
<a name="l01772"></a>01772         }
<a name="l01773"></a>01773     }
<a name="l01774"></a>01774 
<a name="l01775"></a>01775     <span class="keywordflow">return</span> count;
<a name="l01776"></a>01776 }
<a name="l01777"></a>01777 
<a name="l01778"></a>01778 <span class="comment">// -----------------------------------------------------------------------</span>
<a name="l01779"></a>01779 
<a name="l01780"></a>01780 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Alloc&gt;
<a name="l01781"></a><a class="code" href="a00043.html#a27e95553f358ebebda6b521336682deb">01781</a> <a class="code" href="a00043.html" title="bitvector with runtime compression of bits.">bvector&lt;Alloc&gt;</a>&amp; <a class="code" href="a00043.html#a27e95553f358ebebda6b521336682deb" title="Inverts all bits.">bvector&lt;Alloc&gt;::invert</a>()
<a name="l01782"></a>01782 {
<a name="l01783"></a>01783     <a class="code" href="a00087.html#a835c3ed1c5956735e59744cff81244dc">BMCOUNT_VALID</a>(<span class="keyword">false</span>)
<a name="l01784"></a>01784     <a class="code" href="a00092.html#a7e6f87ba3230dece2125af5c32e84b05">BM_SET_MMX_GUARD</a>
<a name="l01785"></a>01785 
<a name="l01786"></a>01786     <a class="code" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a>*** blk_root = blockman_.get_rootblock();
<a name="l01787"></a>01787     <span class="keyword">typename</span> blocks_manager_type::block_invert_func func(blockman_);    
<a name="l01788"></a>01788     <a class="code" href="a00115.html#a8abecc773e9aaee744215278d1e6924e">for_each_block</a>(blk_root, blockman_.top_block_size(), func);
<a name="l01789"></a>01789     <span class="keywordflow">if</span> (size_ == <a class="code" href="a00115.html#a104b924a1df81542db2a6296fbf26a65">bm::id_max</a>) 
<a name="l01790"></a>01790     {
<a name="l01791"></a>01791         set_bit_no_check(<a class="code" href="a00115.html#a104b924a1df81542db2a6296fbf26a65">bm::id_max</a>, <span class="keyword">false</span>);
<a name="l01792"></a>01792     } 
<a name="l01793"></a>01793     <span class="keywordflow">else</span>
<a name="l01794"></a>01794     {
<a name="l01795"></a>01795         set_range_no_check(size_, <a class="code" href="a00115.html#a104b924a1df81542db2a6296fbf26a65">bm::id_max</a>, <span class="keyword">false</span>);
<a name="l01796"></a>01796     }
<a name="l01797"></a>01797 
<a name="l01798"></a>01798     <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l01799"></a>01799 }
<a name="l01800"></a>01800 
<a name="l01801"></a>01801 <span class="comment">// -----------------------------------------------------------------------</span>
<a name="l01802"></a>01802 
<a name="l01803"></a>01803 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Alloc&gt; 
<a name="l01804"></a><a class="code" href="a00043.html#a1f9a5978084af329274ba67ed85012f4">01804</a> <span class="keywordtype">bool</span> <a class="code" href="a00043.html#a1f9a5978084af329274ba67ed85012f4" title="returns true if bit n is set and false is bit n is 0.">bvector&lt;Alloc&gt;::get_bit</a>(<a class="code" href="a00115.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a> n)<span class="keyword"> const</span>
<a name="l01805"></a>01805 <span class="keyword"></span>{    
<a name="l01806"></a>01806     <a class="code" href="a00092.html#aa44515fab0ace8928d1cb82009a95bf8">BM_ASSERT</a>(n &lt; size_);
<a name="l01807"></a>01807 
<a name="l01808"></a>01808     <span class="comment">// calculate logical block number</span>
<a name="l01809"></a>01809     <span class="keywordtype">unsigned</span> nblock = unsigned(n &gt;&gt;  <a class="code" href="a00115.html#ad8723fbeea6290d3daa8917ea7ce9bb2">bm::set_block_shift</a>); 
<a name="l01810"></a>01810 
<a name="l01811"></a>01811     <span class="keyword">const</span> <a class="code" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a>* block = blockman_.get_block(nblock);
<a name="l01812"></a>01812 
<a name="l01813"></a>01813     <span class="keywordflow">if</span> (block)
<a name="l01814"></a>01814     {
<a name="l01815"></a>01815         <span class="comment">// calculate word number in block and bit</span>
<a name="l01816"></a>01816         <span class="keywordtype">unsigned</span> nbit = unsigned(n &amp; <a class="code" href="a00115.html#a201fb8b1f81b7487f1c1c129fc3d6557">bm::set_block_mask</a>); 
<a name="l01817"></a>01817         <span class="keywordtype">unsigned</span> is_set;
<a name="l01818"></a>01818 
<a name="l01819"></a>01819         <span class="keywordflow">if</span> (<a class="code" href="a00092.html#a7bc243edc0a5e82979d6bf63f4debb9a">BM_IS_GAP</a>(block))
<a name="l01820"></a>01820         {
<a name="l01821"></a>01821             is_set = <a class="code" href="a00119.html#ga866352ef5986a7d2b709795d127b666b" title="Tests if bit = pos is true.">gap_test</a>(<a class="code" href="a00092.html#a6a7c8b8ee3f3b60ab907c1699acb7aa0">BMGAP_PTR</a>(block), nbit);
<a name="l01822"></a>01822         }
<a name="l01823"></a>01823         <span class="keywordflow">else</span> 
<a name="l01824"></a>01824         {
<a name="l01825"></a>01825             <span class="keywordtype">unsigned</span> nword  = unsigned(nbit &gt;&gt; <a class="code" href="a00115.html#a83d76bccf6fe3770f32d5ba11d2a37ad">bm::set_word_shift</a>); 
<a name="l01826"></a>01826             nbit &amp;= <a class="code" href="a00115.html#addbf345be3733d5e4575d71733ed1da8">bm::set_word_mask</a>;
<a name="l01827"></a>01827 
<a name="l01828"></a>01828             is_set = (block[nword] &amp; (((<a class="code" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a>)1) &lt;&lt; nbit));
<a name="l01829"></a>01829         }
<a name="l01830"></a>01830         <span class="keywordflow">return</span> is_set != 0;
<a name="l01831"></a>01831     }
<a name="l01832"></a>01832     <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l01833"></a>01833 }
<a name="l01834"></a>01834 
<a name="l01835"></a>01835 <span class="comment">// -----------------------------------------------------------------------</span>
<a name="l01836"></a>01836 
<a name="l01837"></a>01837 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Alloc&gt; 
<a name="l01838"></a><a class="code" href="a00043.html#a622e6827d799a561e2f0db28f7ac19d2">01838</a> <span class="keywordtype">void</span> <a class="code" href="a00043.html#a622e6827d799a561e2f0db28f7ac19d2" title="Optimize memory bitvector&amp;#39;s memory allocation.">bvector&lt;Alloc&gt;::optimize</a>(<a class="code" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a>* temp_block, 
<a name="l01839"></a>01839                               <a class="code" href="a00043.html#a05f1e977cb5e6208838afc7e7b69e5f0" title="Optimization mode Every next level means additional checks (better compression vs...">optmode</a>     opt_mode,
<a name="l01840"></a>01840                               <a class="code" href="a00085.html" title="Statistical information about bitset&amp;#39;s memory allocation details.">statistics</a>* stat)
<a name="l01841"></a>01841 {
<a name="l01842"></a>01842     <a class="code" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">word_t</a>*** blk_root = blockman_.blocks_root();
<a name="l01843"></a>01843 
<a name="l01844"></a>01844     <span class="keywordflow">if</span> (!temp_block)
<a name="l01845"></a>01845         temp_block = blockman_.check_allocate_tempblock();
<a name="l01846"></a>01846 
<a name="l01847"></a>01847     <span class="keyword">typename</span> 
<a name="l01848"></a>01848         blocks_manager_type::block_opt_func  opt_func(blockman_, 
<a name="l01849"></a>01849                                                 temp_block, 
<a name="l01850"></a>01850                                                 (<span class="keywordtype">int</span>)opt_mode,
<a name="l01851"></a>01851                                                 stat);
<a name="l01852"></a>01852     <span class="keywordflow">if</span> (stat)
<a name="l01853"></a>01853     {
<a name="l01854"></a>01854         stat-&gt;<a class="code" href="a00042.html#a4ec8ba190b4ba31c431c008402881c62" title="Number of bit blocks.">bit_blocks</a> = stat-&gt;<a class="code" href="a00042.html#a4dcfd64e9ab0be5472e3c2b04e551f81" title="Number of GAP blocks.">gap_blocks</a> 
<a name="l01855"></a>01855                          = stat-&gt;<a class="code" href="a00042.html#a92f800e8649a1455c17019c8ec882b4b" title="Estimated maximum of memory required for serialization.">max_serialize_mem</a> 
<a name="l01856"></a>01856                          = stat-&gt;<a class="code" href="a00042.html#ad3b2190eb4afe24ecd56323cbc0a7666" title="Memory used by bitvector including temp and service blocks.">memory_used</a> 
<a name="l01857"></a>01857                          = 0;
<a name="l01858"></a>01858         ::memcpy(stat-&gt;<a class="code" href="a00042.html#acc08d9637cc25d02d3a50c061ba221e1" title="GAP lengths used by bvector.">gap_levels</a>, 
<a name="l01859"></a>01859                 blockman_.glen(), <span class="keyword">sizeof</span>(<a class="code" href="a00115.html#ac654d6319039a86546d235a236fc7cf6">gap_word_t</a>) * <a class="code" href="a00115.html#a773e9f5341919d58000bd54d50038733">bm::gap_levels</a>);
<a name="l01860"></a>01860         stat-&gt;<a class="code" href="a00042.html#a92f800e8649a1455c17019c8ec882b4b" title="Estimated maximum of memory required for serialization.">max_serialize_mem</a> = <span class="keyword">sizeof</span>(<a class="code" href="a00115.html#aa3824d882a037396370b16f2f0a8bf37">id_t</a>) * 4;
<a name="l01861"></a>01861 
<a name="l01862"></a>01862     }
<a name="l01863"></a>01863 
<a name="l01864"></a>01864     <a class="code" href="a00115.html#a46953a43cfc3da7192d883b6dd822d99">for_each_nzblock</a>(blk_root, blockman_.effective_top_block_size(),
<a name="l01865"></a>01865                      opt_func);
<a name="l01866"></a>01866 
<a name="l01867"></a>01867     <span class="keywordflow">if</span> (stat)
<a name="l01868"></a>01868     {
<a name="l01869"></a>01869         <span class="keywordtype">unsigned</span> safe_inc = stat-&gt;<a class="code" href="a00042.html#a92f800e8649a1455c17019c8ec882b4b" title="Estimated maximum of memory required for serialization.">max_serialize_mem</a> / 10; <span class="comment">// 10% increment</span>
<a name="l01870"></a>01870         <span class="keywordflow">if</span> (!safe_inc) safe_inc = 256;
<a name="l01871"></a>01871         stat-&gt;<a class="code" href="a00042.html#a92f800e8649a1455c17019c8ec882b4b" title="Estimated maximum of memory required for serialization.">max_serialize_mem</a> += safe_inc;
<a name="l01872"></a>01872         stat-&gt;<a class="code" href="a00042.html#ad3b2190eb4afe24ecd56323cbc0a7666" title="Memory used by bitvector including temp and service blocks.">memory_used</a> += <span class="keyword">sizeof</span>(*this) - <span class="keyword">sizeof</span>(blockman_);
<a name="l01873"></a>01873         stat-&gt;<a class="code" href="a00042.html#ad3b2190eb4afe24ecd56323cbc0a7666" title="Memory used by bitvector including temp and service blocks.">memory_used</a> += blockman_.mem_used();
<a name="l01874"></a>01874     }
<a name="l01875"></a>01875 }
<a name="l01876"></a>01876 
<a name="l01877"></a>01877 <span class="comment">// -----------------------------------------------------------------------</span>
<a name="l01878"></a>01878 
<a name="l01879"></a>01879 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Alloc&gt; 
<a name="l01880"></a><a class="code" href="a00043.html#aaa2d954f42ea75520b8795066302daab">01880</a> <span class="keywordtype">void</span> <a class="code" href="a00043.html#aaa2d954f42ea75520b8795066302daab" title="Optimize sizes of GAP blocks.">bvector&lt;Alloc&gt;::optimize_gap_size</a>()
<a name="l01881"></a>01881 {
<a name="l01882"></a>01882     <span class="keyword">struct </span><a class="code" href="a00043.html" title="bitvector with runtime compression of bits.">bvector</a>&lt;Alloc&gt;::<a class="code" href="a00085.html" title="Statistical information about bitset&amp;#39;s memory allocation details.">statistics</a> st;
<a name="l01883"></a>01883     <a class="code" href="a00043.html#a61cd78a95b33d4759b5b8b535713dc50" title="Calculates bitvector statistics.">calc_stat</a>(&amp;st);
<a name="l01884"></a>01884 
<a name="l01885"></a>01885     if (!st.gap_blocks)
<a name="l01886"></a>01886         return;
<a name="l01887"></a>01887 
<a name="l01888"></a>01888     <a class="code" href="a00115.html#ac654d6319039a86546d235a236fc7cf6">gap_word_t</a> opt_glen[bm::<a class="code" href="a00115.html#a773e9f5341919d58000bd54d50038733">gap_levels</a>];
<a name="l01889"></a>01889     ::memcpy(opt_glen, st.gap_levels, bm::gap_levels * sizeof(*opt_glen));
<a name="l01890"></a>01890 
<a name="l01891"></a>01891     <a class="code" href="a00119.html#ga2daff3a0ceda6fef87d3b0e892da5813" title="Finds optimal gap blocks lengths.">improve_gap_levels</a>(st.gap_length, 
<a name="l01892"></a>01892                             st.gap_length + st.gap_blocks, 
<a name="l01893"></a>01893                             opt_glen);
<a name="l01894"></a>01894     
<a name="l01895"></a>01895     <a class="code" href="a00043.html#a14f9b220fec8e7b65e4e5ed2832af96b" title="Sets new GAP lengths table. All GAP blocks will be reallocated to match the new scheme...">set_gap_levels</a>(opt_glen);
<a name="l01896"></a>01896 }
<a name="l01897"></a>01897 
<a name="l01898"></a>01898 <span class="comment">// -----------------------------------------------------------------------</span>
<a name="l01899"></a>01899 
<a name="l01900"></a>01900 template&lt;typename Alloc&gt; 
<a name="l01901"></a><a class="code" href="a00043.html#a14f9b220fec8e7b65e4e5ed2832af96b">01901</a> void <a class="code" href="a00043.html" title="bitvector with runtime compression of bits.">bvector</a>&lt;Alloc&gt;::<a class="code" href="a00043.html#a14f9b220fec8e7b65e4e5ed2832af96b" title="Sets new GAP lengths table. All GAP blocks will be reallocated to match the new scheme...">set_gap_levels</a>(const gap_word_t* glevel_len)
<a name="l01902"></a>01902 {
<a name="l01903"></a>01903     <a class="code" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">word_t</a>*** blk_root = blockman_.blocks_root();
<a name="l01904"></a>01904     <span class="keyword">typename</span> 
<a name="l01905"></a>01905         blocks_manager_type::gap_level_func  gl_func(blockman_, glevel_len);
<a name="l01906"></a>01906     <a class="code" href="a00115.html#a46953a43cfc3da7192d883b6dd822d99">for_each_nzblock</a>(blk_root, blockman_.top_block_size(),gl_func);
<a name="l01907"></a>01907 
<a name="l01908"></a>01908     blockman_.set_glen(glevel_len);
<a name="l01909"></a>01909 }
<a name="l01910"></a>01910 
<a name="l01911"></a>01911 <span class="comment">// -----------------------------------------------------------------------</span>
<a name="l01912"></a>01912 
<a name="l01913"></a>01913 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Alloc&gt; 
<a name="l01914"></a><a class="code" href="a00043.html#a4dbc98ea637b352635549814982d4c28">01914</a> <span class="keywordtype">int</span> <a class="code" href="a00043.html#a4dbc98ea637b352635549814982d4c28" title="Lexicographical comparison with a bitvector.">bvector&lt;Alloc&gt;::compare</a>(<span class="keyword">const</span> <a class="code" href="a00043.html" title="bitvector with runtime compression of bits.">bvector&lt;Alloc&gt;</a>&amp; <a class="code" href="a00043.html" title="bitvector with runtime compression of bits.">bvect</a>)<span class="keyword"> const</span>
<a name="l01915"></a>01915 <span class="keyword"></span>{
<a name="l01916"></a>01916     <span class="keywordtype">int</span> res;
<a name="l01917"></a>01917     <span class="keywordtype">unsigned</span> bn = 0;
<a name="l01918"></a>01918 
<a name="l01919"></a>01919     <span class="keywordtype">unsigned</span> top_blocks = blockman_.effective_top_block_size();
<a name="l01920"></a>01920     <span class="keywordtype">unsigned</span> bvect_top_blocks = bvect.blockman_.effective_top_block_size();
<a name="l01921"></a>01921 
<a name="l01922"></a>01922     <span class="keywordflow">if</span> (bvect_top_blocks &gt; top_blocks) top_blocks = bvect_top_blocks;
<a name="l01923"></a>01923 
<a name="l01924"></a>01924     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i = 0; i &lt; top_blocks; ++i)
<a name="l01925"></a>01925     {
<a name="l01926"></a>01926         <span class="keyword">const</span> <a class="code" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a>* <span class="keyword">const</span>* blk_blk = blockman_.get_topblock(i);
<a name="l01927"></a>01927         <span class="keyword">const</span> <a class="code" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a>* <span class="keyword">const</span>* arg_blk_blk = 
<a name="l01928"></a>01928                                 bvect.blockman_.get_topblock(i);
<a name="l01929"></a>01929 
<a name="l01930"></a>01930         <span class="keywordflow">if</span> (blk_blk == arg_blk_blk) 
<a name="l01931"></a>01931         {
<a name="l01932"></a>01932             bn += <a class="code" href="a00115.html#a40ad34d6c46a2fb20ba2baa7f95d80b4">bm::set_array_size</a>;
<a name="l01933"></a>01933             <span class="keywordflow">continue</span>;
<a name="l01934"></a>01934         }
<a name="l01935"></a>01935 
<a name="l01936"></a>01936         <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> j = 0; j &lt; <a class="code" href="a00115.html#a40ad34d6c46a2fb20ba2baa7f95d80b4">bm::set_array_size</a>; ++j, ++bn)
<a name="l01937"></a>01937         {
<a name="l01938"></a>01938             <span class="keyword">const</span> <a class="code" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a>* arg_blk = arg_blk_blk ? arg_blk_blk[j] : 0;
<a name="l01939"></a>01939             <span class="keyword">const</span> <a class="code" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a>* blk = blk_blk ? blk_blk[j] : 0;
<a name="l01940"></a>01940             <span class="keywordflow">if</span> (blk == arg_blk) <span class="keywordflow">continue</span>;
<a name="l01941"></a>01941 
<a name="l01942"></a>01942             <span class="comment">// If one block is zero we check if the other one has at least </span>
<a name="l01943"></a>01943             <span class="comment">// one bit ON</span>
<a name="l01944"></a>01944 
<a name="l01945"></a>01945             <span class="keywordflow">if</span> (!blk || !arg_blk)  
<a name="l01946"></a>01946             {
<a name="l01947"></a>01947                 <span class="keyword">const</span> <a class="code" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a>*  pblk;
<a name="l01948"></a>01948                 <span class="keywordtype">bool</span> is_gap;
<a name="l01949"></a>01949 
<a name="l01950"></a>01950                 <span class="keywordflow">if</span> (blk)
<a name="l01951"></a>01951                 {
<a name="l01952"></a>01952                     pblk = blk;
<a name="l01953"></a>01953                     res = 1;
<a name="l01954"></a>01954                     is_gap = <a class="code" href="a00092.html#a7bc243edc0a5e82979d6bf63f4debb9a">BM_IS_GAP</a>(blk);
<a name="l01955"></a>01955                 }
<a name="l01956"></a>01956                 <span class="keywordflow">else</span>
<a name="l01957"></a>01957                 {
<a name="l01958"></a>01958                     pblk = arg_blk;
<a name="l01959"></a>01959                     res = -1;
<a name="l01960"></a>01960                     is_gap = <a class="code" href="a00092.html#a7bc243edc0a5e82979d6bf63f4debb9a">BM_IS_GAP</a>(arg_blk);
<a name="l01961"></a>01961                 }
<a name="l01962"></a>01962 
<a name="l01963"></a>01963                 <span class="keywordflow">if</span> (is_gap)
<a name="l01964"></a>01964                 {
<a name="l01965"></a>01965                     <span class="keywordflow">if</span> (!<a class="code" href="a00119.html#ga690ff7c8b16e1821a77663b7194267e7" title="Temporary inverts all bits in the GAP buffer.">gap_is_all_zero</a>(<a class="code" href="a00092.html#a6a7c8b8ee3f3b60ab907c1699acb7aa0">BMGAP_PTR</a>(pblk), <a class="code" href="a00115.html#ad0b8714080144ac70197840ff96752b7">bm::gap_max_bits</a>))
<a name="l01966"></a>01966                     {
<a name="l01967"></a>01967                         <span class="keywordflow">return</span> res;
<a name="l01968"></a>01968                     }
<a name="l01969"></a>01969                 }
<a name="l01970"></a>01970                 <span class="keywordflow">else</span>
<a name="l01971"></a>01971                 {
<a name="l01972"></a>01972                     <a class="code" href="a00115.html#a7176bf7817550ca24cb6612bd8d7957d">bm::wordop_t</a>* blk1 = (<a class="code" href="a00115.html#a7176bf7817550ca24cb6612bd8d7957d">wordop_t</a>*)pblk;
<a name="l01973"></a>01973                     <a class="code" href="a00115.html#a7176bf7817550ca24cb6612bd8d7957d">bm::wordop_t</a>* blk2 = 
<a name="l01974"></a>01974                         (<a class="code" href="a00115.html#a7176bf7817550ca24cb6612bd8d7957d">wordop_t</a>*)(pblk + bm::set_block_size);
<a name="l01975"></a>01975                     <span class="keywordflow">if</span> (!<a class="code" href="a00120.html#gac6cfb9f92e4df6bb4c76f6efb2382860" title="Returns &amp;quot;true&amp;quot; if all bits in the block are 0.">bit_is_all_zero</a>(blk1, blk2))
<a name="l01976"></a>01976                     {
<a name="l01977"></a>01977                         <span class="keywordflow">return</span> res;
<a name="l01978"></a>01978                     }
<a name="l01979"></a>01979                 }
<a name="l01980"></a>01980 
<a name="l01981"></a>01981                 <span class="keywordflow">continue</span>;
<a name="l01982"></a>01982             }
<a name="l01983"></a>01983 
<a name="l01984"></a>01984             <span class="keywordtype">bool</span> arg_gap = <a class="code" href="a00092.html#a7bc243edc0a5e82979d6bf63f4debb9a">BM_IS_GAP</a>(arg_blk);
<a name="l01985"></a>01985             <span class="keywordtype">bool</span> gap = <a class="code" href="a00092.html#a7bc243edc0a5e82979d6bf63f4debb9a">BM_IS_GAP</a>(blk);
<a name="l01986"></a>01986 
<a name="l01987"></a>01987             <span class="keywordflow">if</span> (arg_gap != gap)
<a name="l01988"></a>01988             {
<a name="l01989"></a>01989                 <a class="code" href="a00115.html#a7176bf7817550ca24cb6612bd8d7957d">bm::wordop_t</a> temp_blk[<a class="code" href="a00115.html#a7049fd70220fc3a3072e9f82abf4ad66">bm::set_block_size_op</a>]; 
<a name="l01990"></a>01990                 <a class="code" href="a00115.html#a7176bf7817550ca24cb6612bd8d7957d">bm::wordop_t</a>* blk1;
<a name="l01991"></a>01991                 <a class="code" href="a00115.html#a7176bf7817550ca24cb6612bd8d7957d">bm::wordop_t</a>* blk2;
<a name="l01992"></a>01992 
<a name="l01993"></a>01993                 <span class="keywordflow">if</span> (gap)
<a name="l01994"></a>01994                 {
<a name="l01995"></a>01995                     <a class="code" href="a00119.html#ga4862f4dcdcb7c0575e2e2db9e5f2a849" title="GAP block to bitblock conversion.">gap_convert_to_bitset</a>((<a class="code" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a>*)temp_blk, 
<a name="l01996"></a>01996                                             <a class="code" href="a00092.html#a6a7c8b8ee3f3b60ab907c1699acb7aa0">BMGAP_PTR</a>(blk));
<a name="l01997"></a>01997 
<a name="l01998"></a>01998                     blk1 = (<a class="code" href="a00115.html#a7176bf7817550ca24cb6612bd8d7957d">bm::wordop_t</a>*)temp_blk;
<a name="l01999"></a>01999                     blk2 = (<a class="code" href="a00115.html#a7176bf7817550ca24cb6612bd8d7957d">bm::wordop_t</a>*)arg_blk;
<a name="l02000"></a>02000                 }
<a name="l02001"></a>02001                 <span class="keywordflow">else</span>
<a name="l02002"></a>02002                 {
<a name="l02003"></a>02003                     <a class="code" href="a00119.html#ga4862f4dcdcb7c0575e2e2db9e5f2a849" title="GAP block to bitblock conversion.">gap_convert_to_bitset</a>((<a class="code" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a>*)temp_blk, 
<a name="l02004"></a>02004                                             <a class="code" href="a00092.html#a6a7c8b8ee3f3b60ab907c1699acb7aa0">BMGAP_PTR</a>(arg_blk));
<a name="l02005"></a>02005 
<a name="l02006"></a>02006                     blk1 = (<a class="code" href="a00115.html#a7176bf7817550ca24cb6612bd8d7957d">bm::wordop_t</a>*)blk;
<a name="l02007"></a>02007                     blk2 = (<a class="code" href="a00115.html#a7176bf7817550ca24cb6612bd8d7957d">bm::wordop_t</a>*)temp_blk;
<a name="l02008"></a>02008 
<a name="l02009"></a>02009                 }                        
<a name="l02010"></a>02010                 res = <a class="code" href="a00120.html#ga91fe9566575d9d66e1bb9d030b3d29a0" title="Lexicographical comparison of BIT buffers.">bitcmp</a>(blk1, blk2, <a class="code" href="a00115.html#a7049fd70220fc3a3072e9f82abf4ad66">bm::set_block_size_op</a>);  
<a name="l02011"></a>02011 
<a name="l02012"></a>02012             }
<a name="l02013"></a>02013             <span class="keywordflow">else</span>
<a name="l02014"></a>02014             {
<a name="l02015"></a>02015                 <span class="keywordflow">if</span> (gap)
<a name="l02016"></a>02016                 {
<a name="l02017"></a>02017                     res = <a class="code" href="a00119.html#ga406952734f1b05962941b32e37b3eb96" title="Lexicographical comparison of GAP buffers.">gapcmp</a>(<a class="code" href="a00092.html#a6a7c8b8ee3f3b60ab907c1699acb7aa0">BMGAP_PTR</a>(blk), <a class="code" href="a00092.html#a6a7c8b8ee3f3b60ab907c1699acb7aa0">BMGAP_PTR</a>(arg_blk));
<a name="l02018"></a>02018                 }
<a name="l02019"></a>02019                 <span class="keywordflow">else</span>
<a name="l02020"></a>02020                 {
<a name="l02021"></a>02021                     res = <a class="code" href="a00120.html#ga91fe9566575d9d66e1bb9d030b3d29a0" title="Lexicographical comparison of BIT buffers.">bitcmp</a>((<a class="code" href="a00115.html#a7176bf7817550ca24cb6612bd8d7957d">bm::wordop_t</a>*)blk, 
<a name="l02022"></a>02022                                     (<a class="code" href="a00115.html#a7176bf7817550ca24cb6612bd8d7957d">bm::wordop_t</a>*)arg_blk, 
<a name="l02023"></a>02023                                     <a class="code" href="a00115.html#a7049fd70220fc3a3072e9f82abf4ad66">bm::set_block_size_op</a>);
<a name="l02024"></a>02024                 }
<a name="l02025"></a>02025             }
<a name="l02026"></a>02026 
<a name="l02027"></a>02027             <span class="keywordflow">if</span> (res != 0)
<a name="l02028"></a>02028             {
<a name="l02029"></a>02029                 <span class="keywordflow">return</span> res;
<a name="l02030"></a>02030             }
<a name="l02031"></a>02031         
<a name="l02032"></a>02032 
<a name="l02033"></a>02033         } <span class="comment">// for j</span>
<a name="l02034"></a>02034 
<a name="l02035"></a>02035     } <span class="comment">// for i</span>
<a name="l02036"></a>02036 
<a name="l02037"></a>02037     <span class="keywordflow">return</span> 0;
<a name="l02038"></a>02038 }
<a name="l02039"></a>02039 
<a name="l02040"></a>02040 
<a name="l02041"></a>02041 <span class="comment">// -----------------------------------------------------------------------</span>
<a name="l02042"></a>02042 
<a name="l02043"></a>02043 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Alloc&gt; 
<a name="l02044"></a><a class="code" href="a00043.html#a61cd78a95b33d4759b5b8b535713dc50">02044</a> <span class="keywordtype">void</span> <a class="code" href="a00043.html#a61cd78a95b33d4759b5b8b535713dc50" title="Calculates bitvector statistics.">bvector&lt;Alloc&gt;::calc_stat</a>(<span class="keyword">struct</span> <a class="code" href="a00085.html" title="Statistical information about bitset&amp;#39;s memory allocation details.">bvector&lt;Alloc&gt;::statistics</a>* st)<span class="keyword"> const</span>
<a name="l02045"></a>02045 <span class="keyword"></span>{
<a name="l02046"></a>02046     st-&gt;<a class="code" href="a00042.html#a4ec8ba190b4ba31c431c008402881c62" title="Number of bit blocks.">bit_blocks</a> = st-&gt;<a class="code" href="a00042.html#a4dcfd64e9ab0be5472e3c2b04e551f81" title="Number of GAP blocks.">gap_blocks</a> 
<a name="l02047"></a>02047                    = st-&gt;<a class="code" href="a00042.html#a92f800e8649a1455c17019c8ec882b4b" title="Estimated maximum of memory required for serialization.">max_serialize_mem</a> 
<a name="l02048"></a>02048                    = st-&gt;<a class="code" href="a00042.html#ad3b2190eb4afe24ecd56323cbc0a7666" title="Memory used by bitvector including temp and service blocks.">memory_used</a> = 0;
<a name="l02049"></a>02049 
<a name="l02050"></a>02050     ::memcpy(st-&gt;<a class="code" href="a00042.html#acc08d9637cc25d02d3a50c061ba221e1" title="GAP lengths used by bvector.">gap_levels</a>, 
<a name="l02051"></a>02051              blockman_.glen(), <span class="keyword">sizeof</span>(<a class="code" href="a00115.html#ac654d6319039a86546d235a236fc7cf6">gap_word_t</a>) * <a class="code" href="a00115.html#a773e9f5341919d58000bd54d50038733">bm::gap_levels</a>);
<a name="l02052"></a>02052 
<a name="l02053"></a>02053     <span class="keywordtype">unsigned</span> empty_blocks = 0;
<a name="l02054"></a>02054     <span class="keywordtype">unsigned</span> blocks_memory = 0;
<a name="l02055"></a>02055     <a class="code" href="a00115.html#ac654d6319039a86546d235a236fc7cf6">gap_word_t</a>* gapl_ptr = st-&gt;<a class="code" href="a00042.html#a824dd18d515305d159c48a697696cbb6" title="Array of all GAP block lengths in the bvector.">gap_length</a>;
<a name="l02056"></a>02056 
<a name="l02057"></a>02057     st-&gt;<a class="code" href="a00042.html#a92f800e8649a1455c17019c8ec882b4b" title="Estimated maximum of memory required for serialization.">max_serialize_mem</a> = <span class="keyword">sizeof</span>(<a class="code" href="a00115.html#aa3824d882a037396370b16f2f0a8bf37">id_t</a>) * 4;
<a name="l02058"></a>02058 
<a name="l02059"></a>02059     <span class="keywordtype">unsigned</span> block_idx = 0;
<a name="l02060"></a>02060 
<a name="l02061"></a>02061     <span class="keywordtype">unsigned</span> top_size = blockman_.effective_top_block_size();
<a name="l02062"></a>02062     <span class="comment">// Walk the blocks, calculate statistics.</span>
<a name="l02063"></a>02063     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i = 0; i &lt; top_size; ++i)
<a name="l02064"></a>02064     {
<a name="l02065"></a>02065         <span class="keyword">const</span> <a class="code" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a>* <span class="keyword">const</span>* blk_blk = blockman_.get_topblock(i);
<a name="l02066"></a>02066 
<a name="l02067"></a>02067         <span class="keywordflow">if</span> (!blk_blk) 
<a name="l02068"></a>02068         {
<a name="l02069"></a>02069             block_idx += <a class="code" href="a00115.html#a40ad34d6c46a2fb20ba2baa7f95d80b4">bm::set_array_size</a>;
<a name="l02070"></a>02070             st-&gt;<a class="code" href="a00042.html#a92f800e8649a1455c17019c8ec882b4b" title="Estimated maximum of memory required for serialization.">max_serialize_mem</a> += <span class="keyword">sizeof</span>(unsigned) + 1;
<a name="l02071"></a>02071             <span class="keywordflow">continue</span>;
<a name="l02072"></a>02072         }
<a name="l02073"></a>02073 
<a name="l02074"></a>02074         <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> j = 0;j &lt; <a class="code" href="a00115.html#a40ad34d6c46a2fb20ba2baa7f95d80b4">bm::set_array_size</a>; ++j, ++block_idx)
<a name="l02075"></a>02075         {
<a name="l02076"></a>02076             <span class="keyword">const</span> <a class="code" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a>* blk = blk_blk[j];
<a name="l02077"></a>02077             <span class="keywordflow">if</span> (<a class="code" href="a00092.html#a13ba598909515339ceede09e3b9b0198">IS_VALID_ADDR</a>(blk))
<a name="l02078"></a>02078             {
<a name="l02079"></a>02079                 st-&gt;<a class="code" href="a00042.html#a92f800e8649a1455c17019c8ec882b4b" title="Estimated maximum of memory required for serialization.">max_serialize_mem</a> += empty_blocks &lt;&lt; 2;
<a name="l02080"></a>02080                 empty_blocks = 0;
<a name="l02081"></a>02081 
<a name="l02082"></a>02082                 <span class="keywordflow">if</span> (<a class="code" href="a00092.html#a7bc243edc0a5e82979d6bf63f4debb9a">BM_IS_GAP</a>(blk))
<a name="l02083"></a>02083                 {
<a name="l02084"></a>02084                     ++(st-&gt;<a class="code" href="a00042.html#a4dcfd64e9ab0be5472e3c2b04e551f81" title="Number of GAP blocks.">gap_blocks</a>);
<a name="l02085"></a>02085 
<a name="l02086"></a>02086                     <a class="code" href="a00115.html#ac654d6319039a86546d235a236fc7cf6">bm::gap_word_t</a>* gap_blk = <a class="code" href="a00092.html#a6a7c8b8ee3f3b60ab907c1699acb7aa0">BMGAP_PTR</a>(blk);
<a name="l02087"></a>02087 
<a name="l02088"></a>02088                     <span class="keywordtype">unsigned</span> mem_used = 
<a name="l02089"></a>02089                         <a class="code" href="a00119.html#ga0419ed06e2f0b7891e7d721546f5fb45" title="Returs GAP block capacity.">bm::gap_capacity</a>(gap_blk, blockman_.glen()) 
<a name="l02090"></a>02090                         * <span class="keyword">sizeof</span>(<a class="code" href="a00115.html#ac654d6319039a86546d235a236fc7cf6">gap_word_t</a>);
<a name="l02091"></a>02091 
<a name="l02092"></a>02092                     *gapl_ptr = <a class="code" href="a00119.html#ga02541ec6c2930c292eda4313b78e874c" title="Returs GAP block length.">gap_length</a>(gap_blk);
<a name="l02093"></a>02093 
<a name="l02094"></a>02094                     st-&gt;<a class="code" href="a00042.html#a92f800e8649a1455c17019c8ec882b4b" title="Estimated maximum of memory required for serialization.">max_serialize_mem</a> += *gapl_ptr * <span class="keyword">sizeof</span>(<a class="code" href="a00115.html#ac654d6319039a86546d235a236fc7cf6">gap_word_t</a>);
<a name="l02095"></a>02095                     blocks_memory += mem_used;
<a name="l02096"></a>02096 
<a name="l02097"></a>02097                     ++gapl_ptr;
<a name="l02098"></a>02098                 }
<a name="l02099"></a>02099                 <span class="keywordflow">else</span> <span class="comment">// bit block</span>
<a name="l02100"></a>02100                 {
<a name="l02101"></a>02101                     ++(st-&gt;<a class="code" href="a00042.html#a4ec8ba190b4ba31c431c008402881c62" title="Number of bit blocks.">bit_blocks</a>);
<a name="l02102"></a>02102                     <span class="keywordtype">unsigned</span> mem_used = <span class="keyword">sizeof</span>(<a class="code" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a>) * bm::set_block_size;
<a name="l02103"></a>02103                     st-&gt;<a class="code" href="a00042.html#a92f800e8649a1455c17019c8ec882b4b" title="Estimated maximum of memory required for serialization.">max_serialize_mem</a> += mem_used;
<a name="l02104"></a>02104                     blocks_memory += mem_used;
<a name="l02105"></a>02105                 }
<a name="l02106"></a>02106             }
<a name="l02107"></a>02107             <span class="keywordflow">else</span>
<a name="l02108"></a>02108             {
<a name="l02109"></a>02109                 ++empty_blocks;
<a name="l02110"></a>02110             }
<a name="l02111"></a>02111         }
<a name="l02112"></a>02112     }  
<a name="l02113"></a>02113 
<a name="l02114"></a>02114     <span class="keywordtype">unsigned</span> safe_inc = st-&gt;<a class="code" href="a00042.html#a92f800e8649a1455c17019c8ec882b4b" title="Estimated maximum of memory required for serialization.">max_serialize_mem</a> / 10; <span class="comment">// 10% increment</span>
<a name="l02115"></a>02115     <span class="keywordflow">if</span> (!safe_inc) safe_inc = 256;
<a name="l02116"></a>02116     st-&gt;<a class="code" href="a00042.html#a92f800e8649a1455c17019c8ec882b4b" title="Estimated maximum of memory required for serialization.">max_serialize_mem</a> += safe_inc;
<a name="l02117"></a>02117 
<a name="l02118"></a>02118     <span class="comment">// Calc size of different odd and temporary things.</span>
<a name="l02119"></a>02119 
<a name="l02120"></a>02120     st-&gt;<a class="code" href="a00042.html#ad3b2190eb4afe24ecd56323cbc0a7666" title="Memory used by bitvector including temp and service blocks.">memory_used</a> += <span class="keyword">sizeof</span>(*this) - <span class="keyword">sizeof</span>(blockman_);
<a name="l02121"></a>02121     st-&gt;<a class="code" href="a00042.html#ad3b2190eb4afe24ecd56323cbc0a7666" title="Memory used by bitvector including temp and service blocks.">memory_used</a> += blockman_.mem_used();
<a name="l02122"></a>02122     st-&gt;<a class="code" href="a00042.html#ad3b2190eb4afe24ecd56323cbc0a7666" title="Memory used by bitvector including temp and service blocks.">memory_used</a> += blocks_memory;
<a name="l02123"></a>02123 }
<a name="l02124"></a>02124 
<a name="l02125"></a>02125 
<a name="l02126"></a>02126 <span class="comment">// -----------------------------------------------------------------------</span>
<a name="l02127"></a>02127 
<a name="l02128"></a>02128 
<a name="l02129"></a>02129 <span class="keyword">template</span>&lt;<span class="keyword">class</span> Alloc&gt; 
<a name="l02130"></a>02130 <span class="keywordtype">bool</span> <a class="code" href="a00043.html" title="bitvector with runtime compression of bits.">bvector&lt;Alloc&gt;::set_bit_no_check</a>(<a class="code" href="a00115.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a> n, <span class="keywordtype">bool</span> val)
<a name="l02131"></a>02131 {
<a name="l02132"></a>02132     <span class="comment">// calculate logical block number</span>
<a name="l02133"></a>02133     <span class="keywordtype">unsigned</span> nblock = unsigned(n &gt;&gt;  <a class="code" href="a00115.html#ad8723fbeea6290d3daa8917ea7ce9bb2">bm::set_block_shift</a>); 
<a name="l02134"></a>02134 
<a name="l02135"></a>02135     <span class="keywordtype">int</span> block_type;
<a name="l02136"></a>02136 
<a name="l02137"></a>02137     <a class="code" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a>* blk = 
<a name="l02138"></a>02138         blockman_.check_allocate_block(nblock, 
<a name="l02139"></a>02139                                         val,
<a name="l02140"></a>02140                                         <a class="code" href="a00043.html#a1f0f6467c82e6f2385632565e765d524" title="Returns blocks allocation strategy.">get_new_blocks_strat</a>(), 
<a name="l02141"></a>02141                                         &amp;block_type);
<a name="l02142"></a>02142 
<a name="l02143"></a>02143     <span class="keywordflow">if</span> (!blk) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l02144"></a>02144 
<a name="l02145"></a>02145     <span class="comment">// calculate word number in block and bit</span>
<a name="l02146"></a>02146     <span class="keywordtype">unsigned</span> nbit   = unsigned(n &amp; <a class="code" href="a00115.html#a201fb8b1f81b7487f1c1c129fc3d6557">bm::set_block_mask</a>); 
<a name="l02147"></a>02147 
<a name="l02148"></a>02148     <span class="keywordflow">if</span> (block_type == 1) <span class="comment">// gap</span>
<a name="l02149"></a>02149     {
<a name="l02150"></a>02150         <span class="keywordtype">unsigned</span> is_set;
<a name="l02151"></a>02151         <span class="keywordtype">unsigned</span> new_block_len;
<a name="l02152"></a>02152         
<a name="l02153"></a>02153         new_block_len = 
<a name="l02154"></a>02154             <a class="code" href="a00119.html#ga69186bd13bda27e04b3e33683ff884c2" title="Sets or clears bit in the GAP buffer.">gap_set_value</a>(val, <a class="code" href="a00092.html#a6a7c8b8ee3f3b60ab907c1699acb7aa0">BMGAP_PTR</a>(blk), nbit, &amp;is_set);
<a name="l02155"></a>02155         <span class="keywordflow">if</span> (is_set)
<a name="l02156"></a>02156         {
<a name="l02157"></a>02157             <a class="code" href="a00087.html#aef4146eb86de042a6c34717f87b16c10">BMCOUNT_ADJ</a>(val)
<a name="l02158"></a>02158 
<a name="l02159"></a>02159             unsigned threshold = 
<a name="l02160"></a>02160             bm::<a class="code" href="a00119.html#ga94a5371b5dc6a1560d95d7c2dde88815" title="Returs GAP block capacity limit.">gap_limit</a>(<a class="code" href="a00092.html#a6a7c8b8ee3f3b60ab907c1699acb7aa0">BMGAP_PTR</a>(blk), blockman_.glen());
<a name="l02161"></a>02161 
<a name="l02162"></a>02162             if (new_block_len &gt; threshold) 
<a name="l02163"></a>02163             {
<a name="l02164"></a>02164                 extend_gap_block(nblock, <a class="code" href="a00092.html#a6a7c8b8ee3f3b60ab907c1699acb7aa0">BMGAP_PTR</a>(blk));
<a name="l02165"></a>02165             }
<a name="l02166"></a>02166             <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l02167"></a>02167         }
<a name="l02168"></a>02168     }
<a name="l02169"></a>02169     <span class="keywordflow">else</span>  <span class="comment">// bit block</span>
<a name="l02170"></a>02170     {
<a name="l02171"></a>02171         <span class="keywordtype">unsigned</span> nword  = unsigned(nbit &gt;&gt; <a class="code" href="a00115.html#a83d76bccf6fe3770f32d5ba11d2a37ad">bm::set_word_shift</a>); 
<a name="l02172"></a>02172         nbit &amp;= <a class="code" href="a00115.html#addbf345be3733d5e4575d71733ed1da8">bm::set_word_mask</a>;
<a name="l02173"></a>02173 
<a name="l02174"></a>02174         <a class="code" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a>* word = blk + nword;
<a name="l02175"></a>02175         <a class="code" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a>  mask = (((<a class="code" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a>)1) &lt;&lt; nbit);
<a name="l02176"></a>02176 
<a name="l02177"></a>02177         <span class="keywordflow">if</span> (val)
<a name="l02178"></a>02178         {
<a name="l02179"></a>02179             <span class="keywordflow">if</span> ( ((*word) &amp; mask) == 0 )
<a name="l02180"></a>02180             {
<a name="l02181"></a>02181                 *word |= mask; <span class="comment">// set bit</span>
<a name="l02182"></a>02182                 <a class="code" href="a00087.html#a911e3d9e9a293cafab1396a8700288e9">BMCOUNT_INC</a>;
<a name="l02183"></a>02183                 <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l02184"></a>02184             }
<a name="l02185"></a>02185         }
<a name="l02186"></a>02186         <span class="keywordflow">else</span>
<a name="l02187"></a>02187         {
<a name="l02188"></a>02188             <span class="keywordflow">if</span> ((*word) &amp; mask)
<a name="l02189"></a>02189             {
<a name="l02190"></a>02190                 *word &amp;= ~mask; <span class="comment">// clear bit</span>
<a name="l02191"></a>02191                 <a class="code" href="a00087.html#a809c66152f5967c1a1eb51e006206630">BMCOUNT_DEC</a>;
<a name="l02192"></a>02192                 <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l02193"></a>02193             }
<a name="l02194"></a>02194         }
<a name="l02195"></a>02195     }
<a name="l02196"></a>02196     <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l02197"></a>02197 }
<a name="l02198"></a>02198 
<a name="l02199"></a>02199 <span class="comment">// -----------------------------------------------------------------------</span>
<a name="l02200"></a>02200 
<a name="l02201"></a>02201 <span class="keyword">template</span>&lt;<span class="keyword">class</span> Alloc&gt; 
<a name="l02202"></a>02202 <span class="keywordtype">bool</span> bvector&lt;Alloc&gt;::set_bit_conditional_impl(<a class="code" href="a00115.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a> n, 
<a name="l02203"></a>02203                                               <span class="keywordtype">bool</span>     val, 
<a name="l02204"></a>02204                                               <span class="keywordtype">bool</span>     condition)
<a name="l02205"></a>02205 {
<a name="l02206"></a>02206     <span class="comment">// calculate logical block number</span>
<a name="l02207"></a>02207     <span class="keywordtype">unsigned</span> nblock = unsigned(n &gt;&gt;  <a class="code" href="a00115.html#ad8723fbeea6290d3daa8917ea7ce9bb2">bm::set_block_shift</a>); 
<a name="l02208"></a>02208 
<a name="l02209"></a>02209     <span class="keywordtype">int</span> block_type;
<a name="l02210"></a>02210     <a class="code" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a>* blk = 
<a name="l02211"></a>02211         blockman_.check_allocate_block(nblock, 
<a name="l02212"></a>02212                                        val,
<a name="l02213"></a>02213                                        <a class="code" href="a00043.html#a1f0f6467c82e6f2385632565e765d524" title="Returns blocks allocation strategy.">get_new_blocks_strat</a>(), 
<a name="l02214"></a>02214                                        &amp;block_type);
<a name="l02215"></a>02215     <span class="keywordflow">if</span> (!blk) 
<a name="l02216"></a>02216         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l02217"></a>02217 
<a name="l02218"></a>02218     <span class="comment">// calculate word number in block and bit</span>
<a name="l02219"></a>02219     <span class="keywordtype">unsigned</span> nbit   = unsigned(n &amp; <a class="code" href="a00115.html#a201fb8b1f81b7487f1c1c129fc3d6557">bm::set_block_mask</a>); 
<a name="l02220"></a>02220 
<a name="l02221"></a>02221     <span class="keywordflow">if</span> (block_type == 1) <span class="comment">// gap</span>
<a name="l02222"></a>02222     {
<a name="l02223"></a>02223         <a class="code" href="a00115.html#ac654d6319039a86546d235a236fc7cf6">bm::gap_word_t</a>* gap_blk = <a class="code" href="a00092.html#a6a7c8b8ee3f3b60ab907c1699acb7aa0">BMGAP_PTR</a>(blk);
<a name="l02224"></a>02224         <span class="keywordtype">bool</span> old_val = (<a class="code" href="a00119.html#ga866352ef5986a7d2b709795d127b666b" title="Tests if bit = pos is true.">gap_test</a>(gap_blk, nbit) != 0);
<a name="l02225"></a>02225 
<a name="l02226"></a>02226         <span class="keywordflow">if</span> (old_val != condition) 
<a name="l02227"></a>02227         {
<a name="l02228"></a>02228             <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l02229"></a>02229         }
<a name="l02230"></a>02230 
<a name="l02231"></a>02231         <span class="keywordflow">if</span> (val != old_val)
<a name="l02232"></a>02232         {
<a name="l02233"></a>02233             <span class="keywordtype">unsigned</span> is_set;
<a name="l02234"></a>02234             <span class="keywordtype">unsigned</span> new_block_len = 
<a name="l02235"></a>02235                 <a class="code" href="a00119.html#ga69186bd13bda27e04b3e33683ff884c2" title="Sets or clears bit in the GAP buffer.">gap_set_value</a>(val, gap_blk, nbit, &amp;is_set);
<a name="l02236"></a>02236             <a class="code" href="a00092.html#aa44515fab0ace8928d1cb82009a95bf8">BM_ASSERT</a>(is_set);
<a name="l02237"></a>02237             <a class="code" href="a00087.html#aef4146eb86de042a6c34717f87b16c10">BMCOUNT_ADJ</a>(val)
<a name="l02238"></a>02238 
<a name="l02239"></a>02239             unsigned threshold = 
<a name="l02240"></a>02240                 bm::<a class="code" href="a00119.html#ga94a5371b5dc6a1560d95d7c2dde88815" title="Returs GAP block capacity limit.">gap_limit</a>(gap_blk, blockman_.glen());
<a name="l02241"></a>02241             if (new_block_len &gt; threshold) 
<a name="l02242"></a>02242             {
<a name="l02243"></a>02243                 extend_gap_block(nblock, gap_blk);
<a name="l02244"></a>02244             }
<a name="l02245"></a>02245             <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l02246"></a>02246         }
<a name="l02247"></a>02247     }
<a name="l02248"></a>02248     <span class="keywordflow">else</span>  <span class="comment">// bit block</span>
<a name="l02249"></a>02249     {
<a name="l02250"></a>02250         <span class="keywordtype">unsigned</span> nword  = unsigned(nbit &gt;&gt; <a class="code" href="a00115.html#a83d76bccf6fe3770f32d5ba11d2a37ad">bm::set_word_shift</a>); 
<a name="l02251"></a>02251         nbit &amp;= <a class="code" href="a00115.html#addbf345be3733d5e4575d71733ed1da8">bm::set_word_mask</a>;
<a name="l02252"></a>02252 
<a name="l02253"></a>02253         <a class="code" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a>* word = blk + nword;
<a name="l02254"></a>02254         <a class="code" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a>  mask = (((<a class="code" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a>)1) &lt;&lt; nbit);
<a name="l02255"></a>02255         <span class="keywordtype">bool</span> is_set = ((*word) &amp; mask) != 0;
<a name="l02256"></a>02256 
<a name="l02257"></a>02257         <span class="keywordflow">if</span> (is_set != condition)
<a name="l02258"></a>02258         {
<a name="l02259"></a>02259             <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l02260"></a>02260         }
<a name="l02261"></a>02261         <span class="keywordflow">if</span> (is_set != val)    <span class="comment">// need to change bit</span>
<a name="l02262"></a>02262         {
<a name="l02263"></a>02263             <span class="keywordflow">if</span> (val)          <span class="comment">// set bit</span>
<a name="l02264"></a>02264             {
<a name="l02265"></a>02265                 *word |= mask;
<a name="l02266"></a>02266                 <a class="code" href="a00087.html#a911e3d9e9a293cafab1396a8700288e9">BMCOUNT_INC</a>;
<a name="l02267"></a>02267             }
<a name="l02268"></a>02268             <span class="keywordflow">else</span>               <span class="comment">// clear bit</span>
<a name="l02269"></a>02269             {
<a name="l02270"></a>02270                 *word &amp;= ~mask;
<a name="l02271"></a>02271                 <a class="code" href="a00087.html#a809c66152f5967c1a1eb51e006206630">BMCOUNT_DEC</a>;
<a name="l02272"></a>02272             }
<a name="l02273"></a>02273             <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l02274"></a>02274         }
<a name="l02275"></a>02275     }
<a name="l02276"></a>02276     <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l02277"></a>02277 
<a name="l02278"></a>02278 }
<a name="l02279"></a>02279 
<a name="l02280"></a>02280 <span class="comment">// -----------------------------------------------------------------------</span>
<a name="l02281"></a>02281 
<a name="l02282"></a>02282 
<a name="l02283"></a>02283 <span class="keyword">template</span>&lt;<span class="keyword">class</span> Alloc&gt; 
<a name="l02284"></a>02284 <span class="keywordtype">bool</span> bvector&lt;Alloc&gt;::and_bit_no_check(<a class="code" href="a00115.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a> n, <span class="keywordtype">bool</span> val)
<a name="l02285"></a>02285 {
<a name="l02286"></a>02286     <span class="comment">// calculate logical block number</span>
<a name="l02287"></a>02287     <span class="keywordtype">unsigned</span> nblock = unsigned(n &gt;&gt;  <a class="code" href="a00115.html#ad8723fbeea6290d3daa8917ea7ce9bb2">bm::set_block_shift</a>); 
<a name="l02288"></a>02288 
<a name="l02289"></a>02289     <span class="keywordtype">int</span> block_type;
<a name="l02290"></a>02290     <a class="code" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a>* blk = 
<a name="l02291"></a>02291         blockman_.check_allocate_block(nblock, 
<a name="l02292"></a>02292                                        val,
<a name="l02293"></a>02293                                        <a class="code" href="a00043.html#a1f0f6467c82e6f2385632565e765d524" title="Returns blocks allocation strategy.">get_new_blocks_strat</a>(), 
<a name="l02294"></a>02294                                        &amp;block_type);
<a name="l02295"></a>02295     <span class="keywordflow">if</span> (!blk) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l02296"></a>02296 
<a name="l02297"></a>02297     <span class="comment">// calculate word number in block and bit</span>
<a name="l02298"></a>02298     <span class="keywordtype">unsigned</span> nbit   = unsigned(n &amp; <a class="code" href="a00115.html#a201fb8b1f81b7487f1c1c129fc3d6557">bm::set_block_mask</a>); 
<a name="l02299"></a>02299 
<a name="l02300"></a>02300     <span class="keywordflow">if</span> (block_type == 1) <span class="comment">// gap</span>
<a name="l02301"></a>02301     {
<a name="l02302"></a>02302         <a class="code" href="a00115.html#ac654d6319039a86546d235a236fc7cf6">bm::gap_word_t</a>* gap_blk = <a class="code" href="a00092.html#a6a7c8b8ee3f3b60ab907c1699acb7aa0">BMGAP_PTR</a>(blk);
<a name="l02303"></a>02303         <span class="keywordtype">bool</span> old_val = (<a class="code" href="a00119.html#ga866352ef5986a7d2b709795d127b666b" title="Tests if bit = pos is true.">gap_test</a>(gap_blk, nbit) != 0);
<a name="l02304"></a>02304 
<a name="l02305"></a>02305         <span class="keywordtype">bool</span> new_val = val &amp; old_val;
<a name="l02306"></a>02306         <span class="keywordflow">if</span> (new_val != old_val)
<a name="l02307"></a>02307         {
<a name="l02308"></a>02308             <span class="keywordtype">unsigned</span> is_set;
<a name="l02309"></a>02309             <span class="keywordtype">unsigned</span> new_block_len = 
<a name="l02310"></a>02310                 <a class="code" href="a00119.html#ga69186bd13bda27e04b3e33683ff884c2" title="Sets or clears bit in the GAP buffer.">gap_set_value</a>(new_val, gap_blk, nbit, &amp;is_set);
<a name="l02311"></a>02311             <a class="code" href="a00092.html#aa44515fab0ace8928d1cb82009a95bf8">BM_ASSERT</a>(is_set);
<a name="l02312"></a>02312             <a class="code" href="a00087.html#aef4146eb86de042a6c34717f87b16c10">BMCOUNT_ADJ</a>(val)
<a name="l02313"></a>02313 
<a name="l02314"></a>02314             unsigned threshold = 
<a name="l02315"></a>02315                 bm::<a class="code" href="a00119.html#ga94a5371b5dc6a1560d95d7c2dde88815" title="Returs GAP block capacity limit.">gap_limit</a>(gap_blk, blockman_.glen());
<a name="l02316"></a>02316             if (new_block_len &gt; threshold) 
<a name="l02317"></a>02317             {
<a name="l02318"></a>02318                 extend_gap_block(nblock, gap_blk);
<a name="l02319"></a>02319             }
<a name="l02320"></a>02320             <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l02321"></a>02321         }
<a name="l02322"></a>02322     }
<a name="l02323"></a>02323     <span class="keywordflow">else</span>  <span class="comment">// bit block</span>
<a name="l02324"></a>02324     {
<a name="l02325"></a>02325         <span class="keywordtype">unsigned</span> nword  = unsigned(nbit &gt;&gt; <a class="code" href="a00115.html#a83d76bccf6fe3770f32d5ba11d2a37ad">bm::set_word_shift</a>); 
<a name="l02326"></a>02326         nbit &amp;= <a class="code" href="a00115.html#addbf345be3733d5e4575d71733ed1da8">bm::set_word_mask</a>;
<a name="l02327"></a>02327 
<a name="l02328"></a>02328         <a class="code" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a>* word = blk + nword;
<a name="l02329"></a>02329         <a class="code" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a>  mask = (((<a class="code" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a>)1) &lt;&lt; nbit);
<a name="l02330"></a>02330         <span class="keywordtype">bool</span> is_set = ((*word) &amp; mask) != 0;
<a name="l02331"></a>02331 
<a name="l02332"></a>02332         <span class="keywordtype">bool</span> new_val = is_set &amp; val;
<a name="l02333"></a>02333         <span class="keywordflow">if</span> (new_val != val)    <span class="comment">// need to change bit</span>
<a name="l02334"></a>02334         {
<a name="l02335"></a>02335             <span class="keywordflow">if</span> (new_val)       <span class="comment">// set bit</span>
<a name="l02336"></a>02336             {
<a name="l02337"></a>02337                 *word |= mask;
<a name="l02338"></a>02338                 <a class="code" href="a00087.html#a911e3d9e9a293cafab1396a8700288e9">BMCOUNT_INC</a>;
<a name="l02339"></a>02339             }
<a name="l02340"></a>02340             <span class="keywordflow">else</span>               <span class="comment">// clear bit</span>
<a name="l02341"></a>02341             {
<a name="l02342"></a>02342                 *word &amp;= ~mask;
<a name="l02343"></a>02343                 <a class="code" href="a00087.html#a809c66152f5967c1a1eb51e006206630">BMCOUNT_DEC</a>;
<a name="l02344"></a>02344             }
<a name="l02345"></a>02345             <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l02346"></a>02346         }
<a name="l02347"></a>02347     }
<a name="l02348"></a>02348     <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l02349"></a>02349 }
<a name="l02350"></a>02350 
<a name="l02351"></a>02351 
<a name="l02352"></a>02352 <span class="comment">//---------------------------------------------------------------------</span>
<a name="l02353"></a>02353 
<a name="l02354"></a>02354 <span class="keyword">template</span>&lt;<span class="keyword">class</span> Alloc&gt; 
<a name="l02355"></a>02355 <a class="code" href="a00115.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a> bvector&lt;Alloc&gt;::check_or_next(<a class="code" href="a00115.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a> prev)<span class="keyword"> const</span>
<a name="l02356"></a>02356 <span class="keyword"></span>{
<a name="l02357"></a>02357     <span class="keywordflow">for</span> (;;)
<a name="l02358"></a>02358     {
<a name="l02359"></a>02359         <span class="keywordtype">unsigned</span> nblock = unsigned(prev &gt;&gt; <a class="code" href="a00115.html#ad8723fbeea6290d3daa8917ea7ce9bb2">bm::set_block_shift</a>); 
<a name="l02360"></a>02360         <span class="keywordflow">if</span> (nblock &gt;= <a class="code" href="a00115.html#a505011007f54598794e0b9477c0b0b11">bm::set_total_blocks</a>) 
<a name="l02361"></a>02361             <span class="keywordflow">break</span>;
<a name="l02362"></a>02362 
<a name="l02363"></a>02363         <span class="keywordflow">if</span> (blockman_.is_subblock_null(nblock &gt;&gt; <a class="code" href="a00115.html#ac1ff8647a089c751ec330cecee01907e">bm::set_array_shift</a>))
<a name="l02364"></a>02364         {
<a name="l02365"></a>02365             prev += (<a class="code" href="a00115.html#a2d1bf97ae342a7759943e62090fcf5d3">bm::set_blkblk_mask</a> + 1) -
<a name="l02366"></a>02366                             (prev &amp; <a class="code" href="a00115.html#a2d1bf97ae342a7759943e62090fcf5d3">bm::set_blkblk_mask</a>);
<a name="l02367"></a>02367         }
<a name="l02368"></a>02368         <span class="keywordflow">else</span>
<a name="l02369"></a>02369         {
<a name="l02370"></a>02370             <span class="keywordtype">unsigned</span> nbit = unsigned(prev &amp; <a class="code" href="a00115.html#a201fb8b1f81b7487f1c1c129fc3d6557">bm::set_block_mask</a>);
<a name="l02371"></a>02371             <span class="keywordtype">int</span> no_more_blocks;
<a name="l02372"></a>02372             <span class="keyword">const</span> <a class="code" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a>* block = 
<a name="l02373"></a>02373                 blockman_.get_block(nblock, &amp;no_more_blocks);
<a name="l02374"></a>02374 
<a name="l02375"></a>02375             <span class="keywordflow">if</span> (no_more_blocks) 
<a name="l02376"></a>02376             {
<a name="l02377"></a>02377                 <a class="code" href="a00092.html#aa44515fab0ace8928d1cb82009a95bf8">BM_ASSERT</a>(block == 0);
<a name="l02378"></a>02378                 <span class="keywordflow">break</span>;
<a name="l02379"></a>02379             }
<a name="l02380"></a>02380 
<a name="l02381"></a>02381             <span class="keywordflow">if</span> (block)
<a name="l02382"></a>02382             {
<a name="l02383"></a>02383                 <span class="keywordflow">if</span> (<a class="code" href="a00092.html#a074acb37afea68caaffe3832d326eb44">IS_FULL_BLOCK</a>(block)) <span class="keywordflow">return</span> prev;
<a name="l02384"></a>02384                 <span class="keywordflow">if</span> (<a class="code" href="a00092.html#a7bc243edc0a5e82979d6bf63f4debb9a">BM_IS_GAP</a>(block))
<a name="l02385"></a>02385                 {
<a name="l02386"></a>02386                     <span class="keywordflow">if</span> (<a class="code" href="a00119.html#gaa7df7193094353ea24b8519debf745be" title="Searches for the next 1 bit in the GAP block.">bm::gap_find_in_block</a>(<a class="code" href="a00092.html#a6a7c8b8ee3f3b60ab907c1699acb7aa0">BMGAP_PTR</a>(block),
<a name="l02387"></a>02387                                                 nbit,
<a name="l02388"></a>02388                                                 &amp;prev))
<a name="l02389"></a>02389                     {
<a name="l02390"></a>02390                         <span class="keywordflow">return</span> prev;
<a name="l02391"></a>02391                     }
<a name="l02392"></a>02392                 }
<a name="l02393"></a>02393                 <span class="keywordflow">else</span>
<a name="l02394"></a>02394                 {
<a name="l02395"></a>02395                     <span class="keywordflow">if</span> (<a class="code" href="a00120.html#gad6a7c549a625df7aa7d68d43a57238c7" title="Searches for the next 1 bit in the BIT block.">bm::bit_find_in_block</a>(block, nbit, &amp;prev)) 
<a name="l02396"></a>02396                     {
<a name="l02397"></a>02397                         <span class="keywordflow">return</span> prev;
<a name="l02398"></a>02398                     }
<a name="l02399"></a>02399                 }
<a name="l02400"></a>02400             }
<a name="l02401"></a>02401             <span class="keywordflow">else</span>
<a name="l02402"></a>02402             {
<a name="l02403"></a>02403                 prev += (<a class="code" href="a00115.html#a201fb8b1f81b7487f1c1c129fc3d6557">bm::set_block_mask</a> + 1) - 
<a name="l02404"></a>02404                             (prev &amp; <a class="code" href="a00115.html#a201fb8b1f81b7487f1c1c129fc3d6557">bm::set_block_mask</a>);
<a name="l02405"></a>02405             }
<a name="l02406"></a>02406 
<a name="l02407"></a>02407         }
<a name="l02408"></a>02408         <span class="keywordflow">if</span> (!prev) <span class="keywordflow">break</span>;
<a name="l02409"></a>02409     }
<a name="l02410"></a>02410 
<a name="l02411"></a>02411     <span class="keywordflow">return</span> 0;
<a name="l02412"></a>02412 }
<a name="l02413"></a>02413 
<a name="l02414"></a>02414 
<a name="l02415"></a>02415 <span class="comment">//---------------------------------------------------------------------</span>
<a name="l02416"></a>02416 
<a name="l02417"></a>02417 <span class="keyword">template</span>&lt;<span class="keyword">class</span> Alloc&gt; 
<a name="l02418"></a>02418 <a class="code" href="a00115.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a> bvector&lt;Alloc&gt;::check_or_next_extract(<a class="code" href="a00115.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a> prev)
<a name="l02419"></a>02419 {
<a name="l02420"></a>02420     <span class="keywordflow">for</span> (;;)
<a name="l02421"></a>02421     {
<a name="l02422"></a>02422         <span class="keywordtype">unsigned</span> nblock = unsigned(prev &gt;&gt; <a class="code" href="a00115.html#ad8723fbeea6290d3daa8917ea7ce9bb2">bm::set_block_shift</a>); 
<a name="l02423"></a>02423         <span class="keywordflow">if</span> (nblock &gt;= <a class="code" href="a00115.html#a505011007f54598794e0b9477c0b0b11">bm::set_total_blocks</a>) <span class="keywordflow">break</span>;
<a name="l02424"></a>02424 
<a name="l02425"></a>02425         <span class="keywordflow">if</span> (blockman_.is_subblock_null(nblock &gt;&gt; <a class="code" href="a00115.html#ac1ff8647a089c751ec330cecee01907e">bm::set_array_shift</a>))
<a name="l02426"></a>02426         {
<a name="l02427"></a>02427             prev += (<a class="code" href="a00115.html#a2d1bf97ae342a7759943e62090fcf5d3">bm::set_blkblk_mask</a> + 1) -
<a name="l02428"></a>02428                             (prev &amp; <a class="code" href="a00115.html#a2d1bf97ae342a7759943e62090fcf5d3">bm::set_blkblk_mask</a>);
<a name="l02429"></a>02429         }
<a name="l02430"></a>02430         <span class="keywordflow">else</span>
<a name="l02431"></a>02431         {
<a name="l02432"></a>02432             <span class="keywordtype">unsigned</span> nbit = unsigned(prev &amp; <a class="code" href="a00115.html#a201fb8b1f81b7487f1c1c129fc3d6557">bm::set_block_mask</a>);
<a name="l02433"></a>02433 
<a name="l02434"></a>02434             <span class="keywordtype">int</span> no_more_blocks;
<a name="l02435"></a>02435             <a class="code" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a>* block = 
<a name="l02436"></a>02436                 blockman_.get_block(nblock, &amp;no_more_blocks);
<a name="l02437"></a>02437 
<a name="l02438"></a>02438             <span class="keywordflow">if</span> (no_more_blocks) 
<a name="l02439"></a>02439             {
<a name="l02440"></a>02440                 <a class="code" href="a00092.html#aa44515fab0ace8928d1cb82009a95bf8">BM_ASSERT</a>(block == 0);
<a name="l02441"></a>02441                 <span class="keywordflow">break</span>;
<a name="l02442"></a>02442             }
<a name="l02443"></a>02443 
<a name="l02444"></a>02444 
<a name="l02445"></a>02445             <span class="keywordflow">if</span> (block)
<a name="l02446"></a>02446             {
<a name="l02447"></a>02447                 <span class="keywordflow">if</span> (<a class="code" href="a00092.html#a074acb37afea68caaffe3832d326eb44">IS_FULL_BLOCK</a>(block))
<a name="l02448"></a>02448                 {
<a name="l02449"></a>02449                     <span class="keyword">set</span>(prev, <span class="keyword">false</span>);
<a name="l02450"></a>02450                     <span class="keywordflow">return</span> prev;
<a name="l02451"></a>02451                 }
<a name="l02452"></a>02452                 <span class="keywordflow">if</span> (<a class="code" href="a00092.html#a7bc243edc0a5e82979d6bf63f4debb9a">BM_IS_GAP</a>(block))
<a name="l02453"></a>02453                 {
<a name="l02454"></a>02454                     <span class="keywordtype">unsigned</span> is_set;
<a name="l02455"></a>02455                     <span class="keywordtype">unsigned</span> new_block_len = 
<a name="l02456"></a>02456                         <a class="code" href="a00119.html#ga69186bd13bda27e04b3e33683ff884c2" title="Sets or clears bit in the GAP buffer.">gap_set_value</a>(0, <a class="code" href="a00092.html#a6a7c8b8ee3f3b60ab907c1699acb7aa0">BMGAP_PTR</a>(block), nbit, &amp;is_set);
<a name="l02457"></a>02457                     <span class="keywordflow">if</span> (is_set) {
<a name="l02458"></a>02458                         <a class="code" href="a00087.html#a809c66152f5967c1a1eb51e006206630">BMCOUNT_DEC</a>
<a name="l02459"></a>02459                         <span class="keywordtype">unsigned</span> threshold = 
<a name="l02460"></a>02460                             <a class="code" href="a00119.html#ga94a5371b5dc6a1560d95d7c2dde88815" title="Returs GAP block capacity limit.">bm::gap_limit</a>(<a class="code" href="a00092.html#a6a7c8b8ee3f3b60ab907c1699acb7aa0">BMGAP_PTR</a>(block), blockman_.glen());
<a name="l02461"></a>02461                         <span class="keywordflow">if</span> (new_block_len &gt; threshold) 
<a name="l02462"></a>02462                         {
<a name="l02463"></a>02463                             extend_gap_block(nblock, <a class="code" href="a00092.html#a6a7c8b8ee3f3b60ab907c1699acb7aa0">BMGAP_PTR</a>(block));
<a name="l02464"></a>02464                         }
<a name="l02465"></a>02465                         <span class="keywordflow">return</span> prev;
<a name="l02466"></a>02466                     } <span class="keywordflow">else</span> {
<a name="l02467"></a>02467                         <span class="keywordflow">if</span> (<a class="code" href="a00119.html#gaa7df7193094353ea24b8519debf745be" title="Searches for the next 1 bit in the GAP block.">bm::gap_find_in_block</a>(<a class="code" href="a00092.html#a6a7c8b8ee3f3b60ab907c1699acb7aa0">BMGAP_PTR</a>(block),
<a name="l02468"></a>02468                                                     nbit,
<a name="l02469"></a>02469                                                     &amp;prev))
<a name="l02470"></a>02470                         {
<a name="l02471"></a>02471                             <span class="keyword">set</span>(prev, <span class="keyword">false</span>);
<a name="l02472"></a>02472                             <span class="keywordflow">return</span> prev;
<a name="l02473"></a>02473                         }
<a name="l02474"></a>02474                     }
<a name="l02475"></a>02475                 }
<a name="l02476"></a>02476                 <span class="keywordflow">else</span> <span class="comment">// bit block</span>
<a name="l02477"></a>02477                 {
<a name="l02478"></a>02478                     <span class="keywordflow">if</span> (<a class="code" href="a00120.html#gad6a7c549a625df7aa7d68d43a57238c7" title="Searches for the next 1 bit in the BIT block.">bm::bit_find_in_block</a>(block, nbit, &amp;prev)) 
<a name="l02479"></a>02479                     {
<a name="l02480"></a>02480                         <a class="code" href="a00087.html#a809c66152f5967c1a1eb51e006206630">BMCOUNT_DEC</a>
<a name="l02481"></a>02481 
<a name="l02482"></a>02482                         <span class="keywordtype">unsigned</span> nbit = 
<a name="l02483"></a>02483                             unsigned(prev &amp; <a class="code" href="a00115.html#a201fb8b1f81b7487f1c1c129fc3d6557">bm::set_block_mask</a>); 
<a name="l02484"></a>02484                         <span class="keywordtype">unsigned</span> nword = 
<a name="l02485"></a>02485                             unsigned(nbit &gt;&gt; <a class="code" href="a00115.html#a83d76bccf6fe3770f32d5ba11d2a37ad">bm::set_word_shift</a>);
<a name="l02486"></a>02486                         nbit &amp;= <a class="code" href="a00115.html#addbf345be3733d5e4575d71733ed1da8">bm::set_word_mask</a>;
<a name="l02487"></a>02487                         <a class="code" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a>* word = block + nword;
<a name="l02488"></a>02488                         <a class="code" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a>  mask = ((<a class="code" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a>)1) &lt;&lt; nbit;
<a name="l02489"></a>02489                         *word &amp;= ~mask;
<a name="l02490"></a>02490 
<a name="l02491"></a>02491                         <span class="keywordflow">return</span> prev;
<a name="l02492"></a>02492                     }
<a name="l02493"></a>02493                 }
<a name="l02494"></a>02494             }
<a name="l02495"></a>02495             <span class="keywordflow">else</span>
<a name="l02496"></a>02496             {
<a name="l02497"></a>02497                 prev += (<a class="code" href="a00115.html#a201fb8b1f81b7487f1c1c129fc3d6557">bm::set_block_mask</a> + 1) - 
<a name="l02498"></a>02498                             (prev &amp; <a class="code" href="a00115.html#a201fb8b1f81b7487f1c1c129fc3d6557">bm::set_block_mask</a>);
<a name="l02499"></a>02499             }
<a name="l02500"></a>02500 
<a name="l02501"></a>02501         }
<a name="l02502"></a>02502         <span class="keywordflow">if</span> (!prev) <span class="keywordflow">break</span>;
<a name="l02503"></a>02503     }
<a name="l02504"></a>02504 
<a name="l02505"></a>02505     <span class="keywordflow">return</span> 0;
<a name="l02506"></a>02506 }
<a name="l02507"></a>02507 
<a name="l02508"></a>02508 <span class="comment">//---------------------------------------------------------------------</span>
<a name="l02509"></a>02509 
<a name="l02510"></a>02510 <span class="keyword">template</span>&lt;<span class="keyword">class</span> Alloc&gt; 
<a name="l02511"></a><a class="code" href="a00043.html#ae57f6d62d1f54eeaa604ae7ce53e0e0f">02511</a> <span class="keywordtype">void</span> <a class="code" href="a00043.html#ae57f6d62d1f54eeaa604ae7ce53e0e0f">bvector&lt;Alloc&gt;::combine_operation</a>(
<a name="l02512"></a>02512                                   <span class="keyword">const</span> <a class="code" href="a00043.html" title="bitvector with runtime compression of bits.">bm::bvector&lt;Alloc&gt;</a>&amp; <a class="code" href="a00043.html" title="bitvector with runtime compression of bits.">bvect</a>, 
<a name="l02513"></a>02513                                   <a class="code" href="a00115.html#a42405343976ec931388381cea4092bf1" title="Bit operations enumeration.">bm::operation</a>             opcode)
<a name="l02514"></a>02514 {
<a name="l02515"></a>02515     <span class="keyword">typedef</span> void (*block_bit_op)(<a class="code" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a>*, <span class="keyword">const</span> bm::word_t*);
<a name="l02516"></a>02516     <span class="keyword">typedef</span> void (*block_bit_op_next)(bm::word_t*, 
<a name="l02517"></a>02517                                       <span class="keyword">const</span> bm::word_t*, 
<a name="l02518"></a>02518                                       bm::word_t*, 
<a name="l02519"></a>02519                                       <span class="keyword">const</span> bm::word_t*);
<a name="l02520"></a>02520 
<a name="l02521"></a>02521     <span class="keywordtype">unsigned</span> top_blocks = blockman_.top_block_size();
<a name="l02522"></a>02522     <span class="keywordtype">unsigned</span> bvect_top_blocks = bvect.blockman_.top_block_size();
<a name="l02523"></a>02523 
<a name="l02524"></a>02524     <span class="keywordflow">if</span> (size_ == bvect.size_) 
<a name="l02525"></a>02525     {
<a name="l02526"></a>02526         <a class="code" href="a00092.html#aa44515fab0ace8928d1cb82009a95bf8">BM_ASSERT</a>(top_blocks &gt;= bvect_top_blocks);
<a name="l02527"></a>02527     }
<a name="l02528"></a>02528     <span class="keywordflow">else</span>
<a name="l02529"></a>02529     <span class="keywordflow">if</span> (size_ &lt; bvect.size_) <span class="comment">// this vect shorter than the arg.</span>
<a name="l02530"></a>02530     {
<a name="l02531"></a>02531         size_ = bvect.size_;
<a name="l02532"></a>02532         <span class="comment">// stretch our capacity</span>
<a name="l02533"></a>02533         blockman_.reserve_top_blocks(bvect_top_blocks);
<a name="l02534"></a>02534         top_blocks = blockman_.top_block_size();
<a name="l02535"></a>02535     }
<a name="l02536"></a>02536     <span class="keywordflow">else</span> 
<a name="l02537"></a>02537     <span class="keywordflow">if</span> (size_ &gt; bvect.size_) <span class="comment">// this vector larger</span>
<a name="l02538"></a>02538     {
<a name="l02539"></a>02539         <span class="keywordflow">if</span> (opcode == <a class="code" href="a00115.html#a42405343976ec931388381cea4092bf1a546fdf33b301e5b9bee0591522ed9250">BM_AND</a>) <span class="comment">// clear the tail with zeros</span>
<a name="l02540"></a>02540         {
<a name="l02541"></a>02541             <a class="code" href="a00043.html#ae14650ede7559f896894f951810cadbf" title="Sets all bits in the specified closed interval [left,right] Interval must be inside...">set_range</a>(bvect.size_, size_ - 1, <span class="keyword">false</span>);
<a name="l02542"></a>02542             <span class="keywordflow">if</span> (bvect_top_blocks &lt; top_blocks)
<a name="l02543"></a>02543             {
<a name="l02544"></a>02544                 <span class="comment">// not to scan blocks we already swiped</span>
<a name="l02545"></a>02545                 top_blocks = bvect_top_blocks;
<a name="l02546"></a>02546             }
<a name="l02547"></a>02547         }
<a name="l02548"></a>02548     }
<a name="l02549"></a>02549     
<a name="l02550"></a>02550     bm::word_t*** blk_root = blockman_.blocks_root();
<a name="l02551"></a>02551     <span class="keywordtype">unsigned</span> block_idx = 0;
<a name="l02552"></a>02552     <span class="keywordtype">unsigned</span> i, j;
<a name="l02553"></a>02553 
<a name="l02554"></a>02554     <a class="code" href="a00092.html#a7e6f87ba3230dece2125af5c32e84b05">BM_SET_MMX_GUARD</a>
<a name="l02555"></a>02555 
<a name="l02556"></a>02556     <span class="comment">// calculate effective top size to avoid overscan</span>
<a name="l02557"></a>02557     top_blocks = blockman_.effective_top_block_size();
<a name="l02558"></a>02558     <span class="keywordflow">if</span> (top_blocks &lt; bvect.blockman_.effective_top_block_size())
<a name="l02559"></a>02559     {
<a name="l02560"></a>02560         <span class="keywordflow">if</span> (opcode != <a class="code" href="a00115.html#a42405343976ec931388381cea4092bf1a546fdf33b301e5b9bee0591522ed9250">BM_AND</a>)
<a name="l02561"></a>02561         {
<a name="l02562"></a>02562             top_blocks = bvect.blockman_.effective_top_block_size();
<a name="l02563"></a>02563         }
<a name="l02564"></a>02564     }
<a name="l02565"></a>02565 
<a name="l02566"></a>02566     <span class="keywordflow">for</span> (i = 0; i &lt; top_blocks; ++i)
<a name="l02567"></a>02567     {
<a name="l02568"></a>02568         bm::word_t** blk_blk = blk_root[i];
<a name="l02569"></a>02569         <span class="keywordflow">if</span> (blk_blk == 0) <span class="comment">// not allocated</span>
<a name="l02570"></a>02570         {
<a name="l02571"></a>02571             <span class="keywordflow">if</span> (opcode == <a class="code" href="a00115.html#a42405343976ec931388381cea4092bf1a546fdf33b301e5b9bee0591522ed9250">BM_AND</a>) <span class="comment">// 0 AND anything == 0</span>
<a name="l02572"></a>02572             {
<a name="l02573"></a>02573                 block_idx += <a class="code" href="a00115.html#a40ad34d6c46a2fb20ba2baa7f95d80b4">bm::set_array_size</a>;
<a name="l02574"></a>02574                 <span class="keywordflow">continue</span>; 
<a name="l02575"></a>02575             }
<a name="l02576"></a>02576             <span class="keyword">const</span> bm::word_t* <span class="keyword">const</span>* bvbb = bvect.blockman_.get_topblock(i);
<a name="l02577"></a>02577             <span class="keywordflow">if</span> (bvbb == 0) <span class="comment">// skip it because 0 OP 0 == 0 </span>
<a name="l02578"></a>02578             {
<a name="l02579"></a>02579                 block_idx += <a class="code" href="a00115.html#a40ad34d6c46a2fb20ba2baa7f95d80b4">bm::set_array_size</a>;
<a name="l02580"></a>02580                 <span class="keywordflow">continue</span>; 
<a name="l02581"></a>02581             }
<a name="l02582"></a>02582             <span class="comment">// 0 - self, non-zero argument</span>
<a name="l02583"></a>02583             <span class="keywordtype">unsigned</span> r = i * <a class="code" href="a00115.html#a40ad34d6c46a2fb20ba2baa7f95d80b4">bm::set_array_size</a>;
<a name="l02584"></a>02584             <span class="keywordflow">for</span> (j = 0; j &lt; bm::set_array_size; ++j)
<a name="l02585"></a>02585             {
<a name="l02586"></a>02586                 <span class="keyword">const</span> bm::word_t* arg_blk = bvect.blockman_.get_block(i, j);
<a name="l02587"></a>02587                 <span class="keywordflow">if</span> (arg_blk )
<a name="l02588"></a>02588                     combine_operation_with_block(r + j,
<a name="l02589"></a>02589                                                  0, 0, 
<a name="l02590"></a>02590                                                  arg_blk, <a class="code" href="a00092.html#a7bc243edc0a5e82979d6bf63f4debb9a">BM_IS_GAP</a>(arg_blk), 
<a name="l02591"></a>02591                                                  opcode);
<a name="l02592"></a>02592             } <span class="comment">// for j</span>
<a name="l02593"></a>02593             <span class="keywordflow">continue</span>;
<a name="l02594"></a>02594         }
<a name="l02595"></a>02595 
<a name="l02596"></a>02596         <span class="keywordflow">if</span> (opcode == <a class="code" href="a00115.html#a42405343976ec931388381cea4092bf1a546fdf33b301e5b9bee0591522ed9250">BM_AND</a>)
<a name="l02597"></a>02597         {
<a name="l02598"></a>02598             <span class="keywordtype">unsigned</span> r = i * <a class="code" href="a00115.html#a40ad34d6c46a2fb20ba2baa7f95d80b4">bm::set_array_size</a>;
<a name="l02599"></a>02599             <span class="keywordflow">for</span> (j = 0; j &lt; bm::set_array_size; ++j)
<a name="l02600"></a>02600             {            
<a name="l02601"></a>02601                 bm::word_t* blk = blk_blk[j];
<a name="l02602"></a>02602                 <span class="keywordflow">if</span> (blk)
<a name="l02603"></a>02603                 {
<a name="l02604"></a>02604                     <span class="keyword">const</span> bm::word_t* arg_blk = bvect.blockman_.get_block(i, j);            
<a name="l02605"></a>02605                     <span class="keywordflow">if</span> (arg_blk)
<a name="l02606"></a>02606                         combine_operation_with_block(r + j,
<a name="l02607"></a>02607                                                      <a class="code" href="a00092.html#a7bc243edc0a5e82979d6bf63f4debb9a">BM_IS_GAP</a>(blk), blk, 
<a name="l02608"></a>02608                                                      arg_blk, <a class="code" href="a00092.html#a7bc243edc0a5e82979d6bf63f4debb9a">BM_IS_GAP</a>(arg_blk),
<a name="l02609"></a>02609                                                      opcode);                    
<a name="l02610"></a>02610                     <span class="keywordflow">else</span>
<a name="l02611"></a>02611                         blockman_.zero_block(i, j);
<a name="l02612"></a>02612                 }
<a name="l02613"></a>02613 
<a name="l02614"></a>02614             } <span class="comment">// for j</span>
<a name="l02615"></a>02615         }
<a name="l02616"></a>02616         <span class="keywordflow">else</span> <span class="comment">// OR, SUB, XOR</span>
<a name="l02617"></a>02617         {
<a name="l02618"></a>02618             <span class="keywordtype">unsigned</span> r = i * <a class="code" href="a00115.html#a40ad34d6c46a2fb20ba2baa7f95d80b4">bm::set_array_size</a>;
<a name="l02619"></a>02619             <span class="keywordflow">for</span> (j = 0; j &lt; bm::set_array_size; ++j)
<a name="l02620"></a>02620             {            
<a name="l02621"></a>02621                 bm::word_t* blk = blk_blk[j];
<a name="l02622"></a>02622                 <span class="keyword">const</span> bm::word_t* arg_blk = bvect.blockman_.get_block(i, j);            
<a name="l02623"></a>02623                 <span class="keywordflow">if</span> (arg_blk || blk)
<a name="l02624"></a>02624                     combine_operation_with_block(r + j, <a class="code" href="a00092.html#a7bc243edc0a5e82979d6bf63f4debb9a">BM_IS_GAP</a>(blk), blk, 
<a name="l02625"></a>02625                                                  arg_blk, <a class="code" href="a00092.html#a7bc243edc0a5e82979d6bf63f4debb9a">BM_IS_GAP</a>(arg_blk),
<a name="l02626"></a>02626                                                  opcode);
<a name="l02627"></a>02627             } <span class="comment">// for j</span>
<a name="l02628"></a>02628         }
<a name="l02629"></a>02629     } <span class="comment">// for i</span>
<a name="l02630"></a>02630 
<a name="l02631"></a>02631 }
<a name="l02632"></a>02632 
<a name="l02633"></a>02633 
<a name="l02634"></a>02634 <span class="comment">//---------------------------------------------------------------------</span>
<a name="l02635"></a>02635 
<a name="l02636"></a>02636 
<a name="l02637"></a>02637 <span class="keyword">template</span>&lt;<span class="keyword">class</span> Alloc&gt; 
<a name="l02638"></a>02638 <span class="keywordtype">void</span> 
<a name="l02639"></a>02639 <a class="code" href="a00043.html" title="bitvector with runtime compression of bits.">bvector&lt;Alloc&gt;::combine_operation_with_block</a>(<span class="keywordtype">unsigned</span>          nb,
<a name="l02640"></a>02640                                              <span class="keywordtype">unsigned</span>          gap,
<a name="l02641"></a>02641                                              <a class="code" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a>*       blk,
<a name="l02642"></a>02642                                              <span class="keyword">const</span> <a class="code" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a>* arg_blk,
<a name="l02643"></a>02643                                              <span class="keywordtype">int</span>               arg_gap,
<a name="l02644"></a>02644                                              <a class="code" href="a00115.html#a42405343976ec931388381cea4092bf1" title="Bit operations enumeration.">bm::operation</a>     opcode)
<a name="l02645"></a>02645 {
<a name="l02646"></a>02646     <a class="code" href="a00115.html#ac654d6319039a86546d235a236fc7cf6">gap_word_t</a> tmp_buf[<a class="code" href="a00115.html#a9b1715d6d9164d56172e75bbbd0e3000">bm::gap_equiv_len</a> * 3]; <span class="comment">// temporary result            </span>
<a name="l02647"></a>02647     <span class="keyword">const</span> <a class="code" href="a00115.html#ac654d6319039a86546d235a236fc7cf6">bm::gap_word_t</a>* res;
<a name="l02648"></a>02648     <span class="keywordtype">unsigned</span> res_len;
<a name="l02649"></a>02649     <span class="keywordtype">int</span>      level;
<a name="l02650"></a>02650     <span class="keywordtype">unsigned</span> threshold;
<a name="l02651"></a>02651 
<a name="l02652"></a>02652 
<a name="l02653"></a>02653     <span class="keywordflow">if</span> (opcode == <a class="code" href="a00115.html#a42405343976ec931388381cea4092bf1a0c8cf0197857d0bd73a63037e2f2c5c5">BM_OR</a> || opcode == <a class="code" href="a00115.html#a42405343976ec931388381cea4092bf1a45c2fe36efb72dc03f03a842d253f64c">BM_XOR</a>)
<a name="l02654"></a>02654     {        
<a name="l02655"></a>02655         <span class="keywordflow">if</span> (!blk &amp;&amp; arg_gap) 
<a name="l02656"></a>02656         {
<a name="l02657"></a>02657             res = <a class="code" href="a00092.html#a6a7c8b8ee3f3b60ab907c1699acb7aa0">BMGAP_PTR</a>(arg_blk);
<a name="l02658"></a>02658             res_len = <a class="code" href="a00119.html#ga02541ec6c2930c292eda4313b78e874c" title="Returs GAP block length.">bm::gap_length</a>(res);
<a name="l02659"></a>02659             level = -1;
<a name="l02660"></a>02660             threshold = 0;
<a name="l02661"></a>02661             <span class="keywordflow">goto</span> assign_gap_result;
<a name="l02662"></a>02662         }
<a name="l02663"></a>02663     }
<a name="l02664"></a>02664 
<a name="l02665"></a>02665         <span class="keywordflow">if</span> (gap) <span class="comment">// our block GAP-type</span>
<a name="l02666"></a>02666         {
<a name="l02667"></a>02667             <span class="keywordflow">if</span> (arg_gap)  <span class="comment">// both blocks GAP-type</span>
<a name="l02668"></a>02668             {
<a name="l02669"></a>02669                 {
<a name="l02670"></a>02670                     <a class="code" href="a00115.html#a8402de852093e5b23b5825f1974b9c12">gap_operation_func_type</a> gfunc = 
<a name="l02671"></a>02671                         operation_functions&lt;true&gt;::gap_operation(opcode);
<a name="l02672"></a>02672                     <a class="code" href="a00092.html#aa44515fab0ace8928d1cb82009a95bf8">BM_ASSERT</a>(gfunc);
<a name="l02673"></a>02673                     res = (*gfunc)(<a class="code" href="a00092.html#a6a7c8b8ee3f3b60ab907c1699acb7aa0">BMGAP_PTR</a>(blk), 
<a name="l02674"></a>02674                                    <a class="code" href="a00092.html#a6a7c8b8ee3f3b60ab907c1699acb7aa0">BMGAP_PTR</a>(arg_blk), 
<a name="l02675"></a>02675                                    tmp_buf,
<a name="l02676"></a>02676                                    res_len);
<a name="l02677"></a>02677                 }
<a name="l02678"></a>02678                 <a class="code" href="a00092.html#aa44515fab0ace8928d1cb82009a95bf8">BM_ASSERT</a>(res == tmp_buf);
<a name="l02679"></a>02679                 ++res_len;<span class="comment">// = bm::gap_length(res);</span>
<a name="l02680"></a>02680 
<a name="l02681"></a>02681                 <a class="code" href="a00092.html#aa44515fab0ace8928d1cb82009a95bf8">BM_ASSERT</a>(!(res == tmp_buf &amp;&amp; res_len == 0));
<a name="l02682"></a>02682 
<a name="l02683"></a>02683                 <span class="comment">// if as a result of the operation gap block turned to zero</span>
<a name="l02684"></a>02684                 <span class="comment">// we can now replace it with NULL</span>
<a name="l02685"></a>02685                 <span class="keywordflow">if</span> (<a class="code" href="a00119.html#ga690ff7c8b16e1821a77663b7194267e7" title="Temporary inverts all bits in the GAP buffer.">gap_is_all_zero</a>(res, <a class="code" href="a00115.html#ad0b8714080144ac70197840ff96752b7">bm::gap_max_bits</a>))
<a name="l02686"></a>02686                 {
<a name="l02687"></a>02687                     blockman_.zero_block(nb);
<a name="l02688"></a>02688                     <span class="keywordflow">return</span>;
<a name="l02689"></a>02689                 }
<a name="l02690"></a>02690 
<a name="l02691"></a>02691                 <span class="comment">// mutation check</span>
<a name="l02692"></a>02692 
<a name="l02693"></a>02693                 level = <a class="code" href="a00119.html#ga1defe73aa4227a0e7204363ac6bb1ac1" title="Returs GAP blocks capacity level.">gap_level</a>(<a class="code" href="a00092.html#a6a7c8b8ee3f3b60ab907c1699acb7aa0">BMGAP_PTR</a>(blk));
<a name="l02694"></a>02694                 threshold = blockman_.glen(level)-4;
<a name="l02695"></a>02695 
<a name="l02696"></a>02696             assign_gap_result:
<a name="l02697"></a>02697                 <span class="keywordtype">int</span> new_level = <a class="code" href="a00119.html#ga3bfaebeeb4b2d479c5a9ac9d57607165" title="Calculates GAP block capacity level.">gap_calc_level</a>(res_len, blockman_.glen());
<a name="l02698"></a>02698                 <span class="keywordflow">if</span> (new_level == -1)
<a name="l02699"></a>02699                 {
<a name="l02700"></a>02700                     blockman_.convert_gap2bitset(nb, res, res_len-1);
<a name="l02701"></a>02701                     <span class="keywordflow">return</span>;
<a name="l02702"></a>02702                 }
<a name="l02703"></a>02703 
<a name="l02704"></a>02704                 <span class="keywordflow">if</span> (res_len &gt; threshold)
<a name="l02705"></a>02705                 {
<a name="l02706"></a>02706                     <a class="code" href="a00115.html#ac654d6319039a86546d235a236fc7cf6">gap_word_t</a>* new_blk = 
<a name="l02707"></a>02707                         blockman_.allocate_gap_block(new_level, res);
<a name="l02708"></a>02708                     <a class="code" href="a00119.html#ga501aa9bf029e7f9ea9518e7003fe5549" title="Sets GAP block capacity level.">set_gap_level</a>(new_blk, new_level);
<a name="l02709"></a>02709 
<a name="l02710"></a>02710                     <a class="code" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a>* p = (<a class="code" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a>*)new_blk;
<a name="l02711"></a>02711                     <a class="code" href="a00092.html#a93dbdb1a62ca0ce33149d3249dbf386e">BMSET_PTRGAP</a>(p);
<a name="l02712"></a>02712 
<a name="l02713"></a>02713                     <span class="keywordflow">if</span> (blk)
<a name="l02714"></a>02714                     {
<a name="l02715"></a>02715                         blockman_.set_block_ptr(nb, p);
<a name="l02716"></a>02716                         blockman_.get_allocator().free_gap_block(<a class="code" href="a00092.html#a6a7c8b8ee3f3b60ab907c1699acb7aa0">BMGAP_PTR</a>(blk), 
<a name="l02717"></a>02717                                                                  blockman_.glen());
<a name="l02718"></a>02718                     }
<a name="l02719"></a>02719                     <span class="keywordflow">else</span>
<a name="l02720"></a>02720                     {
<a name="l02721"></a>02721                         blockman_.set_block(nb, p, <span class="keyword">true</span>); <span class="comment">// set GAP block</span>
<a name="l02722"></a>02722                     }
<a name="l02723"></a>02723                     <span class="keywordflow">return</span>;
<a name="l02724"></a>02724                 }
<a name="l02725"></a>02725 
<a name="l02726"></a>02726                 <span class="comment">// gap operation result is in the temporary buffer</span>
<a name="l02727"></a>02727                 <span class="comment">// we copy it back to the gap_block</span>
<a name="l02728"></a>02728 
<a name="l02729"></a>02729                 <a class="code" href="a00092.html#aa44515fab0ace8928d1cb82009a95bf8">BM_ASSERT</a>(blk);
<a name="l02730"></a>02730 
<a name="l02731"></a>02731                 <a class="code" href="a00119.html#ga501aa9bf029e7f9ea9518e7003fe5549" title="Sets GAP block capacity level.">set_gap_level</a>(tmp_buf, level);
<a name="l02732"></a>02732                 ::memcpy(<a class="code" href="a00092.html#a6a7c8b8ee3f3b60ab907c1699acb7aa0">BMGAP_PTR</a>(blk), tmp_buf, res_len * <span class="keyword">sizeof</span>(<a class="code" href="a00115.html#ac654d6319039a86546d235a236fc7cf6">gap_word_t</a>));
<a name="l02733"></a>02733                 <span class="keywordflow">return</span>;
<a name="l02734"></a>02734             }
<a name="l02735"></a>02735             <span class="keywordflow">else</span> <span class="comment">// argument is BITSET-type (own block is GAP)</span>
<a name="l02736"></a>02736             {
<a name="l02737"></a>02737                 <span class="comment">// since we can not combine blocks of mixed type</span>
<a name="l02738"></a>02738                 <span class="comment">// we need to convert our block to bitset</span>
<a name="l02739"></a>02739                
<a name="l02740"></a>02740                 <span class="keywordflow">if</span> (arg_blk == 0)  <span class="comment">// Combining against an empty block</span>
<a name="l02741"></a>02741                 {
<a name="l02742"></a>02742                     <span class="keywordflow">switch</span> (opcode)
<a name="l02743"></a>02743                     {
<a name="l02744"></a>02744                     <span class="keywordflow">case</span> <a class="code" href="a00115.html#a42405343976ec931388381cea4092bf1a546fdf33b301e5b9bee0591522ed9250">BM_AND</a>:  <span class="comment">// (&quot;Value&quot; AND  0) == 0</span>
<a name="l02745"></a>02745                         blockman_.zero_block(nb);
<a name="l02746"></a>02746                         <span class="keywordflow">return</span>;
<a name="l02747"></a>02747                     <span class="keywordflow">case</span> <a class="code" href="a00115.html#a42405343976ec931388381cea4092bf1a0c8cf0197857d0bd73a63037e2f2c5c5">BM_OR</a>: <span class="keywordflow">case</span> <a class="code" href="a00115.html#a42405343976ec931388381cea4092bf1a1df0f4de7126bb2f7ce69d7a005affb5">BM_SUB</a>: <span class="keywordflow">case</span> <a class="code" href="a00115.html#a42405343976ec931388381cea4092bf1a45c2fe36efb72dc03f03a842d253f64c">BM_XOR</a>:
<a name="l02748"></a>02748                         <span class="keywordflow">return</span>; <span class="comment">// nothing to do</span>
<a name="l02749"></a>02749                     }
<a name="l02750"></a>02750                 }
<a name="l02751"></a>02751                 <a class="code" href="a00115.html#ac654d6319039a86546d235a236fc7cf6">gap_word_t</a>* gap_blk = <a class="code" href="a00092.html#a6a7c8b8ee3f3b60ab907c1699acb7aa0">BMGAP_PTR</a>(blk);
<a name="l02752"></a>02752                 <span class="keywordflow">if</span> (opcode == <a class="code" href="a00115.html#a42405343976ec931388381cea4092bf1a546fdf33b301e5b9bee0591522ed9250">BM_AND</a>)
<a name="l02753"></a>02753                 {
<a name="l02754"></a>02754                     <span class="keywordtype">unsigned</span> gap_cnt = <a class="code" href="a00119.html#ga570a6f573ffb9ac9e41a688d2bdc6004" title="Calculates number of bits ON in GAP buffer.">gap_bit_count</a>(gap_blk);
<a name="l02755"></a>02755                     <span class="keywordflow">if</span> (gap_cnt &lt; 128)
<a name="l02756"></a>02756                     {
<a name="l02757"></a>02757                         <a class="code" href="a00115.html#ac654d6319039a86546d235a236fc7cf6">gap_word_t</a> tmp_buf[<a class="code" href="a00115.html#a9b1715d6d9164d56172e75bbbd0e3000">bm::gap_equiv_len</a> * 3];         
<a name="l02758"></a>02758                         <a class="code" href="a00115.html#ac654d6319039a86546d235a236fc7cf6">gap_word_t</a> arr_len = 
<a name="l02759"></a>02759                             <a class="code" href="a00119.html#ga5cd7e0cfee401da1b8f702151c083b27" title="Convert gap block into array of ints corresponding to 1 bits.">gap_convert_to_arr</a>(tmp_buf, gap_blk, 
<a name="l02760"></a>02760                                                <a class="code" href="a00115.html#a9b1715d6d9164d56172e75bbbd0e3000">bm::gap_equiv_len</a>-10);
<a name="l02761"></a>02761                         <a class="code" href="a00092.html#aa44515fab0ace8928d1cb82009a95bf8">BM_ASSERT</a>(gap_cnt == arr_len);
<a name="l02762"></a>02762                         blockman_.zero_block(nb);
<a name="l02763"></a>02763                         <span class="keywordtype">unsigned</span> arr_i = 0;
<a name="l02764"></a>02764                         <span class="keywordtype">int</span> block_type;
<a name="l02765"></a>02765                         blk =
<a name="l02766"></a>02766                             blockman_.check_allocate_block(nb,
<a name="l02767"></a>02767                                                            <span class="keyword">true</span>,
<a name="l02768"></a>02768                                                            <a class="code" href="a00118.html#ggad0b87b3b7292383a864d27feaf1c9effa7fe09d1d7c62a813db922c396c0cbc9c" title="GAP compression is ON.">BM_GAP</a>,
<a name="l02769"></a>02769                                                            &amp;block_type,
<a name="l02770"></a>02770                                                            <span class="keyword">false</span> <span class="comment">//no null return</span>
<a name="l02771"></a>02771                                                            );
<a name="l02772"></a>02772                         <a class="code" href="a00092.html#aa44515fab0ace8928d1cb82009a95bf8">BM_ASSERT</a>(block_type==1); <span class="comment">// GAP</span>
<a name="l02773"></a>02773                         gap_blk = <a class="code" href="a00092.html#a6a7c8b8ee3f3b60ab907c1699acb7aa0">BMGAP_PTR</a>(blk);
<a name="l02774"></a>02774                         <span class="keywordtype">unsigned</span> threshold = <a class="code" href="a00119.html#ga94a5371b5dc6a1560d95d7c2dde88815" title="Returs GAP block capacity limit.">bm::gap_limit</a>(gap_blk, blockman_.glen());
<a name="l02775"></a>02775                         <span class="keywordflow">for</span> (; arr_i &lt; arr_len; ++arr_i)
<a name="l02776"></a>02776                         {
<a name="l02777"></a>02777                             <a class="code" href="a00115.html#ac654d6319039a86546d235a236fc7cf6">gap_word_t</a> bit_idx = tmp_buf[arr_i];
<a name="l02778"></a>02778                             <span class="keywordflow">if</span> (<a class="code" href="a00120.html#ga9bccc586aa791f98f1bec284b799102c" title="Test 1 bit in a block.">bm::test_bit</a>(arg_blk, bit_idx))
<a name="l02779"></a>02779                             {
<a name="l02780"></a>02780                                 <span class="keywordtype">unsigned</span> is_set;
<a name="l02781"></a>02781                                 <span class="keywordtype">unsigned</span> new_block_len =
<a name="l02782"></a>02782                                     <a class="code" href="a00119.html#ga69186bd13bda27e04b3e33683ff884c2" title="Sets or clears bit in the GAP buffer.">gap_set_value</a>(<span class="keyword">true</span>, gap_blk, bit_idx, &amp;is_set);
<a name="l02783"></a>02783                                 <a class="code" href="a00092.html#aa44515fab0ace8928d1cb82009a95bf8">BM_ASSERT</a>(is_set);
<a name="l02784"></a>02784                                 <span class="keywordflow">if</span> (new_block_len &gt; threshold) 
<a name="l02785"></a>02785                                 {
<a name="l02786"></a>02786                                     gap_blk = 
<a name="l02787"></a>02787                                         blockman_.extend_gap_block(nb, gap_blk);
<a name="l02788"></a>02788                                     <span class="keywordflow">if</span> (gap_blk == 0) <span class="comment">// mutated into bit-block</span>
<a name="l02789"></a>02789                                     {
<a name="l02790"></a>02790                                         blk = blockman_.check_allocate_block(
<a name="l02791"></a>02791                                                          nb,
<a name="l02792"></a>02792                                                          <span class="keyword">true</span>,
<a name="l02793"></a>02793                                                          this-&gt;<a class="code" href="a00043.html#a1f0f6467c82e6f2385632565e765d524" title="Returns blocks allocation strategy.">get_new_blocks_strat</a>(),
<a name="l02794"></a>02794                                                          &amp;block_type,
<a name="l02795"></a>02795                                                          <span class="keyword">false</span> <span class="comment">// no null return</span>
<a name="l02796"></a>02796                                                          );  
<a name="l02797"></a>02797                                         <a class="code" href="a00092.html#aa44515fab0ace8928d1cb82009a95bf8">BM_ASSERT</a>(block_type == 0); <span class="comment">// BIT</span>
<a name="l02798"></a>02798                                         <span class="comment">// target block degraded into plain bit-block</span>
<a name="l02799"></a>02799                                         <span class="keywordflow">for</span> (++arr_i; arr_i &lt; arr_len; ++arr_i)
<a name="l02800"></a>02800                                         {
<a name="l02801"></a>02801                                             bit_idx = tmp_buf[arr_i];
<a name="l02802"></a>02802                                             <span class="keywordflow">if</span> (<a class="code" href="a00120.html#ga9bccc586aa791f98f1bec284b799102c" title="Test 1 bit in a block.">bm::test_bit</a>(arg_blk, bit_idx))
<a name="l02803"></a>02803                                             {
<a name="l02804"></a>02804                                                 <a class="code" href="a00120.html#gad698b5242f5b629aa28e7338b7150497" title="Sets bits to 1 in the bitblock.">or_bit_block</a>(blk, bit_idx, 1);
<a name="l02805"></a>02805                                             }
<a name="l02806"></a>02806                                         } <span class="comment">// for arr_i</span>
<a name="l02807"></a>02807                                         <span class="keywordflow">return</span>;
<a name="l02808"></a>02808                                     } <span class="comment">// if gap mutated</span>
<a name="l02809"></a>02809                                 }
<a name="l02810"></a>02810                             } <span class="comment">// for arr_i</span>
<a name="l02811"></a>02811                         }
<a name="l02812"></a>02812 
<a name="l02813"></a>02813                         <span class="keywordflow">return</span>;
<a name="l02814"></a>02814                     }                    
<a name="l02815"></a>02815                 } <span class="comment">// BM_AND</span>
<a name="l02816"></a>02816 
<a name="l02817"></a>02817                 blk = blockman_.convert_gap2bitset(nb, gap_blk);
<a name="l02818"></a>02818             }
<a name="l02819"></a>02819         } 
<a name="l02820"></a>02820         <span class="keywordflow">else</span> <span class="comment">// our block is BITSET-type</span>
<a name="l02821"></a>02821         {
<a name="l02822"></a>02822             <span class="keywordflow">if</span> (arg_gap) <span class="comment">// argument block is GAP-type</span>
<a name="l02823"></a>02823             {
<a name="l02824"></a>02824                 <span class="keywordflow">if</span> (<a class="code" href="a00092.html#a13ba598909515339ceede09e3b9b0198">IS_VALID_ADDR</a>(blk))
<a name="l02825"></a>02825                 {
<a name="l02826"></a>02826                     <span class="comment">// special case, maybe we can do the job without </span>
<a name="l02827"></a>02827                     <span class="comment">// converting the GAP argument to bitblock</span>
<a name="l02828"></a>02828                     <a class="code" href="a00115.html#a18a8f03b151ca3a6d5e39e7709fb6c7c">gap_operation_to_bitset_func_type</a> gfunc = 
<a name="l02829"></a>02829                         operation_functions&lt;true&gt;::gap_op_to_bit(opcode);
<a name="l02830"></a>02830                     <a class="code" href="a00092.html#aa44515fab0ace8928d1cb82009a95bf8">BM_ASSERT</a>(gfunc);
<a name="l02831"></a>02831                     (*gfunc)(blk, <a class="code" href="a00092.html#a6a7c8b8ee3f3b60ab907c1699acb7aa0">BMGAP_PTR</a>(arg_blk));
<a name="l02832"></a>02832                     <span class="keywordflow">return</span>;
<a name="l02833"></a>02833                 }
<a name="l02834"></a>02834                 
<a name="l02835"></a>02835                 <span class="comment">// the worst case we need to convert argument block to </span>
<a name="l02836"></a>02836                 <span class="comment">// bitset type.</span>
<a name="l02837"></a>02837                 <a class="code" href="a00115.html#ac654d6319039a86546d235a236fc7cf6">gap_word_t</a>* temp_blk = (<a class="code" href="a00115.html#ac654d6319039a86546d235a236fc7cf6">gap_word_t</a>*) blockman_.check_allocate_tempblock();
<a name="l02838"></a>02838                 arg_blk = 
<a name="l02839"></a>02839                     <a class="code" href="a00119.html#ga3f01bb7c1ae7983aa8c4ba82e1e3f54c" title="Smart GAP block to bitblock conversion.">gap_convert_to_bitset_smart</a>((<a class="code" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a>*)temp_blk, 
<a name="l02840"></a>02840                                                 <a class="code" href="a00092.html#a6a7c8b8ee3f3b60ab907c1699acb7aa0">BMGAP_PTR</a>(arg_blk), 
<a name="l02841"></a>02841                                                 <a class="code" href="a00115.html#ad0b8714080144ac70197840ff96752b7">bm::gap_max_bits</a>);
<a name="l02842"></a>02842             
<a name="l02843"></a>02843             }   
<a name="l02844"></a>02844         }
<a name="l02845"></a>02845     
<a name="l02846"></a>02846         <span class="comment">// Now here we combine two plain bitblocks using supplied bit function.</span>
<a name="l02847"></a>02847         <a class="code" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a>* dst = blk;
<a name="l02848"></a>02848 
<a name="l02849"></a>02849         <a class="code" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a>* ret; 
<a name="l02850"></a>02850         <span class="keywordflow">if</span> (dst == 0 &amp;&amp; arg_blk == 0)
<a name="l02851"></a>02851         {
<a name="l02852"></a>02852             <span class="keywordflow">return</span>;
<a name="l02853"></a>02853         }
<a name="l02854"></a>02854 
<a name="l02855"></a>02855         <span class="keywordflow">switch</span> (opcode)
<a name="l02856"></a>02856         {
<a name="l02857"></a>02857         <span class="keywordflow">case</span> <a class="code" href="a00115.html#a42405343976ec931388381cea4092bf1a546fdf33b301e5b9bee0591522ed9250">BM_AND</a>:
<a name="l02858"></a>02858             ret = <a class="code" href="a00120.html#ga869fce5348076d4c7b92adcc2f1a49ab" title="bitblock AND operation.">bit_operation_and</a>(dst, arg_blk);
<a name="l02859"></a>02859             <span class="keywordflow">goto</span> copy_block;
<a name="l02860"></a>02860         <span class="keywordflow">case</span> <a class="code" href="a00115.html#a42405343976ec931388381cea4092bf1a45c2fe36efb72dc03f03a842d253f64c">BM_XOR</a>:
<a name="l02861"></a>02861             ret = <a class="code" href="a00120.html#ga179de722e87ccf8189d975ca6beed025" title="bitblock XOR operation.">bit_operation_xor</a>(dst, arg_blk);
<a name="l02862"></a>02862             <span class="keywordflow">if</span> (ret &amp;&amp; (ret == arg_blk) &amp;&amp; <a class="code" href="a00092.html#a074acb37afea68caaffe3832d326eb44">IS_FULL_BLOCK</a>(dst))
<a name="l02863"></a>02863             {
<a name="l02864"></a>02864                 ret = blockman_.get_allocator().alloc_bit_block();
<a name="l02865"></a>02865 <span class="preprocessor">#ifdef BMVECTOPT</span>
<a name="l02866"></a>02866 <span class="preprocessor"></span>            <a class="code" href="a00098.html#a9b8caa31ab90cbfbc99b5728352e5456">VECT_XOR_ARR_2_MASK</a>(ret, 
<a name="l02867"></a>02867                                 arg_blk, 
<a name="l02868"></a>02868                                 arg_blk + bm::set_block_size, 
<a name="l02869"></a>02869                                 <a class="code" href="a00115.html#ad81dea46a256b93b2af3568ce409d40b">bm::all_bits_mask</a>);
<a name="l02870"></a>02870 <span class="preprocessor">#else</span>
<a name="l02871"></a>02871 <span class="preprocessor"></span>                <a class="code" href="a00115.html#a7176bf7817550ca24cb6612bd8d7957d">bm::wordop_t</a>* dst_ptr = (<a class="code" href="a00115.html#a7176bf7817550ca24cb6612bd8d7957d">wordop_t</a>*)ret;
<a name="l02872"></a>02872                 <span class="keyword">const</span> <a class="code" href="a00115.html#a7176bf7817550ca24cb6612bd8d7957d">bm::wordop_t</a>* wrd_ptr = (<a class="code" href="a00115.html#a7176bf7817550ca24cb6612bd8d7957d">wordop_t</a>*) arg_blk;
<a name="l02873"></a>02873                 <span class="keyword">const</span> <a class="code" href="a00115.html#a7176bf7817550ca24cb6612bd8d7957d">bm::wordop_t</a>* wrd_end = 
<a name="l02874"></a>02874                 (<a class="code" href="a00115.html#a7176bf7817550ca24cb6612bd8d7957d">wordop_t</a>*) (arg_blk + bm::set_block_size);
<a name="l02875"></a>02875 
<a name="l02876"></a>02876                 <span class="keywordflow">do</span>
<a name="l02877"></a>02877                 {
<a name="l02878"></a>02878                     dst_ptr[0] = <a class="code" href="a00115.html#ad81dea46a256b93b2af3568ce409d40b">bm::all_bits_mask</a> ^ wrd_ptr[0];
<a name="l02879"></a>02879                     dst_ptr[1] = <a class="code" href="a00115.html#ad81dea46a256b93b2af3568ce409d40b">bm::all_bits_mask</a> ^ wrd_ptr[1];
<a name="l02880"></a>02880                     dst_ptr[2] = <a class="code" href="a00115.html#ad81dea46a256b93b2af3568ce409d40b">bm::all_bits_mask</a> ^ wrd_ptr[2];
<a name="l02881"></a>02881                     dst_ptr[3] = <a class="code" href="a00115.html#ad81dea46a256b93b2af3568ce409d40b">bm::all_bits_mask</a> ^ wrd_ptr[3];
<a name="l02882"></a>02882 
<a name="l02883"></a>02883                     dst_ptr+=4;
<a name="l02884"></a>02884                     wrd_ptr+=4;
<a name="l02885"></a>02885 
<a name="l02886"></a>02886                 } <span class="keywordflow">while</span> (wrd_ptr &lt; wrd_end);
<a name="l02887"></a>02887 <span class="preprocessor">#endif</span>
<a name="l02888"></a>02888 <span class="preprocessor"></span>                <span class="keywordflow">break</span>;
<a name="l02889"></a>02889             }
<a name="l02890"></a>02890             <span class="keywordflow">goto</span> copy_block;
<a name="l02891"></a>02891         <span class="keywordflow">case</span> <a class="code" href="a00115.html#a42405343976ec931388381cea4092bf1a0c8cf0197857d0bd73a63037e2f2c5c5">BM_OR</a>:
<a name="l02892"></a>02892             ret = <a class="code" href="a00120.html#ga0e945a9eaae699ad40f63b3f0632e6f9" title="Block OR operation. Makes analysis if block is 0 or FULL.">bit_operation_or</a>(dst, arg_blk);
<a name="l02893"></a>02893         copy_block:
<a name="l02894"></a>02894             <span class="keywordflow">if</span> (ret &amp;&amp; (ret == arg_blk) &amp;&amp; !<a class="code" href="a00092.html#a074acb37afea68caaffe3832d326eb44">IS_FULL_BLOCK</a>(ret))
<a name="l02895"></a>02895             {
<a name="l02896"></a>02896             ret = blockman_.get_allocator().alloc_bit_block();
<a name="l02897"></a>02897             <a class="code" href="a00120.html#ga9090de87d53e7f25eff96c8259b3485c" title="Bitblock copy operation.">bit_block_copy</a>(ret, arg_blk);
<a name="l02898"></a>02898             }
<a name="l02899"></a>02899             <span class="keywordflow">break</span>;
<a name="l02900"></a>02900 
<a name="l02901"></a>02901         <span class="keywordflow">case</span> <a class="code" href="a00115.html#a42405343976ec931388381cea4092bf1a1df0f4de7126bb2f7ce69d7a005affb5">BM_SUB</a>:
<a name="l02902"></a>02902             ret = <a class="code" href="a00120.html#gad7afa9bce28a376360ca4826960d669f" title="bitblock SUB operation.">bit_operation_sub</a>(dst, arg_blk);
<a name="l02903"></a>02903             <span class="keywordflow">if</span> (ret &amp;&amp; ret == arg_blk)
<a name="l02904"></a>02904             {
<a name="l02905"></a>02905                 ret = blockman_.get_allocator().alloc_bit_block();
<a name="l02906"></a>02906 <span class="preprocessor">#ifdef BMVECTOPT</span>
<a name="l02907"></a>02907 <span class="preprocessor"></span>                <a class="code" href="a00098.html#a7d425b68d8217dc37d33c660e39a61e1">VECT_ANDNOT_ARR_2_MASK</a>(ret, 
<a name="l02908"></a>02908                                     arg_blk,
<a name="l02909"></a>02909                                     arg_blk + bm::set_block_size,
<a name="l02910"></a>02910                                     <a class="code" href="a00115.html#ad81dea46a256b93b2af3568ce409d40b">bm::all_bits_mask</a>);
<a name="l02911"></a>02911 <span class="preprocessor">#else</span>
<a name="l02912"></a>02912 <span class="preprocessor"></span>
<a name="l02913"></a>02913                 <a class="code" href="a00115.html#a7176bf7817550ca24cb6612bd8d7957d">bm::wordop_t</a>* dst_ptr = (<a class="code" href="a00115.html#a7176bf7817550ca24cb6612bd8d7957d">wordop_t</a>*)ret;
<a name="l02914"></a>02914                 <span class="keyword">const</span> <a class="code" href="a00115.html#a7176bf7817550ca24cb6612bd8d7957d">bm::wordop_t</a>* wrd_ptr = (<a class="code" href="a00115.html#a7176bf7817550ca24cb6612bd8d7957d">wordop_t</a>*) arg_blk;
<a name="l02915"></a>02915                 <span class="keyword">const</span> <a class="code" href="a00115.html#a7176bf7817550ca24cb6612bd8d7957d">bm::wordop_t</a>* wrd_end = 
<a name="l02916"></a>02916                 (<a class="code" href="a00115.html#a7176bf7817550ca24cb6612bd8d7957d">wordop_t</a>*) (arg_blk + bm::set_block_size);
<a name="l02917"></a>02917 
<a name="l02918"></a>02918                 <span class="keywordflow">do</span>
<a name="l02919"></a>02919                 {
<a name="l02920"></a>02920                     dst_ptr[0] = <a class="code" href="a00115.html#ad81dea46a256b93b2af3568ce409d40b">bm::all_bits_mask</a> &amp; ~wrd_ptr[0];
<a name="l02921"></a>02921                     dst_ptr[1] = <a class="code" href="a00115.html#ad81dea46a256b93b2af3568ce409d40b">bm::all_bits_mask</a> &amp; ~wrd_ptr[1];
<a name="l02922"></a>02922                     dst_ptr[2] = <a class="code" href="a00115.html#ad81dea46a256b93b2af3568ce409d40b">bm::all_bits_mask</a> &amp; ~wrd_ptr[2];
<a name="l02923"></a>02923                     dst_ptr[3] = <a class="code" href="a00115.html#ad81dea46a256b93b2af3568ce409d40b">bm::all_bits_mask</a> &amp; ~wrd_ptr[3];
<a name="l02924"></a>02924 
<a name="l02925"></a>02925                     dst_ptr+=4;
<a name="l02926"></a>02926                     wrd_ptr+=4;
<a name="l02927"></a>02927 
<a name="l02928"></a>02928                 } <span class="keywordflow">while</span> (wrd_ptr &lt; wrd_end);
<a name="l02929"></a>02929 <span class="preprocessor">#endif</span>
<a name="l02930"></a>02930 <span class="preprocessor"></span>            }
<a name="l02931"></a>02931             <span class="keywordflow">break</span>;
<a name="l02932"></a>02932         <span class="keywordflow">default</span>:
<a name="l02933"></a>02933             <a class="code" href="a00092.html#aa44515fab0ace8928d1cb82009a95bf8">BM_ASSERT</a>(0);
<a name="l02934"></a>02934             ret = 0;
<a name="l02935"></a>02935         }
<a name="l02936"></a>02936 
<a name="l02937"></a>02937         <span class="keywordflow">if</span> (ret != dst) <span class="comment">// block mutation</span>
<a name="l02938"></a>02938         {
<a name="l02939"></a>02939             blockman_.set_block(nb, ret);
<a name="l02940"></a>02940             blockman_.get_allocator().free_bit_block(dst);
<a name="l02941"></a>02941         }
<a name="l02942"></a>02942 }
<a name="l02943"></a>02943 
<a name="l02944"></a>02944 <span class="comment">//---------------------------------------------------------------------</span>
<a name="l02945"></a>02945 
<a name="l02946"></a>02946 <span class="keyword">template</span>&lt;<span class="keyword">class</span> Alloc&gt; 
<a name="l02947"></a>02947 <span class="keywordtype">void</span> bvector&lt;Alloc&gt;::set_range_no_check(<a class="code" href="a00115.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a> left,
<a name="l02948"></a>02948                                         <a class="code" href="a00115.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a> right,
<a name="l02949"></a>02949                                         <span class="keywordtype">bool</span>     value)
<a name="l02950"></a>02950 {
<a name="l02951"></a>02951     <span class="comment">// calculate logical number of start and destination blocks</span>
<a name="l02952"></a>02952     <span class="keywordtype">unsigned</span> nblock_left  = unsigned(left  &gt;&gt;  <a class="code" href="a00115.html#ad8723fbeea6290d3daa8917ea7ce9bb2">bm::set_block_shift</a>);
<a name="l02953"></a>02953     <span class="keywordtype">unsigned</span> nblock_right = unsigned(right &gt;&gt;  <a class="code" href="a00115.html#ad8723fbeea6290d3daa8917ea7ce9bb2">bm::set_block_shift</a>);
<a name="l02954"></a>02954 
<a name="l02955"></a>02955     <a class="code" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a>* block = blockman_.get_block(nblock_left);
<a name="l02956"></a>02956     <span class="keywordtype">bool</span> left_gap = <a class="code" href="a00092.html#a7bc243edc0a5e82979d6bf63f4debb9a">BM_IS_GAP</a>(block);
<a name="l02957"></a>02957 
<a name="l02958"></a>02958     <span class="keywordtype">unsigned</span> nbit_left  = unsigned(left  &amp; <a class="code" href="a00115.html#a201fb8b1f81b7487f1c1c129fc3d6557">bm::set_block_mask</a>); 
<a name="l02959"></a>02959     <span class="keywordtype">unsigned</span> nbit_right = unsigned(right &amp; <a class="code" href="a00115.html#a201fb8b1f81b7487f1c1c129fc3d6557">bm::set_block_mask</a>); 
<a name="l02960"></a>02960 
<a name="l02961"></a>02961     <span class="keywordtype">unsigned</span> r = 
<a name="l02962"></a>02962         (nblock_left == nblock_right) ? nbit_right :(<a class="code" href="a00115.html#ae9916f69ced0347d94472d7944ea0e45">bm::bits_in_block</a>-1);
<a name="l02963"></a>02963 
<a name="l02964"></a>02964         <a class="code" href="a00115.html#ac654d6319039a86546d235a236fc7cf6">bm::gap_word_t</a> tmp_gap_blk[5] = {0,};
<a name="l02965"></a>02965 
<a name="l02966"></a>02966     <span class="comment">// Set bits in the starting block</span>
<a name="l02967"></a>02967 
<a name="l02968"></a>02968     <span class="keywordtype">unsigned</span> nb;
<a name="l02969"></a>02969     <span class="keywordflow">if</span> ((nbit_left == 0) &amp;&amp; (r == <a class="code" href="a00115.html#ae9916f69ced0347d94472d7944ea0e45">bm::bits_in_block</a> - 1)) <span class="comment">// full block</span>
<a name="l02970"></a>02970     {
<a name="l02971"></a>02971         nb = nblock_left;
<a name="l02972"></a>02972     }
<a name="l02973"></a>02973     <span class="keywordflow">else</span>
<a name="l02974"></a>02974     {
<a name="l02975"></a>02975         gap_init_range_block&lt;gap_word_t&gt;(tmp_gap_blk,
<a name="l02976"></a>02976                                          (<a class="code" href="a00115.html#ac654d6319039a86546d235a236fc7cf6">gap_word_t</a>)nbit_left, 
<a name="l02977"></a>02977                                          (<a class="code" href="a00115.html#ac654d6319039a86546d235a236fc7cf6">gap_word_t</a>)r, 
<a name="l02978"></a>02978                                          (<a class="code" href="a00115.html#ac654d6319039a86546d235a236fc7cf6">gap_word_t</a>)value, 
<a name="l02979"></a>02979                                          <a class="code" href="a00115.html#ae9916f69ced0347d94472d7944ea0e45">bm::bits_in_block</a>);
<a name="l02980"></a>02980 
<a name="l02981"></a>02981         combine_operation_with_block(nblock_left, 
<a name="l02982"></a>02982                                     left_gap, 
<a name="l02983"></a>02983                                     block,
<a name="l02984"></a>02984                                     (<a class="code" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a>*) tmp_gap_blk,
<a name="l02985"></a>02985                                     1,
<a name="l02986"></a>02986                                     value ? <a class="code" href="a00115.html#a42405343976ec931388381cea4092bf1a0c8cf0197857d0bd73a63037e2f2c5c5">BM_OR</a> : <a class="code" href="a00115.html#a42405343976ec931388381cea4092bf1a546fdf33b301e5b9bee0591522ed9250">BM_AND</a>);
<a name="l02987"></a>02987 
<a name="l02988"></a>02988         <span class="keywordflow">if</span> (nblock_left == nblock_right)  <span class="comment">// in one block</span>
<a name="l02989"></a>02989             <span class="keywordflow">return</span>;
<a name="l02990"></a>02990         nb = nblock_left+1;
<a name="l02991"></a>02991     }
<a name="l02992"></a>02992 
<a name="l02993"></a>02993     <span class="comment">// Set (or clear) all full blocks between left and right</span>
<a name="l02994"></a>02994     
<a name="l02995"></a>02995     <span class="keywordtype">unsigned</span> nb_to = nblock_right + (nbit_right ==(<a class="code" href="a00115.html#ae9916f69ced0347d94472d7944ea0e45">bm::bits_in_block</a>-1));
<a name="l02996"></a>02996             
<a name="l02997"></a>02997     <span class="keywordflow">if</span> (value)
<a name="l02998"></a>02998     {
<a name="l02999"></a>02999         <span class="keywordflow">for</span> (; nb &lt; nb_to; ++nb)
<a name="l03000"></a>03000         {
<a name="l03001"></a>03001             block = blockman_.get_block(nb);
<a name="l03002"></a>03002             <span class="keywordflow">if</span> (<a class="code" href="a00092.html#a074acb37afea68caaffe3832d326eb44">IS_FULL_BLOCK</a>(block)) 
<a name="l03003"></a>03003                 <span class="keywordflow">continue</span>;
<a name="l03004"></a>03004 
<a name="l03005"></a>03005             blockman_.set_block(nb, <a class="code" href="a00092.html#a1365569f85f442c4914a3579f55df99b">FULL_BLOCK_ADDR</a>);
<a name="l03006"></a>03006             blockman_.free_block(block);
<a name="l03007"></a>03007         } <span class="comment">// for</span>
<a name="l03008"></a>03008     }
<a name="l03009"></a>03009     <span class="keywordflow">else</span> <span class="comment">// value == 0</span>
<a name="l03010"></a>03010     {
<a name="l03011"></a>03011         <span class="keywordflow">for</span> (; nb &lt; nb_to; ++nb)
<a name="l03012"></a>03012         {
<a name="l03013"></a>03013             block = blockman_.get_block(nb);
<a name="l03014"></a>03014             <span class="keywordflow">if</span> (block == 0)  <span class="comment">// nothing to do</span>
<a name="l03015"></a>03015                 <span class="keywordflow">continue</span>;
<a name="l03016"></a>03016             blockman_.set_block(nb, 0, <span class="keyword">false</span> <span class="comment">/*bit*/</span>);
<a name="l03017"></a>03017             blockman_.free_block(block);
<a name="l03018"></a>03018 
<a name="l03019"></a>03019         } <span class="comment">// for</span>
<a name="l03020"></a>03020     } <span class="comment">// if value else </span>
<a name="l03021"></a>03021 
<a name="l03022"></a>03022     <span class="keywordflow">if</span> (nb_to &gt; nblock_right)
<a name="l03023"></a>03023         <span class="keywordflow">return</span>;
<a name="l03024"></a>03024 
<a name="l03025"></a>03025     block = blockman_.get_block(nblock_right);
<a name="l03026"></a>03026     <span class="keywordtype">bool</span> right_gap = <a class="code" href="a00092.html#a7bc243edc0a5e82979d6bf63f4debb9a">BM_IS_GAP</a>(block);
<a name="l03027"></a>03027 
<a name="l03028"></a>03028     gap_init_range_block&lt;gap_word_t&gt;(tmp_gap_blk, 
<a name="l03029"></a>03029                                      (<a class="code" href="a00115.html#ac654d6319039a86546d235a236fc7cf6">gap_word_t</a>)0, 
<a name="l03030"></a>03030                                      (<a class="code" href="a00115.html#ac654d6319039a86546d235a236fc7cf6">gap_word_t</a>)nbit_right, 
<a name="l03031"></a>03031                                      (<a class="code" href="a00115.html#ac654d6319039a86546d235a236fc7cf6">gap_word_t</a>)value, 
<a name="l03032"></a>03032                                      <a class="code" href="a00115.html#ae9916f69ced0347d94472d7944ea0e45">bm::bits_in_block</a>);
<a name="l03033"></a>03033 
<a name="l03034"></a>03034     combine_operation_with_block(nblock_right, 
<a name="l03035"></a>03035                                     right_gap, 
<a name="l03036"></a>03036                                     block,
<a name="l03037"></a>03037                                     (<a class="code" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a>*) tmp_gap_blk,
<a name="l03038"></a>03038                                     1,
<a name="l03039"></a>03039                                     value ? <a class="code" href="a00115.html#a42405343976ec931388381cea4092bf1a0c8cf0197857d0bd73a63037e2f2c5c5">BM_OR</a> : <a class="code" href="a00115.html#a42405343976ec931388381cea4092bf1a546fdf33b301e5b9bee0591522ed9250">BM_AND</a>);
<a name="l03040"></a>03040 
<a name="l03041"></a>03041 }
<a name="l03042"></a>03042 
<a name="l03043"></a>03043 <span class="comment">//---------------------------------------------------------------------</span>
<a name="l03044"></a>03044 
<a name="l03045"></a>03045 
<a name="l03046"></a>03046 } <span class="comment">// namespace</span>
<a name="l03047"></a>03047 
<a name="l03048"></a>03048 <span class="preprocessor">#include &quot;<a class="code" href="a00101.html">bmundef.h</a>&quot;</span>
<a name="l03049"></a>03049 
<a name="l03050"></a>03050 <span class="preprocessor">#ifdef _MSC_VER</span>
<a name="l03051"></a>03051 <span class="preprocessor"></span><span class="preprocessor">#pragma warning( pop )</span>
<a name="l03052"></a>03052 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l03053"></a>03053 <span class="preprocessor"></span>
<a name="l03054"></a>03054 
<a name="l03055"></a>03055 <span class="preprocessor">#endif</span>
</pre></div></div>
<hr size="1"/><address style="text-align: right;"><small>Generated on Sun Apr 25 09:37:27 2010 for BitMagic by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
