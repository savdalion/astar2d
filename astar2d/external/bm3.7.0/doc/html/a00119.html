<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BitMagic: GAP functions</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>GAP functions<br/>
<small>
[<a class="el" href="a00117.html">BitMagic C++ Library</a>]</small>
</h1>
<p><div class="dynheader">
Collaboration diagram for GAP functions:</div>
<div class="dynsection">
<center><table><tr><td><img src="a00119.png" border="0" alt="" usemap="#a00119_map"/>
<map name="a00119_map" id="a00119">
<area shape="rect" href="a00117.html" title="For more information please visit: http://bmagic.sourceforge.net." alt="" coords="5,5,149,35"/></map></td></tr></table></center>
</div>
</p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Data Structures</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00066.html">bm::gap_len_table&lt; T &gt;</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Default GAP lengths table.  <a href="a00066.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00067.html">bm::gap_len_table_min&lt; T &gt;</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Alternative GAP lengths table. Good for for memory saver mode and very sparse bitsets.  <a href="a00067.html#_details">More...</a><br/></td></tr>
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">unsigned&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00119.html#ga866352ef5986a7d2b709795d127b666b">bm::gap_test</a> (const T *buf, unsigned pos)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Tests if bit = pos is true.  <a href="#ga866352ef5986a7d2b709795d127b666b"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">unsigned&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00119.html#ga570a6f573ffb9ac9e41a688d2bdc6004">bm::gap_bit_count</a> (const T *buf, unsigned dsize=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Calculates number of bits ON in GAP buffer.  <a href="#ga570a6f573ffb9ac9e41a688d2bdc6004"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">int&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00119.html#ga406952734f1b05962941b32e37b3eb96">bm::gapcmp</a> (const T *buf1, const T *buf2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Lexicographical comparison of GAP buffers.  <a href="#ga406952734f1b05962941b32e37b3eb96"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T , class F &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">unsigned&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00119.html#ga5e3123c3c9d3587f470abdbe6c8c3ad3">bm::gap_buff_any_op</a> (const T *BMRESTRICT vect1, unsigned vect1_mask, const T *BMRESTRICT vect2, unsigned vect2_mask, F f)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Abstract distance test operation for GAP buffers. Receives functor F as a template argument.  <a href="#ga5e3123c3c9d3587f470abdbe6c8c3ad3"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T , class F &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">unsigned&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00119.html#ga9a5ff7782f3de0d1c699eb72d432f255">bm::gap_buff_count_op</a> (const T *vect1, const T *vect2, F f)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Abstract distance(similarity) operation for GAP buffers. Receives functor F as a template argument.  <a href="#ga9a5ff7782f3de0d1c699eb72d432f255"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">unsigned&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00119.html#ga69186bd13bda27e04b3e33683ff884c2">bm::gap_set_value</a> (unsigned val, T *BMRESTRICT buf, unsigned pos, unsigned *BMRESTRICT is_set)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets or clears bit in the GAP buffer.  <a href="#ga69186bd13bda27e04b3e33683ff884c2"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">unsigned&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00119.html#gadae4001e2834125b9c08b154a8a874a7">bm::gap_add_value</a> (T *buf, T pos)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add new value to the end of GAP buffer.  <a href="#gadae4001e2834125b9c08b154a8a874a7"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">unsigned&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00119.html#ga550394048c163d41a135fb9068f2251b">bm::gap_set_array</a> (T *buf, const T *arr, unsigned len)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convert array to GAP buffer.  <a href="#ga550394048c163d41a135fb9068f2251b"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">unsigned&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00119.html#ga68e53a96e93a31e8a323d10c7a2f21f5">bm::bit_array_compute_gaps</a> (const T *arr, unsigned len)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute number of GAPs in bit-array.  <a href="#ga68e53a96e93a31e8a323d10c7a2f21f5"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">int&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00119.html#gaa7df7193094353ea24b8519debf745be">bm::gap_find_in_block</a> (const T *buf, unsigned nbit, <a class="el" href="a00115.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a> *prev)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Searches for the next 1 bit in the GAP block.  <a href="#gaa7df7193094353ea24b8519debf745be"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00119.html#gabcedad4aea1a503c30f10e6d09b523f2">bm::gap_sub_to_bitset</a> (unsigned *BMRESTRICT dest, const T *BMRESTRICT buf)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">SUB (AND NOT) GAP block to bitblock.  <a href="#gabcedad4aea1a503c30f10e6d09b523f2"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00119.html#ga63c33428c2f5eac9f69d663203cd2172">bm::gap_xor_to_bitset</a> (unsigned *BMRESTRICT dest, const T *BMRESTRICT buf)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">XOR GAP block to bitblock.  <a href="#ga63c33428c2f5eac9f69d663203cd2172"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00119.html#ga78510a39b6e8c6b8904ecbffb6ab215b">bm::gap_add_to_bitset_l</a> (unsigned *dest, const T *buf, unsigned buf_len)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds(OR) GAP block to bitblock.  <a href="#ga78510a39b6e8c6b8904ecbffb6ab215b"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00119.html#ga12615cd62f2e5367e1bc688d00a2188f">bm::gap_add_to_bitset</a> (unsigned *dest, const T *buf)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds(OR) GAP block to bitblock.  <a href="#ga12615cd62f2e5367e1bc688d00a2188f"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00119.html#gafe6f72a009618290eeab3cddee869543">bm::gap_and_to_bitset</a> (unsigned *dest, const T *buf)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">ANDs GAP block to bitblock.  <a href="#gafe6f72a009618290eeab3cddee869543"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00119.html#ga4862f4dcdcb7c0575e2e2db9e5f2a849">bm::gap_convert_to_bitset</a> (unsigned *dest, const T *buf)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">GAP block to bitblock conversion.  <a href="#ga4862f4dcdcb7c0575e2e2db9e5f2a849"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00119.html#ga1dd58e3576239c49010b62a3add42417">bm::gap_convert_to_bitset_l</a> (unsigned *dest, const T *buf, unsigned buf_len)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">GAP block to bitblock conversion.  <a href="#ga1dd58e3576239c49010b62a3add42417"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00119.html#ga9bb80c42ee0ecf8f2af8250d7f5d327b">bm::gap_convert_to_bitset</a> (unsigned *dest, const T *buf, unsigned dest_len)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">GAP block to bitblock conversion.  <a href="#ga9bb80c42ee0ecf8f2af8250d7f5d327b"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">unsigned *&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00119.html#ga3f01bb7c1ae7983aa8c4ba82e1e3f54c">bm::gap_convert_to_bitset_smart</a> (unsigned *dest, const T *buf, id_t set_max)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Smart GAP block to bitblock conversion.  <a href="#ga3f01bb7c1ae7983aa8c4ba82e1e3f54c"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">unsigned&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00119.html#ga14d29338ffd1387758810b3f9e3a72c6">bm::gap_control_sum</a> (const T *buf)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Calculates sum of all words in GAP block. (For debugging purposes).  <a href="#ga14d29338ffd1387758810b3f9e3a72c6"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00119.html#gaef53b2877ff369badd7bb25b26bb9029">bm::gap_set_all</a> (T *buf, unsigned set_max, unsigned value)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets all bits to 0 or 1 (GAP).  <a href="#gaef53b2877ff369badd7bb25b26bb9029"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00119.html#ga510ab7feb60c19f7d7811cc304fdf649">bm::gap_init_range_block</a> (T *buf, T from, T to, T value, unsigned set_max)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Init gap block so it has block in it (can be whole block).  <a href="#ga510ab7feb60c19f7d7811cc304fdf649"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00119.html#ga3f22bfde5dfe06d6d77dc2598b8c0845">bm::gap_invert</a> (T *buf)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Inverts all bits in the GAP buffer.  <a href="#ga3f22bfde5dfe06d6d77dc2598b8c0845"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00119.html#ga690ff7c8b16e1821a77663b7194267e7">bm::gap_is_all_zero</a> (const T *buf, unsigned set_max)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Temporary inverts all bits in the GAP buffer.  <a href="#ga690ff7c8b16e1821a77663b7194267e7"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00119.html#ga1427d43e91872f981c6311fa76ab5633">bm::gap_is_all_one</a> (const T *buf, unsigned set_max)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Checks if GAP block is all-one.  <a href="#ga1427d43e91872f981c6311fa76ab5633"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">T&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00119.html#ga02541ec6c2930c292eda4313b78e874c">bm::gap_length</a> (const T *buf)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returs GAP block length.  <a href="#ga02541ec6c2930c292eda4313b78e874c"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">unsigned&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00119.html#ga0419ed06e2f0b7891e7d721546f5fb45">bm::gap_capacity</a> (const T *buf, const T *glevel_len)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returs GAP block capacity.  <a href="#ga0419ed06e2f0b7891e7d721546f5fb45"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">unsigned&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00119.html#ga94a5371b5dc6a1560d95d7c2dde88815">bm::gap_limit</a> (const T *buf, const T *glevel_len)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returs GAP block capacity limit.  <a href="#ga94a5371b5dc6a1560d95d7c2dde88815"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">unsigned&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00119.html#ga1defe73aa4227a0e7204363ac6bb1ac1">bm::gap_level</a> (const T *buf)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returs GAP blocks capacity level.  <a href="#ga1defe73aa4227a0e7204363ac6bb1ac1"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00119.html#ga501aa9bf029e7f9ea9518e7003fe5549">bm::set_gap_level</a> (T *buf, unsigned level)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets GAP block capacity level.  <a href="#ga501aa9bf029e7f9ea9518e7003fe5549"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">int&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00119.html#ga3bfaebeeb4b2d479c5a9ac9d57607165">bm::gap_calc_level</a> (int len, const T *glevel_len)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Calculates GAP block capacity level.  <a href="#ga3bfaebeeb4b2d479c5a9ac9d57607165"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">unsigned&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00119.html#gafd76869eb44fac688da5e26e0e74f41f">bm::gap_free_elements</a> (const T *buf, const T *glevel_len)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns number of free elements in GAP block array. Difference between GAP block capacity on this level and actual GAP length.  <a href="#gafd76869eb44fac688da5e26e0e74f41f"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">unsigned&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00119.html#ga80d09bb6ab244e68ab0c1fdccc17b95b">bm::bit_convert_to_gap</a> (T *BMRESTRICT dest, const unsigned *BMRESTRICT src, <a class="el" href="a00115.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a> bits, unsigned dest_len)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Converts bit block to GAP.  <a href="#ga80d09bb6ab244e68ab0c1fdccc17b95b"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T , class F &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00119.html#ga11bc26da8533752bb23756632fd30a00">bm::for_each_gap_dbit</a> (const T *buf, F &amp;func)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Iterate gap block as delta-bits with a functor.  <a href="#ga11bc26da8533752bb23756632fd30a00"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename D , typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">D&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00119.html#ga5cd7e0cfee401da1b8f702151c083b27">bm::gap_convert_to_arr</a> (D *BMRESTRICT dest, const T *BMRESTRICT buf, unsigned dest_len, bool invert=false)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convert gap block into array of ints corresponding to 1 bits.  <a href="#ga5cd7e0cfee401da1b8f702151c083b27"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">BMFORCEINLINE gap_word_t *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00119.html#gac18d7da0492983802511999a4ad0764a">bm::gap_operation_and</a> (const gap_word_t *BMRESTRICT vect1, const gap_word_t *BMRESTRICT vect2, gap_word_t *BMRESTRICT tmp_buf, unsigned &amp;dsize)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">GAP AND operation.  <a href="#gac18d7da0492983802511999a4ad0764a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">BMFORCEINLINE unsigned&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00119.html#ga58e0312d3ab0551e883176b170c0a3e8">bm::gap_operation_any_and</a> (const gap_word_t *BMRESTRICT vect1, const gap_word_t *BMRESTRICT vect2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">GAP AND operation test.  <a href="#ga58e0312d3ab0551e883176b170c0a3e8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">BMFORCEINLINE unsigned&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00119.html#gafd92d013b0c377604831f401ef6917b8">bm::gap_count_and</a> (const gap_word_t *BMRESTRICT vect1, const gap_word_t *BMRESTRICT vect2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">GAP bitcount AND operation test.  <a href="#gafd92d013b0c377604831f401ef6917b8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">BMFORCEINLINE gap_word_t *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00119.html#ga72d2d3933b4410413eeb02e9ee0a910d">bm::gap_operation_xor</a> (const gap_word_t *BMRESTRICT vect1, const gap_word_t *BMRESTRICT vect2, gap_word_t *BMRESTRICT tmp_buf, unsigned &amp;dsize)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">GAP XOR operation.  <a href="#ga72d2d3933b4410413eeb02e9ee0a910d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">BMFORCEINLINE unsigned&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00119.html#gab8800dff60eb05404a83159035e8e72f">bm::gap_operation_any_xor</a> (const gap_word_t *BMRESTRICT vect1, const gap_word_t *BMRESTRICT vect2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">GAP XOR operation test.  <a href="#gab8800dff60eb05404a83159035e8e72f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">BMFORCEINLINE unsigned&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00119.html#gae38d6a3296f0562be512f47b4edfb1ad">bm::gap_count_xor</a> (const gap_word_t *BMRESTRICT vect1, const gap_word_t *BMRESTRICT vect2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">GAP bitcount XOR operation test.  <a href="#gae38d6a3296f0562be512f47b4edfb1ad"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">gap_word_t *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00119.html#gacda280af8910ae5fde37731a3a7a1226">bm::gap_operation_or</a> (const gap_word_t *BMRESTRICT vect1, const gap_word_t *BMRESTRICT vect2, gap_word_t *BMRESTRICT tmp_buf, unsigned &amp;dsize)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">GAP OR operation.  <a href="#gacda280af8910ae5fde37731a3a7a1226"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">BMFORCEINLINE unsigned&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00119.html#ga125fc8dc68245a11a171e7793c6588a2">bm::gap_count_or</a> (const gap_word_t *BMRESTRICT vect1, const gap_word_t *BMRESTRICT vect2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">GAP bitcount OR operation test.  <a href="#ga125fc8dc68245a11a171e7793c6588a2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">gap_word_t *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00119.html#gabe4c83e5e162c38e297116dd1cd05ac4">bm::gap_operation_sub</a> (const gap_word_t *BMRESTRICT vect1, const gap_word_t *BMRESTRICT vect2, gap_word_t *BMRESTRICT tmp_buf, unsigned &amp;dsize)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">GAP SUB (AND NOT) operation.  <a href="#gabe4c83e5e162c38e297116dd1cd05ac4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">BMFORCEINLINE unsigned&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00119.html#ga1c9b33d00f74206ad655dc2cef52428b">bm::gap_operation_any_sub</a> (const gap_word_t *BMRESTRICT vect1, const gap_word_t *BMRESTRICT vect2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">GAP SUB operation test.  <a href="#ga1c9b33d00f74206ad655dc2cef52428b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">BMFORCEINLINE unsigned&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00119.html#gacacf55c60da82a1c384f3ac3a51229d4">bm::gap_count_sub</a> (const gap_word_t *BMRESTRICT vect1, const gap_word_t *BMRESTRICT vect2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">GAP bitcount SUB (AND NOT) operation test.  <a href="#gacacf55c60da82a1c384f3ac3a51229d4"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">unsigned&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00119.html#gacc578010f3700940829c600c812d23b1">bm::gap_overhead</a> (const T *length, const T *length_end, const T *glevel_len)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convert bit block into an array of ints corresponding to 1 bits.  <a href="#gacc578010f3700940829c600c812d23b1"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00119.html#ga2daff3a0ceda6fef87d3b0e892da5813">bm::improve_gap_levels</a> (const T *length, const T *length_end, T *glevel_len)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Finds optimal gap blocks lengths.  <a href="#ga2daff3a0ceda6fef87d3b0e892da5813"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>GAP functions implement different opereations on GAP compressed blocks and serve as a minimal building blocks. </p>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="ga68e53a96e93a31e8a323d10c7a2f21f5"></a><!-- doxytag: member="bm::bit_array_compute_gaps" ref="ga68e53a96e93a31e8a323d10c7a2f21f5" args="(const T *arr, unsigned len)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned bm::bit_array_compute_gaps </td>
          <td>(</td>
          <td class="paramtype">const T *&nbsp;</td>
          <td class="paramname"> <em>arr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>len</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute number of GAPs in bit-array. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>arr</em>&nbsp;</td><td>- array of BITs </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>len</em>&nbsp;</td><td>- array length </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="a00093_source.html#l01406">1406</a> of file <a class="el" href="a00093_source.html">bmfunc.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga80d09bb6ab244e68ab0c1fdccc17b95b"></a><!-- doxytag: member="bm::bit_convert_to_gap" ref="ga80d09bb6ab244e68ab0c1fdccc17b95b" args="(T *BMRESTRICT dest, const unsigned *BMRESTRICT src, bm::id_t bits, unsigned dest_len)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned bm::bit_convert_to_gap </td>
          <td>(</td>
          <td class="paramtype">T *BMRESTRICT&nbsp;</td>
          <td class="paramname"> <em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned *BMRESTRICT&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00115.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a>&nbsp;</td>
          <td class="paramname"> <em>bits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>dest_len</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Converts bit block to GAP. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dest</em>&nbsp;</td><td>- Destinatio GAP buffer. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>src</em>&nbsp;</td><td>- Source bitblock buffer. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bits</em>&nbsp;</td><td>- Number of bits to convert. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dest_len</em>&nbsp;</td><td>- length of the dest. buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>New length of GAP block or 0 if conversion failed (insufficicent space). </dd></dl>

<p>Definition at line <a class="el" href="a00093_source.html#l02522">2522</a> of file <a class="el" href="a00093_source.html">bmfunc.h</a>.</p>

<p>References <a class="el" href="a00092_source.html#l00050">BM_ASSERT</a>.</p>

<p>Referenced by <a class="el" href="a00096_source.html#l00814">bm::serializer&lt; BV &gt;::serialize()</a>.</p>

</div>
</div>
<a class="anchor" id="ga11bc26da8533752bb23756632fd30a00"></a><!-- doxytag: member="bm::for_each_gap_dbit" ref="ga11bc26da8533752bb23756632fd30a00" args="(const T *buf, F &amp;func)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class F &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void bm::for_each_gap_dbit </td>
          <td>(</td>
          <td class="paramtype">const T *&nbsp;</td>
          <td class="paramname"> <em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F &amp;&nbsp;</td>
          <td class="paramname"> <em>func</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Iterate gap block as delta-bits with a functor. </p>

<p>Definition at line <a class="el" href="a00093_source.html#l02612">2612</a> of file <a class="el" href="a00093_source.html">bmfunc.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga12615cd62f2e5367e1bc688d00a2188f"></a><!-- doxytag: member="bm::gap_add_to_bitset" ref="ga12615cd62f2e5367e1bc688d00a2188f" args="(unsigned *dest, const T *buf)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void bm::gap_add_to_bitset </td>
          <td>(</td>
          <td class="paramtype">unsigned *&nbsp;</td>
          <td class="paramname"> <em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&nbsp;</td>
          <td class="paramname"> <em>buf</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Adds(OR) GAP block to bitblock. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dest</em>&nbsp;</td><td>- bitblock buffer pointer. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>buf</em>&nbsp;</td><td>- GAP buffer pointer. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="a00093_source.html#l01763">1763</a> of file <a class="el" href="a00093_source.html">bmfunc.h</a>.</p>

<p>References <a class="el" href="a00093_source.html#l01733">bm::gap_add_to_bitset_l()</a>.</p>

<p>Referenced by <a class="el" href="a00096_source.html#l01316">bm::deserializer&lt; BV, DEC &gt;::deserialize_gap()</a>, and <a class="el" href="a00093_source.html#l02144">bm::gap_convert_to_bitset()</a>.</p>

</div>
</div>
<a class="anchor" id="ga78510a39b6e8c6b8904ecbffb6ab215b"></a><!-- doxytag: member="bm::gap_add_to_bitset_l" ref="ga78510a39b6e8c6b8904ecbffb6ab215b" args="(unsigned *dest, const T *buf, unsigned buf_len)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void bm::gap_add_to_bitset_l </td>
          <td>(</td>
          <td class="paramtype">unsigned *&nbsp;</td>
          <td class="paramname"> <em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&nbsp;</td>
          <td class="paramname"> <em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>buf_len</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Adds(OR) GAP block to bitblock. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dest</em>&nbsp;</td><td>- bitblock buffer pointer. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>buf</em>&nbsp;</td><td>- GAP buffer pointer. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>buf_len</em>&nbsp;</td><td>- GAP buffer length </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="a00093_source.html#l01733">1733</a> of file <a class="el" href="a00093_source.html">bmfunc.h</a>.</p>

<p>References <a class="el" href="a00092_source.html#l00050">BM_ASSERT</a>, and <a class="el" href="a00093_source.html#l01491">bm::or_bit_block()</a>.</p>

<p>Referenced by <a class="el" href="a00096_source.html#l01316">bm::deserializer&lt; BV, DEC &gt;::deserialize_gap()</a>, <a class="el" href="a00093_source.html#l01763">bm::gap_add_to_bitset()</a>, and <a class="el" href="a00093_source.html#l02158">bm::gap_convert_to_bitset_l()</a>.</p>

</div>
</div>
<a class="anchor" id="gadae4001e2834125b9c08b154a8a874a7"></a><!-- doxytag: member="bm::gap_add_value" ref="gadae4001e2834125b9c08b154a8a874a7" args="(T *buf, T pos)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned bm::gap_add_value </td>
          <td>(</td>
          <td class="paramtype">T *&nbsp;</td>
          <td class="paramname"> <em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&nbsp;</td>
          <td class="paramname"> <em>pos</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Add new value to the end of GAP buffer. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buf</em>&nbsp;</td><td>- GAP buffer. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pos</em>&nbsp;</td><td>- Index of bit to set.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>New GAP buffer length. </dd></dl>

<p>Definition at line <a class="el" href="a00093_source.html#l01261">1261</a> of file <a class="el" href="a00093_source.html">bmfunc.h</a>.</p>

<p>References <a class="el" href="a00092_source.html#l00050">BM_ASSERT</a>, and <a class="el" href="a00091_source.html#l00072">bm::gap_max_bits</a>.</p>

<p>Referenced by <a class="el" href="a00096_source.html#l01227">bm::deseriaizer_base&lt; DEC &gt;::read_gap_block()</a>.</p>

</div>
</div>
<a class="anchor" id="gafe6f72a009618290eeab3cddee869543"></a><!-- doxytag: member="bm::gap_and_to_bitset" ref="gafe6f72a009618290eeab3cddee869543" args="(unsigned *dest, const T *buf)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void bm::gap_and_to_bitset </td>
          <td>(</td>
          <td class="paramtype">unsigned *&nbsp;</td>
          <td class="paramname"> <em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&nbsp;</td>
          <td class="paramname"> <em>buf</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>ANDs GAP block to bitblock. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dest</em>&nbsp;</td><td>- bitblock buffer pointer. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>buf</em>&nbsp;</td><td>- GAP buffer pointer. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="a00093_source.html#l01777">1777</a> of file <a class="el" href="a00093_source.html">bmfunc.h</a>.</p>

<p>References <a class="el" href="a00092_source.html#l00050">BM_ASSERT</a>, and <a class="el" href="a00093_source.html#l01553">bm::sub_bit_block()</a>.</p>

</div>
</div>
<a class="anchor" id="ga570a6f573ffb9ac9e41a688d2bdc6004"></a><!-- doxytag: member="bm::gap_bit_count" ref="ga570a6f573ffb9ac9e41a688d2bdc6004" args="(const T *buf, unsigned dsize=0)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned bm::gap_bit_count </td>
          <td>(</td>
          <td class="paramtype">const T *&nbsp;</td>
          <td class="paramname"> <em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>dsize</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calculates number of bits ON in GAP buffer. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buf</em>&nbsp;</td><td>- GAP buffer pointer. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dsize</em>&nbsp;</td><td>- buffer size </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Number of non-zero bits. </dd></dl>

<p>Definition at line <a class="el" href="a00093_source.html#l00678">678</a> of file <a class="el" href="a00093_source.html">bmfunc.h</a>.</p>

<p>Referenced by <a class="el" href="a00089_source.html#l00116">bm::combine_count_operation_with_block()</a>, and <a class="el" href="a00096_source.html#l00709">bm::serializer&lt; BV &gt;::encode_gap_block()</a>.</p>

</div>
</div>
<a class="anchor" id="ga5e3123c3c9d3587f470abdbe6c8c3ad3"></a><!-- doxytag: member="bm::gap_buff_any_op" ref="ga5e3123c3c9d3587f470abdbe6c8c3ad3" args="(const T *BMRESTRICT vect1, unsigned vect1_mask, const T *BMRESTRICT vect2, unsigned vect2_mask, F f)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , class F &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned bm::gap_buff_any_op </td>
          <td>(</td>
          <td class="paramtype">const T *BMRESTRICT&nbsp;</td>
          <td class="paramname"> <em>vect1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>vect1_mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *BMRESTRICT&nbsp;</td>
          <td class="paramname"> <em>vect2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>vect2_mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F&nbsp;</td>
          <td class="paramname"> <em>f</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Abstract distance test operation for GAP buffers. Receives functor F as a template argument. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>vect1</em>&nbsp;</td><td>- operand 1 GAP encoded buffer. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>vect1_mask</em>&nbsp;</td><td>- XOR mask for starting bitflag for vector1 can be 0 or 1 (1 inverts the vector) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>vect2</em>&nbsp;</td><td>- operand 2 GAP encoded buffer. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>vect2_mask</em>&nbsp;</td><td>- same as vect1_mask </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>f</em>&nbsp;</td><td>- operation functor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="note"><dt><b>Note:</b></dt><dd>Internal function. </dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>non zero value if operation result returns any 1 bit </dd></dl>

<p>Definition at line <a class="el" href="a00093_source.html#l01015">1015</a> of file <a class="el" href="a00093_source.html">bmfunc.h</a>.</p>

<p>References <a class="el" href="a00091_source.html#l00072">bm::gap_max_bits</a>.</p>

<p>Referenced by <a class="el" href="a00093_source.html#l03210">bm::gap_operation_any_and()</a>, <a class="el" href="a00093_source.html#l03388">bm::gap_operation_any_sub()</a>, and <a class="el" href="a00093_source.html#l03277">bm::gap_operation_any_xor()</a>.</p>

</div>
</div>
<a class="anchor" id="ga9a5ff7782f3de0d1c699eb72d432f255"></a><!-- doxytag: member="bm::gap_buff_count_op" ref="ga9a5ff7782f3de0d1c699eb72d432f255" args="(const T *vect1, const T *vect2, F f)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , class F &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned bm::gap_buff_count_op </td>
          <td>(</td>
          <td class="paramtype">const T *&nbsp;</td>
          <td class="paramname"> <em>vect1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&nbsp;</td>
          <td class="paramname"> <em>vect2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F&nbsp;</td>
          <td class="paramname"> <em>f</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Abstract distance(similarity) operation for GAP buffers. Receives functor F as a template argument. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>vect1</em>&nbsp;</td><td>- operand 1 GAP encoded buffer. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>vect2</em>&nbsp;</td><td>- operand 2 GAP encoded buffer. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>f</em>&nbsp;</td><td>- operation functor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="note"><dt><b>Note:</b></dt><dd>Internal function. </dd></dl>

<p>Definition at line <a class="el" href="a00093_source.html#l01084">1084</a> of file <a class="el" href="a00093_source.html">bmfunc.h</a>.</p>

<p>References <a class="el" href="a00091_source.html#l00072">bm::gap_max_bits</a>.</p>

<p>Referenced by <a class="el" href="a00093_source.html#l03227">bm::gap_count_and()</a>, <a class="el" href="a00093_source.html#l03338">bm::gap_count_or()</a>, <a class="el" href="a00093_source.html#l03405">bm::gap_count_sub()</a>, and <a class="el" href="a00093_source.html#l03293">bm::gap_count_xor()</a>.</p>

</div>
</div>
<a class="anchor" id="ga3bfaebeeb4b2d479c5a9ac9d57607165"></a><!-- doxytag: member="bm::gap_calc_level" ref="ga3bfaebeeb4b2d479c5a9ac9d57607165" args="(int len, const T *glevel_len)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int bm::gap_calc_level </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&nbsp;</td>
          <td class="paramname"> <em>glevel_len</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calculates GAP block capacity level. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>len</em>&nbsp;</td><td>- GAP buffer length. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>glevel_len</em>&nbsp;</td><td>- GAP lengths table </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>GAP block capacity level. -1 if block does not fit any level. </dd></dl>

<p>Definition at line <a class="el" href="a00093_source.html#l02450">2450</a> of file <a class="el" href="a00093_source.html">bmfunc.h</a>.</p>

<p>References <a class="el" href="a00092_source.html#l00050">BM_ASSERT</a>, and <a class="el" href="a00091_source.html#l00075">bm::gap_levels</a>.</p>

<p>Referenced by <a class="el" href="a00096_source.html#l03101">bm::iterator_deserializer&lt; BV, SerialIterator &gt;::deserialize()</a>, <a class="el" href="a00096_source.html#l01316">bm::deserializer&lt; BV, DEC &gt;::deserialize_gap()</a>, and <a class="el" href="a00093_source.html#l04847">bm::gap_overhead()</a>.</p>

</div>
</div>
<a class="anchor" id="ga0419ed06e2f0b7891e7d721546f5fb45"></a><!-- doxytag: member="bm::gap_capacity" ref="ga0419ed06e2f0b7891e7d721546f5fb45" args="(const T *buf, const T *glevel_len)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned bm::gap_capacity </td>
          <td>(</td>
          <td class="paramtype">const T *&nbsp;</td>
          <td class="paramname"> <em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&nbsp;</td>
          <td class="paramname"> <em>glevel_len</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returs GAP block capacity. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buf</em>&nbsp;</td><td>- GAP buffer pointer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>GAP block capacity. </dd></dl>

<p>Definition at line <a class="el" href="a00093_source.html#l02392">2392</a> of file <a class="el" href="a00093_source.html">bmfunc.h</a>.</p>

<p>Referenced by <a class="el" href="a00087_source.html#l02044">bm::bvector&lt; Alloc &gt;::calc_stat()</a>, <a class="el" href="a00090_source.html#l00205">bm::mem_alloc&lt; BA, PA &gt;::free_gap_block()</a>, and <a class="el" href="a00093_source.html#l02471">bm::gap_free_elements()</a>.</p>

</div>
</div>
<a class="anchor" id="ga14d29338ffd1387758810b3f9e3a72c6"></a><!-- doxytag: member="bm::gap_control_sum" ref="ga14d29338ffd1387758810b3f9e3a72c6" args="(const T *buf)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned bm::gap_control_sum </td>
          <td>(</td>
          <td class="paramtype">const T *&nbsp;</td>
          <td class="paramname"> <em>buf</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calculates sum of all words in GAP block. (For debugging purposes). </p>
<dl class="note"><dt><b>Note:</b></dt><dd>For debugging and testing ONLY. </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buf</em>&nbsp;</td><td>- GAP buffer pointer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Sum of all words. </dd></dl>

<p>Definition at line <a class="el" href="a00093_source.html#l02218">2218</a> of file <a class="el" href="a00093_source.html">bmfunc.h</a>.</p>

<p>References <a class="el" href="a00092_source.html#l00050">BM_ASSERT</a>.</p>

</div>
</div>
<a class="anchor" id="ga5cd7e0cfee401da1b8f702151c083b27"></a><!-- doxytag: member="bm::gap_convert_to_arr" ref="ga5cd7e0cfee401da1b8f702151c083b27" args="(D *BMRESTRICT dest, const T *BMRESTRICT buf, unsigned dest_len, bool invert=false)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename D , typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">D bm::gap_convert_to_arr </td>
          <td>(</td>
          <td class="paramtype">D *BMRESTRICT&nbsp;</td>
          <td class="paramname"> <em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *BMRESTRICT&nbsp;</td>
          <td class="paramname"> <em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>dest_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>invert</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convert gap block into array of ints corresponding to 1 bits. </p>

<p>Definition at line <a class="el" href="a00093_source.html#l02667">2667</a> of file <a class="el" href="a00093_source.html">bmfunc.h</a>.</p>

<p>Referenced by <a class="el" href="a00096_source.html#l00709">bm::serializer&lt; BV &gt;::encode_gap_block()</a>.</p>

</div>
</div>
<a class="anchor" id="ga9bb80c42ee0ecf8f2af8250d7f5d327b"></a><!-- doxytag: member="bm::gap_convert_to_bitset" ref="ga9bb80c42ee0ecf8f2af8250d7f5d327b" args="(unsigned *dest, const T *buf, unsigned dest_len)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void bm::gap_convert_to_bitset </td>
          <td>(</td>
          <td class="paramtype">unsigned *&nbsp;</td>
          <td class="paramname"> <em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&nbsp;</td>
          <td class="paramname"> <em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>dest_len</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>GAP block to bitblock conversion. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dest</em>&nbsp;</td><td>- bitblock buffer pointer. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>buf</em>&nbsp;</td><td>- GAP buffer pointer. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dest_size</em>&nbsp;</td><td>- length of the destination buffer. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="a00093_source.html#l02175">2175</a> of file <a class="el" href="a00093_source.html">bmfunc.h</a>.</p>

<p>References <a class="el" href="a00093_source.html#l01763">bm::gap_add_to_bitset()</a>.</p>

</div>
</div>
<a class="anchor" id="ga4862f4dcdcb7c0575e2e2db9e5f2a849"></a><!-- doxytag: member="bm::gap_convert_to_bitset" ref="ga4862f4dcdcb7c0575e2e2db9e5f2a849" args="(unsigned *dest, const T *buf)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void bm::gap_convert_to_bitset </td>
          <td>(</td>
          <td class="paramtype">unsigned *&nbsp;</td>
          <td class="paramname"> <em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&nbsp;</td>
          <td class="paramname"> <em>buf</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>GAP block to bitblock conversion. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dest</em>&nbsp;</td><td>- bitblock buffer pointer. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>buf</em>&nbsp;</td><td>- GAP buffer pointer. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="a00093_source.html#l02144">2144</a> of file <a class="el" href="a00093_source.html">bmfunc.h</a>.</p>

<p>References <a class="el" href="a00093_source.html#l02126">bm::bit_block_set()</a>, and <a class="el" href="a00093_source.html#l01763">bm::gap_add_to_bitset()</a>.</p>

<p>Referenced by <a class="el" href="a00089_source.html#l00366">bm::combine_any_operation_with_block()</a>, <a class="el" href="a00089_source.html#l00116">bm::combine_count_operation_with_block()</a>, <a class="el" href="a00087_source.html#l01914">bm::bvector&lt; Alloc &gt;::compare()</a>, <a class="el" href="a00096_source.html#l03319">bm::iterator_deserializer&lt; BV, SerialIterator &gt;::deserialize()</a>, <a class="el" href="a00096_source.html#l01316">bm::deserializer&lt; BV, DEC &gt;::deserialize_gap()</a>, and <a class="el" href="a00093_source.html#l02196">bm::gap_convert_to_bitset_smart()</a>.</p>

</div>
</div>
<a class="anchor" id="ga1dd58e3576239c49010b62a3add42417"></a><!-- doxytag: member="bm::gap_convert_to_bitset_l" ref="ga1dd58e3576239c49010b62a3add42417" args="(unsigned *dest, const T *buf, unsigned buf_len)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void bm::gap_convert_to_bitset_l </td>
          <td>(</td>
          <td class="paramtype">unsigned *&nbsp;</td>
          <td class="paramname"> <em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&nbsp;</td>
          <td class="paramname"> <em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>buf_len</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>GAP block to bitblock conversion. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dest</em>&nbsp;</td><td>- bitblock buffer pointer. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>buf</em>&nbsp;</td><td>- GAP buffer pointer. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="a00093_source.html#l02158">2158</a> of file <a class="el" href="a00093_source.html">bmfunc.h</a>.</p>

<p>References <a class="el" href="a00093_source.html#l02126">bm::bit_block_set()</a>, and <a class="el" href="a00093_source.html#l01733">bm::gap_add_to_bitset_l()</a>.</p>

</div>
</div>
<a class="anchor" id="ga3f01bb7c1ae7983aa8c4ba82e1e3f54c"></a><!-- doxytag: member="bm::gap_convert_to_bitset_smart" ref="ga3f01bb7c1ae7983aa8c4ba82e1e3f54c" args="(unsigned *dest, const T *buf, id_t set_max)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned* bm::gap_convert_to_bitset_smart </td>
          <td>(</td>
          <td class="paramtype">unsigned *&nbsp;</td>
          <td class="paramname"> <em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&nbsp;</td>
          <td class="paramname"> <em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">id_t&nbsp;</td>
          <td class="paramname"> <em>set_max</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Smart GAP block to bitblock conversion. </p>
<p>Checks if GAP block is ALL-ZERO or ALL-ON. In those cases returns pointer on special static bitblocks.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dest</em>&nbsp;</td><td>- bitblock buffer pointer. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>buf</em>&nbsp;</td><td>- GAP buffer pointer. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>set_max</em>&nbsp;</td><td>- max possible bitset length </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="a00093_source.html#l02196">2196</a> of file <a class="el" href="a00093_source.html">bmfunc.h</a>.</p>

<p>References <a class="el" href="a00092_source.html#l00060">FULL_BLOCK_ADDR</a>, and <a class="el" href="a00093_source.html#l02144">bm::gap_convert_to_bitset()</a>.</p>

</div>
</div>
<a class="anchor" id="gafd92d013b0c377604831f401ef6917b8"></a><!-- doxytag: member="bm::gap_count_and" ref="gafd92d013b0c377604831f401ef6917b8" args="(const gap_word_t *BMRESTRICT vect1, const gap_word_t *BMRESTRICT vect2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BMFORCEINLINE unsigned bm::gap_count_and </td>
          <td>(</td>
          <td class="paramtype">const gap_word_t *BMRESTRICT&nbsp;</td>
          <td class="paramname"> <em>vect1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const gap_word_t *BMRESTRICT&nbsp;</td>
          <td class="paramname"> <em>vect2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>GAP bitcount AND operation test. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>vect1</em>&nbsp;</td><td>- operand 1 </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>vect2</em>&nbsp;</td><td>- operand 2 </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>bitcount of vect1 AND vect2 </dd></dl>

<p>Definition at line <a class="el" href="a00093_source.html#l03227">3227</a> of file <a class="el" href="a00093_source.html">bmfunc.h</a>.</p>

<p>References <a class="el" href="a00093_source.html#l03143">bm::and_op()</a>, and <a class="el" href="a00093_source.html#l01084">bm::gap_buff_count_op()</a>.</p>

<p>Referenced by <a class="el" href="a00089_source.html#l00329">bm::combine_count_and_operation_with_block()</a>, and <a class="el" href="a00089_source.html#l00116">bm::combine_count_operation_with_block()</a>.</p>

</div>
</div>
<a class="anchor" id="ga125fc8dc68245a11a171e7793c6588a2"></a><!-- doxytag: member="bm::gap_count_or" ref="ga125fc8dc68245a11a171e7793c6588a2" args="(const gap_word_t *BMRESTRICT vect1, const gap_word_t *BMRESTRICT vect2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BMFORCEINLINE unsigned bm::gap_count_or </td>
          <td>(</td>
          <td class="paramtype">const gap_word_t *BMRESTRICT&nbsp;</td>
          <td class="paramname"> <em>vect1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const gap_word_t *BMRESTRICT&nbsp;</td>
          <td class="paramname"> <em>vect2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>GAP bitcount OR operation test. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>vect1</em>&nbsp;</td><td>- operand 1 </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>vect2</em>&nbsp;</td><td>- operand 2 </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>bitcount of vect1 OR vect2 </dd></dl>

<p>Definition at line <a class="el" href="a00093_source.html#l03338">3338</a> of file <a class="el" href="a00093_source.html">bmfunc.h</a>.</p>

<p>References <a class="el" href="a00093_source.html#l01084">bm::gap_buff_count_op()</a>, and <a class="el" href="a00093_source.html#l03157">bm::or_op()</a>.</p>

<p>Referenced by <a class="el" href="a00089_source.html#l00116">bm::combine_count_operation_with_block()</a>.</p>

</div>
</div>
<a class="anchor" id="gacacf55c60da82a1c384f3ac3a51229d4"></a><!-- doxytag: member="bm::gap_count_sub" ref="gacacf55c60da82a1c384f3ac3a51229d4" args="(const gap_word_t *BMRESTRICT vect1, const gap_word_t *BMRESTRICT vect2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BMFORCEINLINE unsigned bm::gap_count_sub </td>
          <td>(</td>
          <td class="paramtype">const gap_word_t *BMRESTRICT&nbsp;</td>
          <td class="paramname"> <em>vect1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const gap_word_t *BMRESTRICT&nbsp;</td>
          <td class="paramname"> <em>vect2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>GAP bitcount SUB (AND NOT) operation test. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>vect1</em>&nbsp;</td><td>- operand 1 </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>vect2</em>&nbsp;</td><td>- operand 2 </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>bitcount of vect1 SUB (AND NOT) vect2 </dd></dl>

<p>Definition at line <a class="el" href="a00093_source.html#l03405">3405</a> of file <a class="el" href="a00093_source.html">bmfunc.h</a>.</p>

<p>References <a class="el" href="a00093_source.html#l01084">bm::gap_buff_count_op()</a>, and <a class="el" href="a00093_source.html#l03163">bm::sub_op()</a>.</p>

<p>Referenced by <a class="el" href="a00089_source.html#l00116">bm::combine_count_operation_with_block()</a>.</p>

</div>
</div>
<a class="anchor" id="gae38d6a3296f0562be512f47b4edfb1ad"></a><!-- doxytag: member="bm::gap_count_xor" ref="gae38d6a3296f0562be512f47b4edfb1ad" args="(const gap_word_t *BMRESTRICT vect1, const gap_word_t *BMRESTRICT vect2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BMFORCEINLINE unsigned bm::gap_count_xor </td>
          <td>(</td>
          <td class="paramtype">const gap_word_t *BMRESTRICT&nbsp;</td>
          <td class="paramname"> <em>vect1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const gap_word_t *BMRESTRICT&nbsp;</td>
          <td class="paramname"> <em>vect2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>GAP bitcount XOR operation test. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>vect1</em>&nbsp;</td><td>- operand 1 </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>vect2</em>&nbsp;</td><td>- operand 2 </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>bitcount of vect1 XOR vect2 </dd></dl>

<p>Definition at line <a class="el" href="a00093_source.html#l03293">3293</a> of file <a class="el" href="a00093_source.html">bmfunc.h</a>.</p>

<p>References <a class="el" href="a00093_source.html#l01084">bm::gap_buff_count_op()</a>, and <a class="el" href="a00093_source.html#l03150">bm::xor_op()</a>.</p>

<p>Referenced by <a class="el" href="a00089_source.html#l00116">bm::combine_count_operation_with_block()</a>.</p>

</div>
</div>
<a class="anchor" id="gaa7df7193094353ea24b8519debf745be"></a><!-- doxytag: member="bm::gap_find_in_block" ref="gaa7df7193094353ea24b8519debf745be" args="(const T *buf, unsigned nbit, bm::id_t *prev)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int bm::gap_find_in_block </td>
          <td>(</td>
          <td class="paramtype">const T *&nbsp;</td>
          <td class="paramname"> <em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>nbit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00115.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a> *&nbsp;</td>
          <td class="paramname"> <em>prev</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Searches for the next 1 bit in the GAP block. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buf</em>&nbsp;</td><td>- GAP buffer </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nbit</em>&nbsp;</td><td>- bit index to start checking from. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>prev</em>&nbsp;</td><td>- returns previously checked value </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="a00093_source.html#l01436">1436</a> of file <a class="el" href="a00093_source.html">bmfunc.h</a>.</p>

<p>References <a class="el" href="a00092_source.html#l00050">BM_ASSERT</a>, <a class="el" href="a00093_source.html#l00461">bm::gap_bfind()</a>, and <a class="el" href="a00091_source.html#l00072">bm::gap_max_bits</a>.</p>

</div>
</div>
<a class="anchor" id="gafd76869eb44fac688da5e26e0e74f41f"></a><!-- doxytag: member="bm::gap_free_elements" ref="gafd76869eb44fac688da5e26e0e74f41f" args="(const T *buf, const T *glevel_len)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned bm::gap_free_elements </td>
          <td>(</td>
          <td class="paramtype">const T *&nbsp;</td>
          <td class="paramname"> <em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&nbsp;</td>
          <td class="paramname"> <em>glevel_len</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns number of free elements in GAP block array. Difference between GAP block capacity on this level and actual GAP length. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buf</em>&nbsp;</td><td>- GAP buffer pointer  glevel_len - GAP lengths table</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Number of free GAP elements </dd></dl>

<p>Definition at line <a class="el" href="a00093_source.html#l02471">2471</a> of file <a class="el" href="a00093_source.html">bmfunc.h</a>.</p>

<p>References <a class="el" href="a00093_source.html#l02392">bm::gap_capacity()</a>, and <a class="el" href="a00093_source.html#l02378">bm::gap_length()</a>.</p>

</div>
</div>
<a class="anchor" id="ga510ab7feb60c19f7d7811cc304fdf649"></a><!-- doxytag: member="bm::gap_init_range_block" ref="ga510ab7feb60c19f7d7811cc304fdf649" args="(T *buf, T from, T to, T value, unsigned set_max)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void bm::gap_init_range_block </td>
          <td>(</td>
          <td class="paramtype">T *&nbsp;</td>
          <td class="paramname"> <em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&nbsp;</td>
          <td class="paramname"> <em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&nbsp;</td>
          <td class="paramname"> <em>to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>set_max</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Init gap block so it has block in it (can be whole block). </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buf</em>&nbsp;</td><td>- GAP buffer pointer. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>from</em>&nbsp;</td><td>- one block start </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>to</em>&nbsp;</td><td>- one block end </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>value</em>&nbsp;</td><td>- (block value)1 or 0 </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>set_max</em>&nbsp;</td><td>- max possible bitset length </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="a00093_source.html#l02270">2270</a> of file <a class="el" href="a00093_source.html">bmfunc.h</a>.</p>

<p>References <a class="el" href="a00092_source.html#l00050">BM_ASSERT</a>, and <a class="el" href="a00093_source.html#l02249">bm::gap_set_all()</a>.</p>

</div>
</div>
<a class="anchor" id="ga3f22bfde5dfe06d6d77dc2598b8c0845"></a><!-- doxytag: member="bm::gap_invert" ref="ga3f22bfde5dfe06d6d77dc2598b8c0845" args="(T *buf)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void bm::gap_invert </td>
          <td>(</td>
          <td class="paramtype">T *&nbsp;</td>
          <td class="paramname"> <em>buf</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Inverts all bits in the GAP buffer. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buf</em>&nbsp;</td><td>- GAP buffer pointer. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="a00093_source.html#l02320">2320</a> of file <a class="el" href="a00093_source.html">bmfunc.h</a>.</p>

<p>Referenced by <a class="el" href="a00093_source.html#l03318">bm::gap_operation_or()</a>, and <a class="el" href="a00096_source.html#l01227">bm::deseriaizer_base&lt; DEC &gt;::read_gap_block()</a>.</p>

</div>
</div>
<a class="anchor" id="ga1427d43e91872f981c6311fa76ab5633"></a><!-- doxytag: member="bm::gap_is_all_one" ref="ga1427d43e91872f981c6311fa76ab5633" args="(const T *buf, unsigned set_max)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bm::gap_is_all_one </td>
          <td>(</td>
          <td class="paramtype">const T *&nbsp;</td>
          <td class="paramname"> <em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>set_max</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Checks if GAP block is all-one. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buf</em>&nbsp;</td><td>- GAP buffer pointer. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>set_max</em>&nbsp;</td><td>- max possible bitset length </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if all-one. </dd></dl>

<p>Definition at line <a class="el" href="a00093_source.html#l02366">2366</a> of file <a class="el" href="a00093_source.html">bmfunc.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga690ff7c8b16e1821a77663b7194267e7"></a><!-- doxytag: member="bm::gap_is_all_zero" ref="ga690ff7c8b16e1821a77663b7194267e7" args="(const T *buf, unsigned set_max)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bm::gap_is_all_zero </td>
          <td>(</td>
          <td class="paramtype">const T *&nbsp;</td>
          <td class="paramname"> <em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>set_max</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Temporary inverts all bits in the GAP buffer. </p>
<p>In this function const-ness of the buffer means nothing. Calling this function again restores the status of the buffer.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buf</em>&nbsp;</td><td>- GAP buffer pointer. (Buffer IS changed)</td></tr>
  </table>
  </dd>
</dl>
<p>Checks if GAP block is all-zero. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buf</em>&nbsp;</td><td>- GAP buffer pointer. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>set_max</em>&nbsp;</td><td>- max possible bitset length </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if all-zero. </dd></dl>

<p>Definition at line <a class="el" href="a00093_source.html#l02352">2352</a> of file <a class="el" href="a00093_source.html">bmfunc.h</a>.</p>

<p>Referenced by <a class="el" href="a00089_source.html#l00366">bm::combine_any_operation_with_block()</a>, and <a class="el" href="a00087_source.html#l01914">bm::bvector&lt; Alloc &gt;::compare()</a>.</p>

</div>
</div>
<a class="anchor" id="ga02541ec6c2930c292eda4313b78e874c"></a><!-- doxytag: member="bm::gap_length" ref="ga02541ec6c2930c292eda4313b78e874c" args="(const T *buf)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T bm::gap_length </td>
          <td>(</td>
          <td class="paramtype">const T *&nbsp;</td>
          <td class="paramname"> <em>buf</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returs GAP block length. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buf</em>&nbsp;</td><td>- GAP buffer pointer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>GAP block length. </dd></dl>

<p>Definition at line <a class="el" href="a00093_source.html#l02378">2378</a> of file <a class="el" href="a00093_source.html">bmfunc.h</a>.</p>

<p>Referenced by <a class="el" href="a00087_source.html#l02044">bm::bvector&lt; Alloc &gt;::calc_stat()</a>, <a class="el" href="a00096_source.html#l03101">bm::iterator_deserializer&lt; BV, SerialIterator &gt;::deserialize()</a>, <a class="el" href="a00096_source.html#l01316">bm::deserializer&lt; BV, DEC &gt;::deserialize_gap()</a>, <a class="el" href="a00096_source.html#l00709">bm::serializer&lt; BV &gt;::encode_gap_block()</a>, <a class="el" href="a00096_source.html#l00625">bm::serializer&lt; BV &gt;::gamma_gap_block()</a>, <a class="el" href="a00093_source.html#l02471">bm::gap_free_elements()</a>, and <a class="el" href="a00096_source.html#l01227">bm::deseriaizer_base&lt; DEC &gt;::read_gap_block()</a>.</p>

</div>
</div>
<a class="anchor" id="ga1defe73aa4227a0e7204363ac6bb1ac1"></a><!-- doxytag: member="bm::gap_level" ref="ga1defe73aa4227a0e7204363ac6bb1ac1" args="(const T *buf)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned bm::gap_level </td>
          <td>(</td>
          <td class="paramtype">const T *&nbsp;</td>
          <td class="paramname"> <em>buf</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returs GAP blocks capacity level. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buf</em>&nbsp;</td><td>- GAP buffer pointer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>GAP block capacity level. </dd></dl>

<p>Definition at line <a class="el" href="a00093_source.html#l02420">2420</a> of file <a class="el" href="a00093_source.html">bmfunc.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga94a5371b5dc6a1560d95d7c2dde88815"></a><!-- doxytag: member="bm::gap_limit" ref="ga94a5371b5dc6a1560d95d7c2dde88815" args="(const T *buf, const T *glevel_len)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned bm::gap_limit </td>
          <td>(</td>
          <td class="paramtype">const T *&nbsp;</td>
          <td class="paramname"> <em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&nbsp;</td>
          <td class="paramname"> <em>glevel_len</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returs GAP block capacity limit. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buf</em>&nbsp;</td><td>- GAP buffer pointer. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>glevel_len</em>&nbsp;</td><td>- GAP lengths table (<a class="el" href="a00066.html" title="Default GAP lengths table.">gap_len_table</a>) </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>GAP block limit. </dd></dl>

<p>Definition at line <a class="el" href="a00093_source.html#l02407">2407</a> of file <a class="el" href="a00093_source.html">bmfunc.h</a>.</p>

<p>Referenced by <a class="el" href="a00089_source.html#l01141">bm::combine_or()</a>, <a class="el" href="a00089_source.html#l01304">bm::combine_sub()</a>, and <a class="el" href="a00089_source.html#l01220">bm::combine_xor()</a>.</p>

</div>
</div>
<a class="anchor" id="gac18d7da0492983802511999a4ad0764a"></a><!-- doxytag: member="bm::gap_operation_and" ref="gac18d7da0492983802511999a4ad0764a" args="(const gap_word_t *BMRESTRICT vect1, const gap_word_t *BMRESTRICT vect2, gap_word_t *BMRESTRICT tmp_buf, unsigned &amp;dsize)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BMFORCEINLINE gap_word_t* bm::gap_operation_and </td>
          <td>(</td>
          <td class="paramtype">const gap_word_t *BMRESTRICT&nbsp;</td>
          <td class="paramname"> <em>vect1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const gap_word_t *BMRESTRICT&nbsp;</td>
          <td class="paramname"> <em>vect2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gap_word_t *BMRESTRICT&nbsp;</td>
          <td class="paramname"> <em>tmp_buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned &amp;&nbsp;</td>
          <td class="paramname"> <em>dsize</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>GAP AND operation. </p>
<p>Function performs AND logical operation on gap vectors. If possible function put the result into vect1 and returns this pointer. Otherwise result is put into tmp_buf, which should be twice of the vector size.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>vect1</em>&nbsp;</td><td>- operand 1 </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>vect2</em>&nbsp;</td><td>- operand 2 </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tmp_buf</em>&nbsp;</td><td>- pointer on temporary buffer </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dsize</em>&nbsp;</td><td>- out size of the destination </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Result pointer (tmp_buf OR vect1) </dd></dl>

<p>Definition at line <a class="el" href="a00093_source.html#l03186">3186</a> of file <a class="el" href="a00093_source.html">bmfunc.h</a>.</p>

<p>References <a class="el" href="a00093_source.html#l03143">bm::and_op()</a>, and <a class="el" href="a00093_source.html#l00933">bm::gap_buff_op()</a>.</p>

</div>
</div>
<a class="anchor" id="ga58e0312d3ab0551e883176b170c0a3e8"></a><!-- doxytag: member="bm::gap_operation_any_and" ref="ga58e0312d3ab0551e883176b170c0a3e8" args="(const gap_word_t *BMRESTRICT vect1, const gap_word_t *BMRESTRICT vect2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BMFORCEINLINE unsigned bm::gap_operation_any_and </td>
          <td>(</td>
          <td class="paramtype">const gap_word_t *BMRESTRICT&nbsp;</td>
          <td class="paramname"> <em>vect1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const gap_word_t *BMRESTRICT&nbsp;</td>
          <td class="paramname"> <em>vect2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>GAP AND operation test. </p>
<p>Function performs AND logical operation on gap vectors. If possible function put the result into vect1 and returns this pointer. Otherwise result is put into tmp_buf, which should be twice of the vector size.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>vect1</em>&nbsp;</td><td>- operand 1 </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>vect2</em>&nbsp;</td><td>- operand 2 </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>non zero value if operation returns any 1 bit </dd></dl>

<p>Definition at line <a class="el" href="a00093_source.html#l03210">3210</a> of file <a class="el" href="a00093_source.html">bmfunc.h</a>.</p>

<p>References <a class="el" href="a00093_source.html#l03143">bm::and_op()</a>, and <a class="el" href="a00093_source.html#l01015">bm::gap_buff_any_op()</a>.</p>

<p>Referenced by <a class="el" href="a00089_source.html#l00366">bm::combine_any_operation_with_block()</a>.</p>

</div>
</div>
<a class="anchor" id="ga1c9b33d00f74206ad655dc2cef52428b"></a><!-- doxytag: member="bm::gap_operation_any_sub" ref="ga1c9b33d00f74206ad655dc2cef52428b" args="(const gap_word_t *BMRESTRICT vect1, const gap_word_t *BMRESTRICT vect2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BMFORCEINLINE unsigned bm::gap_operation_any_sub </td>
          <td>(</td>
          <td class="paramtype">const gap_word_t *BMRESTRICT&nbsp;</td>
          <td class="paramname"> <em>vect1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const gap_word_t *BMRESTRICT&nbsp;</td>
          <td class="paramname"> <em>vect2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>GAP SUB operation test. </p>
<p>Function performs AND logical operation on gap vectors. If possible function put the result into vect1 and returns this pointer. Otherwise result is put into tmp_buf, which should be twice of the vector size.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>vect1</em>&nbsp;</td><td>- operand 1 </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>vect2</em>&nbsp;</td><td>- operand 2 </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>non zero value if operation returns any 1 bit </dd></dl>

<p>Definition at line <a class="el" href="a00093_source.html#l03388">3388</a> of file <a class="el" href="a00093_source.html">bmfunc.h</a>.</p>

<p>References <a class="el" href="a00093_source.html#l03143">bm::and_op()</a>, and <a class="el" href="a00093_source.html#l01015">bm::gap_buff_any_op()</a>.</p>

<p>Referenced by <a class="el" href="a00089_source.html#l00366">bm::combine_any_operation_with_block()</a>.</p>

</div>
</div>
<a class="anchor" id="gab8800dff60eb05404a83159035e8e72f"></a><!-- doxytag: member="bm::gap_operation_any_xor" ref="gab8800dff60eb05404a83159035e8e72f" args="(const gap_word_t *BMRESTRICT vect1, const gap_word_t *BMRESTRICT vect2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BMFORCEINLINE unsigned bm::gap_operation_any_xor </td>
          <td>(</td>
          <td class="paramtype">const gap_word_t *BMRESTRICT&nbsp;</td>
          <td class="paramname"> <em>vect1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const gap_word_t *BMRESTRICT&nbsp;</td>
          <td class="paramname"> <em>vect2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>GAP XOR operation test. </p>
<p>Function performs AND logical operation on gap vectors. If possible function put the result into vect1 and returns this pointer. Otherwise result is put into tmp_buf, which should be twice of the vector size.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>vect1</em>&nbsp;</td><td>- operand 1 </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>vect2</em>&nbsp;</td><td>- operand 2 </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>non zero value if operation returns any 1 bit </dd></dl>

<p>Definition at line <a class="el" href="a00093_source.html#l03277">3277</a> of file <a class="el" href="a00093_source.html">bmfunc.h</a>.</p>

<p>References <a class="el" href="a00093_source.html#l01015">bm::gap_buff_any_op()</a>, and <a class="el" href="a00093_source.html#l03150">bm::xor_op()</a>.</p>

<p>Referenced by <a class="el" href="a00089_source.html#l00366">bm::combine_any_operation_with_block()</a>.</p>

</div>
</div>
<a class="anchor" id="gacda280af8910ae5fde37731a3a7a1226"></a><!-- doxytag: member="bm::gap_operation_or" ref="gacda280af8910ae5fde37731a3a7a1226" args="(const gap_word_t *BMRESTRICT vect1, const gap_word_t *BMRESTRICT vect2, gap_word_t *BMRESTRICT tmp_buf, unsigned &amp;dsize)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gap_word_t* bm::gap_operation_or </td>
          <td>(</td>
          <td class="paramtype">const gap_word_t *BMRESTRICT&nbsp;</td>
          <td class="paramname"> <em>vect1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const gap_word_t *BMRESTRICT&nbsp;</td>
          <td class="paramname"> <em>vect2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gap_word_t *BMRESTRICT&nbsp;</td>
          <td class="paramname"> <em>tmp_buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned &amp;&nbsp;</td>
          <td class="paramname"> <em>dsize</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>GAP OR operation. </p>
<p>Function performs OR logical oparation on gap vectors. If possible function put the result into vect1 and returns this pointer. Otherwise result is put into tmp_buf, which should be twice of the vector size.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>vect1</em>&nbsp;</td><td>- operand 1 </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>vect2</em>&nbsp;</td><td>- operand 2 </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tmp_buf</em>&nbsp;</td><td>- pointer on temporary buffer </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dsize</em>&nbsp;</td><td>- out destination size</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Result pointer (tmp_buf) </dd></dl>

<p>Definition at line <a class="el" href="a00093_source.html#l03318">3318</a> of file <a class="el" href="a00093_source.html">bmfunc.h</a>.</p>

<p>References <a class="el" href="a00093_source.html#l03143">bm::and_op()</a>, <a class="el" href="a00093_source.html#l00933">bm::gap_buff_op()</a>, and <a class="el" href="a00093_source.html#l02320">bm::gap_invert()</a>.</p>

<p>Referenced by <a class="el" href="a00089_source.html#l00366">bm::combine_any_operation_with_block()</a>.</p>

</div>
</div>
<a class="anchor" id="gabe4c83e5e162c38e297116dd1cd05ac4"></a><!-- doxytag: member="bm::gap_operation_sub" ref="gabe4c83e5e162c38e297116dd1cd05ac4" args="(const gap_word_t *BMRESTRICT vect1, const gap_word_t *BMRESTRICT vect2, gap_word_t *BMRESTRICT tmp_buf, unsigned &amp;dsize)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gap_word_t* bm::gap_operation_sub </td>
          <td>(</td>
          <td class="paramtype">const gap_word_t *BMRESTRICT&nbsp;</td>
          <td class="paramname"> <em>vect1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const gap_word_t *BMRESTRICT&nbsp;</td>
          <td class="paramname"> <em>vect2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gap_word_t *BMRESTRICT&nbsp;</td>
          <td class="paramname"> <em>tmp_buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned &amp;&nbsp;</td>
          <td class="paramname"> <em>dsize</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>GAP SUB (AND NOT) operation. </p>
<p>Function performs SUB logical operation on gap vectors. If possible function put the result into vect1 and returns this pointer. Otherwise result is put into tmp_buf, which should be twice of the vector size.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>vect1</em>&nbsp;</td><td>- operand 1 </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>vect2</em>&nbsp;</td><td>- operand 2 </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tmp_buf</em>&nbsp;</td><td>- pointer on temporary buffer </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dsize</em>&nbsp;</td><td>- out destination size</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Result pointer (tmp_buf) </dd></dl>

<p>Definition at line <a class="el" href="a00093_source.html#l03363">3363</a> of file <a class="el" href="a00093_source.html">bmfunc.h</a>.</p>

<p>References <a class="el" href="a00093_source.html#l03143">bm::and_op()</a>, and <a class="el" href="a00093_source.html#l00933">bm::gap_buff_op()</a>.</p>

</div>
</div>
<a class="anchor" id="ga72d2d3933b4410413eeb02e9ee0a910d"></a><!-- doxytag: member="bm::gap_operation_xor" ref="ga72d2d3933b4410413eeb02e9ee0a910d" args="(const gap_word_t *BMRESTRICT vect1, const gap_word_t *BMRESTRICT vect2, gap_word_t *BMRESTRICT tmp_buf, unsigned &amp;dsize)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BMFORCEINLINE gap_word_t* bm::gap_operation_xor </td>
          <td>(</td>
          <td class="paramtype">const gap_word_t *BMRESTRICT&nbsp;</td>
          <td class="paramname"> <em>vect1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const gap_word_t *BMRESTRICT&nbsp;</td>
          <td class="paramname"> <em>vect2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gap_word_t *BMRESTRICT&nbsp;</td>
          <td class="paramname"> <em>tmp_buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned &amp;&nbsp;</td>
          <td class="paramname"> <em>dsize</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>GAP XOR operation. </p>
<p>Function performs XOR logical operation on gap vectors. If possible function put the result into vect1 and returns this pointer. Otherwise result is put into tmp_buf, which should be twice of the vector size.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>vect1</em>&nbsp;</td><td>- operand 1 </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>vect2</em>&nbsp;</td><td>- operand 2 </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tmp_buf</em>&nbsp;</td><td>- pointer on temporary buffer </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dsize</em>&nbsp;</td><td>- out destination size </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Result pointer (tmp_buf) </dd></dl>

<p>Definition at line <a class="el" href="a00093_source.html#l03252">3252</a> of file <a class="el" href="a00093_source.html">bmfunc.h</a>.</p>

<p>References <a class="el" href="a00093_source.html#l00933">bm::gap_buff_op()</a>, and <a class="el" href="a00093_source.html#l03150">bm::xor_op()</a>.</p>

</div>
</div>
<a class="anchor" id="gacc578010f3700940829c600c812d23b1"></a><!-- doxytag: member="bm::gap_overhead" ref="gacc578010f3700940829c600c812d23b1" args="(const T *length, const T *length_end, const T *glevel_len)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned bm::gap_overhead </td>
          <td>(</td>
          <td class="paramtype">const T *&nbsp;</td>
          <td class="paramname"> <em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&nbsp;</td>
          <td class="paramname"> <em>length_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&nbsp;</td>
          <td class="paramname"> <em>glevel_len</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convert bit block into an array of ints corresponding to 1 bits. </p>
<p>OBSOLETE function</p>
<p>Calculates memory overhead for number of gap blocks sharing the same memory allocation table (level lengths table). </p>

<p>Definition at line <a class="el" href="a00093_source.html#l04847">4847</a> of file <a class="el" href="a00093_source.html">bmfunc.h</a>.</p>

<p>References <a class="el" href="a00092_source.html#l00050">BM_ASSERT</a>, <a class="el" href="a00093_source.html#l02450">bm::gap_calc_level()</a>, and <a class="el" href="a00091_source.html#l00075">bm::gap_levels</a>.</p>

<p>Referenced by <a class="el" href="a00093_source.html#l04874">bm::improve_gap_levels()</a>.</p>

</div>
</div>
<a class="anchor" id="gaef53b2877ff369badd7bb25b26bb9029"></a><!-- doxytag: member="bm::gap_set_all" ref="gaef53b2877ff369badd7bb25b26bb9029" args="(T *buf, unsigned set_max, unsigned value)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void bm::gap_set_all </td>
          <td>(</td>
          <td class="paramtype">T *&nbsp;</td>
          <td class="paramname"> <em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>set_max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets all bits to 0 or 1 (GAP). </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buf</em>&nbsp;</td><td>- GAP buffer pointer. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>set_max</em>&nbsp;</td><td>- max possible bitset length </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="a00093_source.html#l02249">2249</a> of file <a class="el" href="a00093_source.html">bmfunc.h</a>.</p>

<p>References <a class="el" href="a00092_source.html#l00050">BM_ASSERT</a>.</p>

<p>Referenced by <a class="el" href="a00093_source.html#l02270">bm::gap_init_range_block()</a>, and <a class="el" href="a00096_source.html#l01227">bm::deseriaizer_base&lt; DEC &gt;::read_gap_block()</a>.</p>

</div>
</div>
<a class="anchor" id="ga550394048c163d41a135fb9068f2251b"></a><!-- doxytag: member="bm::gap_set_array" ref="ga550394048c163d41a135fb9068f2251b" args="(T *buf, const T *arr, unsigned len)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned bm::gap_set_array </td>
          <td>(</td>
          <td class="paramtype">T *&nbsp;</td>
          <td class="paramname"> <em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&nbsp;</td>
          <td class="paramname"> <em>arr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>len</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convert array to GAP buffer. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buf</em>&nbsp;</td><td>- GAP buffer. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>arr</em>&nbsp;</td><td>- array of values to set </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>len</em>&nbsp;</td><td>- length of the array</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>New GAP buffer length. </dd></dl>

<p>Definition at line <a class="el" href="a00093_source.html#l01346">1346</a> of file <a class="el" href="a00093_source.html">bmfunc.h</a>.</p>

<p>References <a class="el" href="a00091_source.html#l00072">bm::gap_max_bits</a>.</p>

<p>Referenced by <a class="el" href="a00096_source.html#l01316">bm::deserializer&lt; BV, DEC &gt;::deserialize_gap()</a>, and <a class="el" href="a00096_source.html#l01227">bm::deseriaizer_base&lt; DEC &gt;::read_gap_block()</a>.</p>

</div>
</div>
<a class="anchor" id="ga69186bd13bda27e04b3e33683ff884c2"></a><!-- doxytag: member="bm::gap_set_value" ref="ga69186bd13bda27e04b3e33683ff884c2" args="(unsigned val, T *BMRESTRICT buf, unsigned pos, unsigned *BMRESTRICT is_set)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned bm::gap_set_value </td>
          <td>(</td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *BMRESTRICT&nbsp;</td>
          <td class="paramname"> <em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned *BMRESTRICT&nbsp;</td>
          <td class="paramname"> <em>is_set</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets or clears bit in the GAP buffer. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>val</em>&nbsp;</td><td>- new bit value </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>buf</em>&nbsp;</td><td>- GAP buffer. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pos</em>&nbsp;</td><td>- Index of bit to set. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>is_set</em>&nbsp;</td><td>- (OUT) flag if bit was actually set.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>New GAP buffer length. </dd></dl>

<p>Definition at line <a class="el" href="a00093_source.html#l01168">1168</a> of file <a class="el" href="a00093_source.html">bmfunc.h</a>.</p>

<p>References <a class="el" href="a00092_source.html#l00050">BM_ASSERT</a>, <a class="el" href="a00093_source.html#l00461">bm::gap_bfind()</a>, and <a class="el" href="a00091_source.html#l00072">bm::gap_max_bits</a>.</p>

<p>Referenced by <a class="el" href="a00089_source.html#l01141">bm::combine_or()</a>, <a class="el" href="a00089_source.html#l01304">bm::combine_sub()</a>, <a class="el" href="a00089_source.html#l01220">bm::combine_xor()</a>, and <a class="el" href="a00103_source.html#l00106">bm::miniset&lt; A, N &gt;::set()</a>.</p>

</div>
</div>
<a class="anchor" id="gabcedad4aea1a503c30f10e6d09b523f2"></a><!-- doxytag: member="bm::gap_sub_to_bitset" ref="gabcedad4aea1a503c30f10e6d09b523f2" args="(unsigned *BMRESTRICT dest, const T *BMRESTRICT buf)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void bm::gap_sub_to_bitset </td>
          <td>(</td>
          <td class="paramtype">unsigned *BMRESTRICT&nbsp;</td>
          <td class="paramname"> <em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *BMRESTRICT&nbsp;</td>
          <td class="paramname"> <em>buf</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>SUB (AND NOT) GAP block to bitblock. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dest</em>&nbsp;</td><td>- bitblock buffer pointer. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>buf</em>&nbsp;</td><td>- GAP buffer pointer. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="a00093_source.html#l01677">1677</a> of file <a class="el" href="a00093_source.html">bmfunc.h</a>.</p>

<p>References <a class="el" href="a00092_source.html#l00050">BM_ASSERT</a>, and <a class="el" href="a00093_source.html#l01553">bm::sub_bit_block()</a>.</p>

</div>
</div>
<a class="anchor" id="ga866352ef5986a7d2b709795d127b666b"></a><!-- doxytag: member="bm::gap_test" ref="ga866352ef5986a7d2b709795d127b666b" args="(const T *buf, unsigned pos)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned bm::gap_test </td>
          <td>(</td>
          <td class="paramtype">const T *&nbsp;</td>
          <td class="paramname"> <em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>pos</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Tests if bit = pos is true. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buf</em>&nbsp;</td><td>- GAP buffer pointer. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pos</em>&nbsp;</td><td>- index of the element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if position is in "1" gap </dd></dl>

<p>Definition at line <a class="el" href="a00093_source.html#l00489">489</a> of file <a class="el" href="a00093_source.html">bmfunc.h</a>.</p>

<p>References <a class="el" href="a00092_source.html#l00050">BM_ASSERT</a>, and <a class="el" href="a00091_source.html#l00072">bm::gap_max_bits</a>.</p>

<p>Referenced by <a class="el" href="a00089_source.html#l01304">bm::combine_sub()</a>, <a class="el" href="a00089_source.html#l01220">bm::combine_xor()</a>, <a class="el" href="a00087_source.html#l01804">bm::bvector&lt; Alloc &gt;::get_bit()</a>, and <a class="el" href="a00103_source.html#l00095">bm::miniset&lt; A, N &gt;::test()</a>.</p>

</div>
</div>
<a class="anchor" id="ga63c33428c2f5eac9f69d663203cd2172"></a><!-- doxytag: member="bm::gap_xor_to_bitset" ref="ga63c33428c2f5eac9f69d663203cd2172" args="(unsigned *BMRESTRICT dest, const T *BMRESTRICT buf)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void bm::gap_xor_to_bitset </td>
          <td>(</td>
          <td class="paramtype">unsigned *BMRESTRICT&nbsp;</td>
          <td class="paramname"> <em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *BMRESTRICT&nbsp;</td>
          <td class="paramname"> <em>buf</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>XOR GAP block to bitblock. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dest</em>&nbsp;</td><td>- bitblock buffer pointer. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>buf</em>&nbsp;</td><td>- GAP buffer pointer. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="a00093_source.html#l01705">1705</a> of file <a class="el" href="a00093_source.html">bmfunc.h</a>.</p>

<p>References <a class="el" href="a00092_source.html#l00050">BM_ASSERT</a>, and <a class="el" href="a00093_source.html#l01615">bm::xor_bit_block()</a>.</p>

</div>
</div>
<a class="anchor" id="ga406952734f1b05962941b32e37b3eb96"></a><!-- doxytag: member="bm::gapcmp" ref="ga406952734f1b05962941b32e37b3eb96" args="(const T *buf1, const T *buf2)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int bm::gapcmp </td>
          <td>(</td>
          <td class="paramtype">const T *&nbsp;</td>
          <td class="paramname"> <em>buf1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&nbsp;</td>
          <td class="paramname"> <em>buf2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Lexicographical comparison of GAP buffers. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buf1</em>&nbsp;</td><td>- First GAP buffer pointer. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>buf2</em>&nbsp;</td><td>- Second GAP buffer pointer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>&lt;0 - less, =0 - equal, &gt;0 - greater. </dd></dl>

<p>Definition at line <a class="el" href="a00093_source.html#l00866">866</a> of file <a class="el" href="a00093_source.html">bmfunc.h</a>.</p>

<p>Referenced by <a class="el" href="a00087_source.html#l01914">bm::bvector&lt; Alloc &gt;::compare()</a>.</p>

</div>
</div>
<a class="anchor" id="ga2daff3a0ceda6fef87d3b0e892da5813"></a><!-- doxytag: member="bm::improve_gap_levels" ref="ga2daff3a0ceda6fef87d3b0e892da5813" args="(const T *length, const T *length_end, T *glevel_len)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bm::improve_gap_levels </td>
          <td>(</td>
          <td class="paramtype">const T *&nbsp;</td>
          <td class="paramname"> <em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&nbsp;</td>
          <td class="paramname"> <em>length_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&nbsp;</td>
          <td class="paramname"> <em>glevel_len</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Finds optimal gap blocks lengths. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>length</em>&nbsp;</td><td>- first element of GAP lengths array </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>length_end</em>&nbsp;</td><td>- end of the GAP lengths array </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>glevel_len</em>&nbsp;</td><td>- destination GAP lengths array </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="a00093_source.html#l04874">4874</a> of file <a class="el" href="a00093_source.html">bmfunc.h</a>.</p>

<p>References <a class="el" href="a00092_source.html#l00050">BM_ASSERT</a>, <a class="el" href="a00091_source.html#l00075">bm::gap_levels</a>, <a class="el" href="a00091_source.html#l00070">bm::gap_max_buff_len</a>, and <a class="el" href="a00093_source.html#l04847">bm::gap_overhead()</a>.</p>

<p>Referenced by <a class="el" href="a00087_source.html#l01880">bm::bvector&lt; Alloc &gt;::optimize_gap_size()</a>.</p>

</div>
</div>
<a class="anchor" id="ga501aa9bf029e7f9ea9518e7003fe5549"></a><!-- doxytag: member="bm::set_gap_level" ref="ga501aa9bf029e7f9ea9518e7003fe5549" args="(T *buf, unsigned level)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void bm::set_gap_level </td>
          <td>(</td>
          <td class="paramtype">T *&nbsp;</td>
          <td class="paramname"> <em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>level</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets GAP block capacity level. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buf</em>&nbsp;</td><td>- GAP buffer pointer. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>level</em>&nbsp;</td><td>new GAP block capacity level. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="a00093_source.html#l02434">2434</a> of file <a class="el" href="a00093_source.html">bmfunc.h</a>.</p>

<p>References <a class="el" href="a00092_source.html#l00050">BM_ASSERT</a>, and <a class="el" href="a00091_source.html#l00075">bm::gap_levels</a>.</p>

<p>Referenced by <a class="el" href="a00096_source.html#l03319">bm::iterator_deserializer&lt; BV, SerialIterator &gt;::deserialize()</a>, and <a class="el" href="a00096_source.html#l01316">bm::deserializer&lt; BV, DEC &gt;::deserialize_gap()</a>.</p>

</div>
</div>
</div>
<hr size="1"/><address style="text-align: right;"><small>Generated on Sun Apr 25 09:37:39 2010 for BitMagic by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
