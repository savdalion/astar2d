<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BitMagic: BIT functions</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>BIT functions<br/>
<small>
[<a class="el" href="a00117.html">BitMagic C++ Library</a>]</small>
</h1>
<p><div class="dynheader">
Collaboration diagram for BIT functions:</div>
<div class="dynsection">
<center><table><tr><td><img src="a00120.png" border="0" alt="" usemap="#a00120_map"/>
<map name="a00120_map" id="a00120">
<area shape="rect" href="a00117.html" title="For more information please visit: http://bmagic.sourceforge.net." alt="" coords="5,5,149,35"/></map></td></tr></table></center>
</div>
</p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Data Structures</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00040.html">bm::block_set_table&lt; T &gt;</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Structure keeps all-left/right ON bits masks.  <a href="a00040.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00011.html">bm::all_set&lt; T &gt;</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Structure carries pointer on bit block with all bits 1.  <a href="a00011.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00063.html">bm::first_bit_table&lt; T &gt;</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Structure keeps index of first right 1 bit for every byte.  <a href="a00063.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00022.html">bm::bit_count_table&lt; T &gt;</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Structure to aid in counting bits table contains count of bits in 0-255 diapason of numbers.  <a href="a00022.html#_details">More...</a><br/></td></tr>
<tr><td colspan="2"><h2>Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00120.html#ga967f6a5264f47d8adb93f6bdf8cdc129">BM_INCWORD_BITCOUNT</a>(cnt, w)&nbsp;&nbsp;&nbsp;cnt += _mm_popcnt_u32(w);</td></tr>
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">BMFORCEINLINE <a class="el" href="a00115.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00120.html#gaef40342b0c318391df3db2b891acf7c1">bm::word_bitcount</a> (<a class="el" href="a00115.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a> w)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">int&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00120.html#gafee2e8361c2e90a67dbaf9c7559d50e4">bm::wordcmp0</a> (T w1, T w2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Lexicographical comparison of two words as bit strings. Auxiliary implementation for testing and reference purposes.  <a href="#gafee2e8361c2e90a67dbaf9c7559d50e4"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">int&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00120.html#ga5847533a73b7a5125fe5c2888ec827bd">bm::wordcmp</a> (T a, T b)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Lexicographical comparison of two words as bit strings. Auxiliary implementation for testing and reference purposes.  <a href="#ga5847533a73b7a5125fe5c2888ec827bd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">BMFORCEINLINE void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00120.html#ga2becf9a16ec20ab124ca8938e34b4aa8">bm::set_bit</a> (unsigned *dest, unsigned bitpos)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set 1 bit in a block.  <a href="#ga2becf9a16ec20ab124ca8938e34b4aa8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">BMFORCEINLINE unsigned&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00120.html#ga9bccc586aa791f98f1bec284b799102c">bm::test_bit</a> (const unsigned *block, unsigned bitpos)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Test 1 bit in a block.  <a href="#ga9bccc586aa791f98f1bec284b799102c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00120.html#gad698b5242f5b629aa28e7338b7150497">bm::or_bit_block</a> (unsigned *dest, unsigned bitpos, unsigned bitcount)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets bits to 1 in the bitblock.  <a href="#gad698b5242f5b629aa28e7338b7150497"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00120.html#gaceaa54aa59b16299f5a87b925715e5e8">bm::sub_bit_block</a> (unsigned *dest, unsigned bitpos, unsigned bitcount)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">SUB (AND NOT) bit interval to 1 in the bitblock.  <a href="#gaceaa54aa59b16299f5a87b925715e5e8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00120.html#ga6191abb017003b633fab24e0c6357521">bm::xor_bit_block</a> (unsigned *dest, unsigned bitpos, unsigned bitcount)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">XOR bit interval to 1 in the bitblock.  <a href="#ga6191abb017003b633fab24e0c6357521"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00115.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00120.html#gab87384cbf46a04d86c008ab2463d02cc">bm::gap_bitset_and_count</a> (const unsigned *block, const T *buf)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute bitcount of bit block AND masked by GAP block.  <a href="#gab87384cbf46a04d86c008ab2463d02cc"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00115.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00120.html#gad6e40898b8836ae1923b06a3d028fcaa">bm::gap_bitset_and_any</a> (const unsigned *block, const T *buf)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Bitcount test of bit block AND masked by GAP block.  <a href="#gad6e40898b8836ae1923b06a3d028fcaa"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00115.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00120.html#ga15a780da58d5aeb67ffc51c84fa6152e">bm::gap_bitset_sub_count</a> (const unsigned *block, const T *buf)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute bitcount of bit block SUB masked by GAP block.  <a href="#ga15a780da58d5aeb67ffc51c84fa6152e"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00115.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00120.html#gaab7c711122e8f189555dffd83a21111c">bm::gap_bitset_sub_any</a> (const unsigned *block, const T *buf)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute bitcount test of bit block SUB masked by GAP block.  <a href="#gaab7c711122e8f189555dffd83a21111c"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00115.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00120.html#ga803fbc7c790f07b14175303e524bd2d8">bm::gap_bitset_xor_count</a> (const unsigned *block, const T *buf)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute bitcount of bit block XOR masked by GAP block.  <a href="#ga803fbc7c790f07b14175303e524bd2d8"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00115.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00120.html#gad0f7ee00f84ea357d55e6a2f507c8918">bm::gap_bitset_xor_any</a> (const unsigned *block, const T *buf)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute bitcount test of bit block XOR masked by GAP block.  <a href="#gad0f7ee00f84ea357d55e6a2f507c8918"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00115.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00120.html#ga23733890861063a59f787e26763a734a">bm::gap_bitset_or_count</a> (const unsigned *block, const T *buf)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute bitcount of bit block OR masked by GAP block.  <a href="#ga23733890861063a59f787e26763a734a"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00115.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00120.html#gad15f1b92c70752cd3b97fa9e0c585f00">bm::gap_bitset_or_any</a> (const unsigned *block, const T *buf)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute bitcount test of bit block OR masked by GAP block.  <a href="#gad15f1b92c70752cd3b97fa9e0c585f00"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00120.html#gaada8b13c35acd8df90129b45edcfc5de">bm::bit_block_set</a> (<a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *BMRESTRICT dst, <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> value)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Bitblock memset operation.  <a href="#gaada8b13c35acd8df90129b45edcfc5de"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">int&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00120.html#ga91fe9566575d9d66e1bb9d030b3d29a0">bm::bitcmp</a> (const T *buf1, const T *buf2, unsigned len)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Lexicographical comparison of BIT buffers.  <a href="#ga91fe9566575d9d66e1bb9d030b3d29a0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00115.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00120.html#gab30df14a61f036d690c091878feaff1c">bm::bit_block_calc_count</a> (const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *block, const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *block_end)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Bitcount for bit string.  <a href="#gab30df14a61f036d690c091878feaff1c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00115.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00120.html#gaafc87c4764bb30d95ba4088064a404e3">bm::bit_count_change</a> (<a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> w)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00115.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00120.html#gaca91016aeb08ae1b610d6d407aae0e4c">bm::bit_block_calc_count_change</a> (const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *block, const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *block_end, unsigned *bit_count)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00115.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00120.html#ga2485f707b2629c5ce7681cf9fe385b91">bm::bit_block_calc_count_range</a> (const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *block, <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> left, <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> right)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00115.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00120.html#ga503e0f3e79f819d9b58e4b0e905be116">bm::bit_block_any_range</a> (const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *block, <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> left, <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> right)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00120.html#ga95854f9969985254a0f58b928da0eec6">bm::bit_invert</a> (T *start, T *end)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00120.html#ga97b1075250d4bf10f596ff2fbc334ceb">bm::is_bits_one</a> (const <a class="el" href="a00115.html#a7176bf7817550ca24cb6612bd8d7957d">bm::wordop_t</a> *start, const <a class="el" href="a00115.html#a7176bf7817550ca24cb6612bd8d7957d">bm::wordop_t</a> *end)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns "true" if all bits in the block are 1.  <a href="#ga97b1075250d4bf10f596ff2fbc334ceb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00120.html#gac6cfb9f92e4df6bb4c76f6efb2382860">bm::bit_is_all_zero</a> (const <a class="el" href="a00115.html#a7176bf7817550ca24cb6612bd8d7957d">bm::wordop_t</a> *start, const <a class="el" href="a00115.html#a7176bf7817550ca24cb6612bd8d7957d">bm::wordop_t</a> *end)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns "true" if all bits in the block are 0.  <a href="#gac6cfb9f92e4df6bb4c76f6efb2382860"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00120.html#ga9090de87d53e7f25eff96c8259b3485c">bm::bit_block_copy</a> (<a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *BMRESTRICT dst, const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *BMRESTRICT src)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Bitblock copy operation.  <a href="#ga9090de87d53e7f25eff96c8259b3485c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00120.html#ga882f79df0a0175ad4ddf483c5f1eeb0e">bm::bit_block_and</a> (<a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *BMRESTRICT dst, const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *BMRESTRICT src)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Plain bitblock AND operation. Function does not analyse availability of source and destination blocks.  <a href="#ga882f79df0a0175ad4ddf483c5f1eeb0e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00120.html#ga0070984bb1d332610150a9106ab8eb0a">bm::bit_block_and_count</a> (const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *src1, const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *src1_end, const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *src2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Function ANDs two bitblocks and computes the bitcount. Function does not analyse availability of source blocks.  <a href="#ga0070984bb1d332610150a9106ab8eb0a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00120.html#ga9fe2d12ddac5293fe53038c687c732f3">bm::bit_block_and_any</a> (const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *src1, const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *src1_end, const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *src2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Function ANDs two bitblocks and tests for any bit. Function does not analyse availability of source blocks.  <a href="#ga9fe2d12ddac5293fe53038c687c732f3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00120.html#gaf8af8cfe8b49407be1af7398da28c939">bm::bit_block_xor_count</a> (const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *BMRESTRICT src1, const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *BMRESTRICT src1_end, const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *BMRESTRICT src2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Function XORs two bitblocks and computes the bitcount. Function does not analyse availability of source blocks.  <a href="#gaf8af8cfe8b49407be1af7398da28c939"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00120.html#gafbc3ffafc859a503fdd2fc96e7fb60ce">bm::bit_block_xor_any</a> (const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *BMRESTRICT src1, const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *BMRESTRICT src1_end, const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *BMRESTRICT src2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Function XORs two bitblocks and and tests for any bit. Function does not analyse availability of source blocks.  <a href="#gafbc3ffafc859a503fdd2fc96e7fb60ce"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00120.html#gad34175255e9860a572fcf2e664a6de8e">bm::bit_block_sub_count</a> (const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *BMRESTRICT src1, const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *BMRESTRICT src1_end, const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *BMRESTRICT src2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Function SUBs two bitblocks and computes the bitcount. Function does not analyse availability of source blocks.  <a href="#gad34175255e9860a572fcf2e664a6de8e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00120.html#ga3f51735d2ca08e5a9fae2c9c49138c5c">bm::bit_block_sub_any</a> (const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *BMRESTRICT src1, const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *BMRESTRICT src1_end, const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *BMRESTRICT src2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Function SUBs two bitblocks and and tests for any bit. Function does not analyse availability of source blocks.  <a href="#ga3f51735d2ca08e5a9fae2c9c49138c5c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00120.html#gacf4f8ab164277278448a541863c07517">bm::bit_block_or_count</a> (const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *src1, const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *src1_end, const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *src2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Function ORs two bitblocks and computes the bitcount. Function does not analyse availability of source blocks.  <a href="#gacf4f8ab164277278448a541863c07517"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00120.html#gab2047495f7844d3014ff697503669d24">bm::bit_block_or_any</a> (const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *BMRESTRICT src1, const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *BMRESTRICT src1_end, const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *BMRESTRICT src2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Function ORs two bitblocks and and tests for any bit. Function does not analyse availability of source blocks.  <a href="#gab2047495f7844d3014ff697503669d24"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00120.html#ga869fce5348076d4c7b92adcc2f1a49ab">bm::bit_operation_and</a> (<a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *BMRESTRICT dst, const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *BMRESTRICT src)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">bitblock AND operation.  <a href="#ga869fce5348076d4c7b92adcc2f1a49ab"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00115.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00120.html#ga9765914087df2fc22ec18db8128f2a12">bm::bit_operation_and_count</a> (const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *BMRESTRICT src1, const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *BMRESTRICT src1_end, const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *BMRESTRICT src2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs bitblock AND operation and calculates bitcount of the result.  <a href="#ga9765914087df2fc22ec18db8128f2a12"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00115.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00120.html#ga0e7995f7d6c791f6ff27a8dd21d324e5">bm::bit_operation_and_any</a> (const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *BMRESTRICT src1, const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *BMRESTRICT src1_end, const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *BMRESTRICT src2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs bitblock AND operation test.  <a href="#ga0e7995f7d6c791f6ff27a8dd21d324e5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00115.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00120.html#gaabb39bf01bf973cb7bf3648873921ab7">bm::bit_operation_sub_count</a> (const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *BMRESTRICT src1, const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *BMRESTRICT src1_end, const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *BMRESTRICT src2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs bitblock SUB operation and calculates bitcount of the result.  <a href="#gaabb39bf01bf973cb7bf3648873921ab7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00115.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00120.html#ga53867faf377db72324b858a37063c0b8">bm::bit_operation_sub_count_inv</a> (const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *BMRESTRICT src1, const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *BMRESTRICT src1_end, const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *BMRESTRICT src2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs inverted bitblock SUB operation and calculates bitcount of the result.  <a href="#ga53867faf377db72324b858a37063c0b8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00115.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00120.html#ga847d5a84673b284be984f0db583e2723">bm::bit_operation_sub_any</a> (const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *BMRESTRICT src1, const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *BMRESTRICT src1_end, const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *BMRESTRICT src2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs bitblock test of SUB operation.  <a href="#ga847d5a84673b284be984f0db583e2723"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00115.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00120.html#ga5a267aff3b56cc6dadf5a3a338e00a1d">bm::bit_operation_or_count</a> (const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *BMRESTRICT src1, const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *BMRESTRICT src1_end, const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *BMRESTRICT src2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs bitblock OR operation and calculates bitcount of the result.  <a href="#ga5a267aff3b56cc6dadf5a3a338e00a1d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00115.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00120.html#ga6d26742bdc373074474a6932eab4f388">bm::bit_operation_or_any</a> (const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *BMRESTRICT src1, const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *BMRESTRICT src1_end, const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *BMRESTRICT src2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs bitblock OR operation test.  <a href="#ga6d26742bdc373074474a6932eab4f388"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00120.html#ga3515d8eb5da7f9d41d63dc90ad9523a4">bm::bit_block_or</a> (<a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *BMRESTRICT dst, const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *BMRESTRICT src)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Plain bitblock OR operation. Function does not analyse availability of source and destination blocks.  <a href="#ga3515d8eb5da7f9d41d63dc90ad9523a4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00120.html#ga0e945a9eaae699ad40f63b3f0632e6f9">bm::bit_operation_or</a> (<a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *BMRESTRICT dst, const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *BMRESTRICT src)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Block OR operation. Makes analysis if block is 0 or FULL.  <a href="#ga0e945a9eaae699ad40f63b3f0632e6f9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00120.html#gafed81435f74c0542857842d4461686e4">bm::bit_block_sub</a> (<a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *BMRESTRICT dst, const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *BMRESTRICT src)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Plain bitblock SUB (AND NOT) operation. Function does not analyse availability of source and destination blocks.  <a href="#gafed81435f74c0542857842d4461686e4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00120.html#gad7afa9bce28a376360ca4826960d669f">bm::bit_operation_sub</a> (<a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *BMRESTRICT dst, const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *BMRESTRICT src)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">bitblock SUB operation.  <a href="#gad7afa9bce28a376360ca4826960d669f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00120.html#gae6a46c5e671ea1c9312219ceb41025ef">bm::bit_block_xor</a> (<a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *BMRESTRICT dst, const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *BMRESTRICT src)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Plain bitblock XOR operation. Function does not analyse availability of source and destination blocks.  <a href="#gae6a46c5e671ea1c9312219ceb41025ef"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00120.html#ga179de722e87ccf8189d975ca6beed025">bm::bit_operation_xor</a> (<a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *BMRESTRICT dst, const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *BMRESTRICT src)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">bitblock XOR operation.  <a href="#ga179de722e87ccf8189d975ca6beed025"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00115.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00120.html#gace08ab77feefb638daee164ee83118bc">bm::bit_operation_xor_count</a> (const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *BMRESTRICT src1, const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *BMRESTRICT src1_end, const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *BMRESTRICT src2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs bitblock XOR operation and calculates bitcount of the result.  <a href="#gace08ab77feefb638daee164ee83118bc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00115.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00120.html#gaa86561b6d11c3f01dd772563c692f732">bm::bit_operation_xor_any</a> (const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *BMRESTRICT src1, const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *BMRESTRICT src1_end, const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *BMRESTRICT src2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs bitblock XOR operation test.  <a href="#gaa86561b6d11c3f01dd772563c692f732"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">unsigned&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00120.html#ga0ff158706f2e194be67fb8267641c30a">bm::bit_count_nonzero_size</a> (const T *blk, unsigned data_size)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Inspects block for full zero words.  <a href="#ga0ff158706f2e194be67fb8267641c30a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00120.html#gad6a7c549a625df7aa7d68d43a57238c7">bm::bit_find_in_block</a> (const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *data, unsigned nbit, <a class="el" href="a00115.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a> *prev)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Searches for the next 1 bit in the BIT block.  <a href="#gad6a7c549a625df7aa7d68d43a57238c7"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T , typename F &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00120.html#gab9f80b3c898323ce77beb915e4c861f3">bm::bit_for_each_4</a> (T w, F &amp;func)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Templated algorithm to unpacks octet based word into list of ON bit indexes.  <a href="#gab9f80b3c898323ce77beb915e4c861f3"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T , typename F &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00120.html#ga24be2ad5d8c2a8f18fdad142452aaae8">bm::bit_for_each</a> (T w, F &amp;func)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Templated algorithm to unpacks word into list of ON bit indexes.  <a href="#ga24be2ad5d8c2a8f18fdad142452aaae8"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T , typename B &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">unsigned&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00120.html#ga3c81f6bff8866ec3ed0a94903eee96b7">bm::bit_list_4</a> (T w, B *bits)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unpacks word into list of ON bit indexes (quad-bit based).  <a href="#ga3c81f6bff8866ec3ed0a94903eee96b7"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T , typename B &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">unsigned&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00120.html#gaae3ae537760044543f842363e4614e82">bm::bit_list</a> (T w, B *bits)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unpacks word into list of ON bit indexes.  <a href="#gaae3ae537760044543f842363e4614e82"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00115.html#a593916a103395805070a3200720c6416">bm::set_representation</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00120.html#ga20610fae6b0de84957b74ed17429667f">bm::best_representation</a> (unsigned bit_count, unsigned total_possible_bitcount, unsigned gap_count, unsigned block_size)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Choose best representation for a bit-block.  <a href="#ga20610fae6b0de84957b74ed17429667f"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">T&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00120.html#gaf24d85761f60877c2260f8160593f732">bm::bit_convert_to_arr</a> (T *BMRESTRICT dest, const unsigned *BMRESTRICT src, <a class="el" href="a00115.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a> bits, unsigned dest_len, unsigned mask=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convert bit block into an array of ints corresponding to 1 bits.  <a href="#gaf24d85761f60877c2260f8160593f732"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T , unsigned BPC, unsigned BPS&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00120.html#ga3fe02492f64cd8a9dfbb1a00ec71c0ae">bm::tmatrix_distance</a> (const T tmatrix[BPC][BPS], unsigned distance[BPC][BPC])</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute pairwise Row x Row Humming distances on plains(rows) of the transposed bit block.  <a href="#ga3fe02492f64cd8a9dfbb1a00ec71c0ae"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T , unsigned BPC, unsigned BPS&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00120.html#gabdc11d48fda6a69873eefd219c4b7e75">bm::bit_iblock_make_pcv</a> (const unsigned distance[BPC][BPC], unsigned char *pc_vector)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">!&lt; ibpc limiter  <a href="#gabdc11d48fda6a69873eefd219c4b7e75"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Bit functions implement different opereations on bit blocks and serve as a minimal building blocks. </p>
<hr/><h2>Define Documentation</h2>
<a class="anchor" id="ga967f6a5264f47d8adb93f6bdf8cdc129"></a><!-- doxytag: member="bmdef.h::BM_INCWORD_BITCOUNT" ref="ga967f6a5264f47d8adb93f6bdf8cdc129" args="(cnt, w)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BM_INCWORD_BITCOUNT</td>
          <td>(</td>
          <td class="paramtype">cnt, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">w&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td>&nbsp;&nbsp;&nbsp;cnt += _mm_popcnt_u32(w);</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Define calculates number of 1 bits in 32-bit word. </p>

<p>Definition at line <a class="el" href="a00092_source.html#l00159">159</a> of file <a class="el" href="a00092_source.html">bmdef.h</a>.</p>

<p>Referenced by <a class="el" href="a00093_source.html#l03480">bm::bit_block_and_count()</a>, <a class="el" href="a00093_source.html#l02726">bm::bit_block_calc_count()</a>, <a class="el" href="a00093_source.html#l02950">bm::bit_block_calc_count_range()</a>, <a class="el" href="a00093_source.html#l03721">bm::bit_block_or_count()</a>, <a class="el" href="a00093_source.html#l03642">bm::bit_block_sub_count()</a>, <a class="el" href="a00093_source.html#l03561">bm::bit_block_xor_count()</a>, <a class="el" href="a00093_source.html#l02786">bm::bit_count_change()</a>, <a class="el" href="a00093_source.html#l02802">bm::bit_count_change32()</a>, <a class="el" href="a00093_source.html#l05178">bm::bit_COUNT_B&lt; W &gt;::operator()()</a>, <a class="el" href="a00093_source.html#l05167">bm::bit_COUNT_A&lt; W &gt;::operator()()</a>, <a class="el" href="a00093_source.html#l05156">bm::bit_COUNT_SUB_BA&lt; W &gt;::operator()()</a>, <a class="el" href="a00093_source.html#l05145">bm::bit_COUNT_SUB_AB&lt; W &gt;::operator()()</a>, <a class="el" href="a00093_source.html#l05133">bm::bit_COUNT_OR&lt; W &gt;::operator()()</a>, <a class="el" href="a00093_source.html#l05122">bm::bit_COUNT_XOR&lt; W &gt;::operator()()</a>, <a class="el" href="a00093_source.html#l05111">bm::bit_COUNT_AND&lt; W &gt;::operator()()</a>, <a class="el" href="a00093_source.html#l05100">bm::bit_COUNT&lt; W &gt;::operator()()</a>, <a class="el" href="a00097_source.html#l00237">bm::sse2_bit_block_calc_count_change()</a>, and <a class="el" href="a00100_source.html#l00352">bm::tmatrix_distance()</a>.</p>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="ga20610fae6b0de84957b74ed17429667f"></a><!-- doxytag: member="bm::best_representation" ref="ga20610fae6b0de84957b74ed17429667f" args="(unsigned bit_count, unsigned total_possible_bitcount, unsigned gap_count, unsigned block_size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00115.html#a593916a103395805070a3200720c6416">bm::set_representation</a> bm::best_representation </td>
          <td>(</td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>bit_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>total_possible_bitcount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>gap_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>block_size</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Choose best representation for a bit-block. </p>

<p>Definition at line <a class="el" href="a00093_source.html#l04713">4713</a> of file <a class="el" href="a00093_source.html">bmfunc.h</a>.</p>

<p>References <a class="el" href="a00091_source.html#l00131">bm::set_array0</a>, <a class="el" href="a00091_source.html#l00130">bm::set_array1</a>, <a class="el" href="a00091_source.html#l00128">bm::set_bitset</a>, and <a class="el" href="a00091_source.html#l00129">bm::set_gap</a>.</p>

<p>Referenced by <a class="el" href="a00100_source.html#l00687">bm::compute_tmatrix_rstat()</a>.</p>

</div>
</div>
<a class="anchor" id="ga882f79df0a0175ad4ddf483c5f1eeb0e"></a><!-- doxytag: member="bm::bit_block_and" ref="ga882f79df0a0175ad4ddf483c5f1eeb0e" args="(bm::word_t *BMRESTRICT dst, const bm::word_t *BMRESTRICT src)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bm::bit_block_and </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *BMRESTRICT&nbsp;</td>
          <td class="paramname"> <em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *BMRESTRICT&nbsp;</td>
          <td class="paramname"> <em>src</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Plain bitblock AND operation. Function does not analyse availability of source and destination blocks. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dst</em>&nbsp;</td><td>- destination block. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>src</em>&nbsp;</td><td>- source block. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="a00093_source.html#l03446">3446</a> of file <a class="el" href="a00093_source.html">bmfunc.h</a>.</p>

<p>References <a class="el" href="a00091_source.html#l00052">bm::set_block_size</a>, and <a class="el" href="a00098_source.html#l00219">VECT_AND_ARR</a>.</p>

<p>Referenced by <a class="el" href="a00093_source.html#l03802">bm::bit_operation_and()</a>, and <a class="el" href="a00096_source.html#l02034">bm::serial_stream_iterator&lt; DEC &gt;::get_bit_block_AND()</a>.</p>

</div>
</div>
<a class="anchor" id="ga9fe2d12ddac5293fe53038c687c732f3"></a><!-- doxytag: member="bm::bit_block_and_any" ref="ga9fe2d12ddac5293fe53038c687c732f3" args="(const bm::word_t *src1, const bm::word_t *src1_end, const bm::word_t *src2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned bm::bit_block_and_any </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *&nbsp;</td>
          <td class="paramname"> <em>src1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *&nbsp;</td>
          <td class="paramname"> <em>src1_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *&nbsp;</td>
          <td class="paramname"> <em>src2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Function ANDs two bitblocks and tests for any bit. Function does not analyse availability of source blocks. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>src1</em>&nbsp;</td><td>- first bit block </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>src1_end</em>&nbsp;</td><td>- first bit block end </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>src2</em>&nbsp;</td><td>- second bit block </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="a00093_source.html#l03530">3530</a> of file <a class="el" href="a00093_source.html">bmfunc.h</a>.</p>

<p>Referenced by <a class="el" href="a00093_source.html#l03890">bm::bit_operation_and_any()</a>.</p>

</div>
</div>
<a class="anchor" id="ga0070984bb1d332610150a9106ab8eb0a"></a><!-- doxytag: member="bm::bit_block_and_count" ref="ga0070984bb1d332610150a9106ab8eb0a" args="(const bm::word_t *src1, const bm::word_t *src1_end, const bm::word_t *src2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned bm::bit_block_and_count </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *&nbsp;</td>
          <td class="paramname"> <em>src1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *&nbsp;</td>
          <td class="paramname"> <em>src1_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *&nbsp;</td>
          <td class="paramname"> <em>src2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Function ANDs two bitblocks and computes the bitcount. Function does not analyse availability of source blocks. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>src1</em>&nbsp;</td><td>- first bit block </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>src1_end</em>&nbsp;</td><td>- first bit block end </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>src2</em>&nbsp;</td><td>- second bit block </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="a00093_source.html#l03480">3480</a> of file <a class="el" href="a00093_source.html">bmfunc.h</a>.</p>

<p>References <a class="el" href="a00092_source.html#l00159">BM_INCWORD_BITCOUNT</a>, and <a class="el" href="a00098_source.html#l00204">VECT_BITCOUNT_AND</a>.</p>

<p>Referenced by <a class="el" href="a00093_source.html#l03867">bm::bit_operation_and_count()</a>.</p>

</div>
</div>
<a class="anchor" id="ga503e0f3e79f819d9b58e4b0e905be116"></a><!-- doxytag: member="bm::bit_block_any_range" ref="ga503e0f3e79f819d9b58e4b0e905be116" args="(const bm::word_t *block, bm::word_t left, bm::word_t right)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00115.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a> bm::bit_block_any_range </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *&nbsp;</td>
          <td class="paramname"> <em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a>&nbsp;</td>
          <td class="paramname"> <em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a>&nbsp;</td>
          <td class="paramname"> <em>right</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Function calculates if there is any number of 1 bits in the given array of words in the range between left anf right bits (borders included). Make sure the addresses are aligned. </p>

<p>Definition at line <a class="el" href="a00093_source.html#l03016">3016</a> of file <a class="el" href="a00093_source.html">bmfunc.h</a>.</p>

<p>References <a class="el" href="a00092_source.html#l00050">BM_ASSERT</a>, <a class="el" href="a00091_source.html#l00063">bm::set_word_mask</a>, and <a class="el" href="a00091_source.html#l00062">bm::set_word_shift</a>.</p>

<p>Referenced by <a class="el" href="a00093_source.html#l01837">bm::gap_bitset_and_any()</a>, <a class="el" href="a00093_source.html#l02075">bm::gap_bitset_or_any()</a>, <a class="el" href="a00093_source.html#l01909">bm::gap_bitset_sub_any()</a>, and <a class="el" href="a00093_source.html#l01985">bm::gap_bitset_xor_any()</a>.</p>

</div>
</div>
<a class="anchor" id="gab30df14a61f036d690c091878feaff1c"></a><!-- doxytag: member="bm::bit_block_calc_count" ref="gab30df14a61f036d690c091878feaff1c" args="(const bm::word_t *block, const bm::word_t *block_end)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00115.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a> bm::bit_block_calc_count </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *&nbsp;</td>
          <td class="paramname"> <em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *&nbsp;</td>
          <td class="paramname"> <em>block_end</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Bitcount for bit string. </p>
<p>Function calculates number of 1 bits in the given array of words. Make sure the addresses are aligned. </p>

<p>Definition at line <a class="el" href="a00093_source.html#l02726">2726</a> of file <a class="el" href="a00093_source.html">bmfunc.h</a>.</p>

<p>References <a class="el" href="a00092_source.html#l00050">BM_ASSERT</a>, <a class="el" href="a00092_source.html#l00159">BM_INCWORD_BITCOUNT</a>, and <a class="el" href="a00098_source.html#l00201">VECT_BITCOUNT</a>.</p>

<p>Referenced by <a class="el" href="a00093_source.html#l03996">bm::bit_operation_or_count()</a>, <a class="el" href="a00093_source.html#l03915">bm::bit_operation_sub_count()</a>, <a class="el" href="a00093_source.html#l04330">bm::bit_operation_xor_count()</a>, <a class="el" href="a00089_source.html#l00116">bm::combine_count_operation_with_block()</a>, <a class="el" href="a00096_source.html#l02281">bm::serial_stream_iterator&lt; DEC &gt;::get_bit_block_COUNT_A()</a>, and <a class="el" href="a00100_source.html#l00352">bm::tmatrix_distance()</a>.</p>

</div>
</div>
<a class="anchor" id="gaca91016aeb08ae1b610d6d407aae0e4c"></a><!-- doxytag: member="bm::bit_block_calc_count_change" ref="gaca91016aeb08ae1b610d6d407aae0e4c" args="(const bm::word_t *block, const bm::word_t *block_end, unsigned *bit_count)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00115.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a> bm::bit_block_calc_count_change </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *&nbsp;</td>
          <td class="paramname"> <em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *&nbsp;</td>
          <td class="paramname"> <em>block_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned *&nbsp;</td>
          <td class="paramname"> <em>bit_count</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Function calculates number of times when bit value changed (1-0 or 0-1) in the bit block. Also calulates number of bits ON.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>bit_count</em>&nbsp;</td><td>- OUT total number of bits ON</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>number of 1-0, 0-1 transitions </dd></dl>

<p>Definition at line <a class="el" href="a00093_source.html#l02864">2864</a> of file <a class="el" href="a00093_source.html">bmfunc.h</a>.</p>

<p>References <a class="el" href="a00093_source.html#l02802">bm::bit_count_change32()</a>, <a class="el" href="a00092_source.html#l00050">BM_ASSERT</a>, <a class="el" href="a00097_source.html#l00237">bm::sse2_bit_block_calc_count_change()</a>, and <a class="el" href="a00098_source.html#l00248">bm::sse4_bit_block_calc_count_change()</a>.</p>

<p>Referenced by <a class="el" href="a00096_source.html#l00814">bm::serializer&lt; BV &gt;::serialize()</a>.</p>

</div>
</div>
<a class="anchor" id="ga2485f707b2629c5ce7681cf9fe385b91"></a><!-- doxytag: member="bm::bit_block_calc_count_range" ref="ga2485f707b2629c5ce7681cf9fe385b91" args="(const bm::word_t *block, bm::word_t left, bm::word_t right)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00115.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a> bm::bit_block_calc_count_range </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *&nbsp;</td>
          <td class="paramname"> <em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a>&nbsp;</td>
          <td class="paramname"> <em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a>&nbsp;</td>
          <td class="paramname"> <em>right</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Function calculates number of 1 bits in the given array of words in the range between left anf right bits (borders included) Make sure the addresses are aligned. </p>

<p>Definition at line <a class="el" href="a00093_source.html#l02950">2950</a> of file <a class="el" href="a00093_source.html">bmfunc.h</a>.</p>

<p>References <a class="el" href="a00092_source.html#l00050">BM_ASSERT</a>, <a class="el" href="a00092_source.html#l00159">BM_INCWORD_BITCOUNT</a>, <a class="el" href="a00091_source.html#l00063">bm::set_word_mask</a>, and <a class="el" href="a00091_source.html#l00062">bm::set_word_shift</a>.</p>

<p>Referenced by <a class="el" href="a00087_source.html#l01687">bm::bvector&lt; Alloc &gt;::count_range()</a>, <a class="el" href="a00093_source.html#l01806">bm::gap_bitset_and_count()</a>, <a class="el" href="a00093_source.html#l02028">bm::gap_bitset_or_count()</a>, <a class="el" href="a00093_source.html#l01876">bm::gap_bitset_sub_count()</a>, and <a class="el" href="a00093_source.html#l01947">bm::gap_bitset_xor_count()</a>.</p>

</div>
</div>
<a class="anchor" id="ga9090de87d53e7f25eff96c8259b3485c"></a><!-- doxytag: member="bm::bit_block_copy" ref="ga9090de87d53e7f25eff96c8259b3485c" args="(bm::word_t *BMRESTRICT dst, const bm::word_t *BMRESTRICT src)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bm::bit_block_copy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *BMRESTRICT&nbsp;</td>
          <td class="paramname"> <em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *BMRESTRICT&nbsp;</td>
          <td class="paramname"> <em>src</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Bitblock copy operation. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dst</em>&nbsp;</td><td>- destination block. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>src</em>&nbsp;</td><td>- source block. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="a00093_source.html#l03426">3426</a> of file <a class="el" href="a00093_source.html">bmfunc.h</a>.</p>

<p>References <a class="el" href="a00091_source.html#l00052">bm::set_block_size</a>, and <a class="el" href="a00098_source.html#l00231">VECT_COPY_BLOCK</a>.</p>

</div>
</div>
<a class="anchor" id="ga3515d8eb5da7f9d41d63dc90ad9523a4"></a><!-- doxytag: member="bm::bit_block_or" ref="ga3515d8eb5da7f9d41d63dc90ad9523a4" args="(bm::word_t *BMRESTRICT dst, const bm::word_t *BMRESTRICT src)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bm::bit_block_or </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *BMRESTRICT&nbsp;</td>
          <td class="paramname"> <em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *BMRESTRICT&nbsp;</td>
          <td class="paramname"> <em>src</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Plain bitblock OR operation. Function does not analyse availability of source and destination blocks. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dst</em>&nbsp;</td><td>- destination block. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>src</em>&nbsp;</td><td>- source block. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="a00093_source.html#l04060">4060</a> of file <a class="el" href="a00093_source.html">bmfunc.h</a>.</p>

<p>References <a class="el" href="a00091_source.html#l00052">bm::set_block_size</a>, and <a class="el" href="a00098_source.html#l00222">VECT_OR_ARR</a>.</p>

<p>Referenced by <a class="el" href="a00093_source.html#l04098">bm::bit_operation_or()</a>.</p>

</div>
</div>
<a class="anchor" id="gab2047495f7844d3014ff697503669d24"></a><!-- doxytag: member="bm::bit_block_or_any" ref="gab2047495f7844d3014ff697503669d24" args="(const bm::word_t *BMRESTRICT src1, const bm::word_t *BMRESTRICT src1_end, const bm::word_t *BMRESTRICT src2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned bm::bit_block_or_any </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *BMRESTRICT&nbsp;</td>
          <td class="paramname"> <em>src1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *BMRESTRICT&nbsp;</td>
          <td class="paramname"> <em>src1_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *BMRESTRICT&nbsp;</td>
          <td class="paramname"> <em>src2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Function ORs two bitblocks and and tests for any bit. Function does not analyse availability of source blocks. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>src1</em>&nbsp;</td><td>- first bit block. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>src1_end</em>&nbsp;</td><td>- first bit block end </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>src2</em>&nbsp;</td><td>- second bit block. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="a00093_source.html#l03770">3770</a> of file <a class="el" href="a00093_source.html">bmfunc.h</a>.</p>

<p>Referenced by <a class="el" href="a00093_source.html#l04028">bm::bit_operation_or_any()</a>.</p>

</div>
</div>
<a class="anchor" id="gacf4f8ab164277278448a541863c07517"></a><!-- doxytag: member="bm::bit_block_or_count" ref="gacf4f8ab164277278448a541863c07517" args="(const bm::word_t *src1, const bm::word_t *src1_end, const bm::word_t *src2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned bm::bit_block_or_count </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *&nbsp;</td>
          <td class="paramname"> <em>src1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *&nbsp;</td>
          <td class="paramname"> <em>src1_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *&nbsp;</td>
          <td class="paramname"> <em>src2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Function ORs two bitblocks and computes the bitcount. Function does not analyse availability of source blocks. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>src1</em>&nbsp;</td><td>- first bit block </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>src1_end</em>&nbsp;</td><td>- first block end </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>src2</em>&nbsp;</td><td>- second bit block. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="a00093_source.html#l03721">3721</a> of file <a class="el" href="a00093_source.html">bmfunc.h</a>.</p>

<p>References <a class="el" href="a00092_source.html#l00159">BM_INCWORD_BITCOUNT</a>, and <a class="el" href="a00098_source.html#l00207">VECT_BITCOUNT_OR</a>.</p>

<p>Referenced by <a class="el" href="a00093_source.html#l03996">bm::bit_operation_or_count()</a>.</p>

</div>
</div>
<a class="anchor" id="gaada8b13c35acd8df90129b45edcfc5de"></a><!-- doxytag: member="bm::bit_block_set" ref="gaada8b13c35acd8df90129b45edcfc5de" args="(bm::word_t *BMRESTRICT dst, bm::word_t value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bm::bit_block_set </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *BMRESTRICT&nbsp;</td>
          <td class="paramname"> <em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a>&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Bitblock memset operation. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dst</em>&nbsp;</td><td>- destination block. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>value</em>&nbsp;</td><td>- value to set. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="a00093_source.html#l02126">2126</a> of file <a class="el" href="a00093_source.html">bmfunc.h</a>.</p>

<p>References <a class="el" href="a00091_source.html#l00052">bm::set_block_size</a>.</p>

<p>Referenced by <a class="el" href="a00096_source.html#l01424">bm::deserializer&lt; BV, DEC &gt;::deserialize()</a>, <a class="el" href="a00096_source.html#l01316">bm::deserializer&lt; BV, DEC &gt;::deserialize_gap()</a>, <a class="el" href="a00093_source.html#l02144">bm::gap_convert_to_bitset()</a>, <a class="el" href="a00093_source.html#l02158">bm::gap_convert_to_bitset_l()</a>, <a class="el" href="a00096_source.html#l02711">bm::serial_stream_iterator&lt; DEC &gt;::get_arr_bit()</a>, <a class="el" href="a00096_source.html#l01910">bm::serial_stream_iterator&lt; DEC &gt;::get_bit_block_ASSIGN()</a>, and <a class="el" href="a00100_source.html#l00810">bm::gap_transpose_engine&lt; GT, BT, BLOCK_SIZE &gt;::transpose()</a>.</p>

</div>
</div>
<a class="anchor" id="gafed81435f74c0542857842d4461686e4"></a><!-- doxytag: member="bm::bit_block_sub" ref="gafed81435f74c0542857842d4461686e4" args="(bm::word_t *BMRESTRICT dst, const bm::word_t *BMRESTRICT src)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bm::bit_block_sub </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *BMRESTRICT&nbsp;</td>
          <td class="paramname"> <em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *BMRESTRICT&nbsp;</td>
          <td class="paramname"> <em>src</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Plain bitblock SUB (AND NOT) operation. Function does not analyse availability of source and destination blocks. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dst</em>&nbsp;</td><td>- destination block. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>src</em>&nbsp;</td><td>- source block. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="a00093_source.html#l04156">4156</a> of file <a class="el" href="a00093_source.html">bmfunc.h</a>.</p>

<p>References <a class="el" href="a00091_source.html#l00052">bm::set_block_size</a>, and <a class="el" href="a00098_source.html#l00225">VECT_SUB_ARR</a>.</p>

<p>Referenced by <a class="el" href="a00093_source.html#l04196">bm::bit_operation_sub()</a>, and <a class="el" href="a00096_source.html#l02165">bm::serial_stream_iterator&lt; DEC &gt;::get_bit_block_SUB()</a>.</p>

</div>
</div>
<a class="anchor" id="ga3f51735d2ca08e5a9fae2c9c49138c5c"></a><!-- doxytag: member="bm::bit_block_sub_any" ref="ga3f51735d2ca08e5a9fae2c9c49138c5c" args="(const bm::word_t *BMRESTRICT src1, const bm::word_t *BMRESTRICT src1_end, const bm::word_t *BMRESTRICT src2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned bm::bit_block_sub_any </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *BMRESTRICT&nbsp;</td>
          <td class="paramname"> <em>src1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *BMRESTRICT&nbsp;</td>
          <td class="paramname"> <em>src1_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *BMRESTRICT&nbsp;</td>
          <td class="paramname"> <em>src2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Function SUBs two bitblocks and and tests for any bit. Function does not analyse availability of source blocks. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>src1</em>&nbsp;</td><td>- first bit block. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>src1_end</em>&nbsp;</td><td>- first bit block end </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>src2</em>&nbsp;</td><td>- second bit block. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="a00093_source.html#l03691">3691</a> of file <a class="el" href="a00093_source.html">bmfunc.h</a>.</p>

<p>Referenced by <a class="el" href="a00093_source.html#l03966">bm::bit_operation_sub_any()</a>.</p>

</div>
</div>
<a class="anchor" id="gad34175255e9860a572fcf2e664a6de8e"></a><!-- doxytag: member="bm::bit_block_sub_count" ref="gad34175255e9860a572fcf2e664a6de8e" args="(const bm::word_t *BMRESTRICT src1, const bm::word_t *BMRESTRICT src1_end, const bm::word_t *BMRESTRICT src2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned bm::bit_block_sub_count </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *BMRESTRICT&nbsp;</td>
          <td class="paramname"> <em>src1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *BMRESTRICT&nbsp;</td>
          <td class="paramname"> <em>src1_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *BMRESTRICT&nbsp;</td>
          <td class="paramname"> <em>src2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Function SUBs two bitblocks and computes the bitcount. Function does not analyse availability of source blocks. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>src1</em>&nbsp;</td><td>- first bit block. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>src1_end</em>&nbsp;</td><td>- first bit block end </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>src2</em>&nbsp;</td><td>- second bit block. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="a00093_source.html#l03642">3642</a> of file <a class="el" href="a00093_source.html">bmfunc.h</a>.</p>

<p>References <a class="el" href="a00092_source.html#l00159">BM_INCWORD_BITCOUNT</a>, and <a class="el" href="a00098_source.html#l00213">VECT_BITCOUNT_SUB</a>.</p>

<p>Referenced by <a class="el" href="a00093_source.html#l03915">bm::bit_operation_sub_count()</a>.</p>

</div>
</div>
<a class="anchor" id="gae6a46c5e671ea1c9312219ceb41025ef"></a><!-- doxytag: member="bm::bit_block_xor" ref="gae6a46c5e671ea1c9312219ceb41025ef" args="(bm::word_t *BMRESTRICT dst, const bm::word_t *BMRESTRICT src)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bm::bit_block_xor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *BMRESTRICT&nbsp;</td>
          <td class="paramname"> <em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *BMRESTRICT&nbsp;</td>
          <td class="paramname"> <em>src</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Plain bitblock XOR operation. Function does not analyse availability of source and destination blocks. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dst</em>&nbsp;</td><td>- destination block. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>src</em>&nbsp;</td><td>- source block. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="a00093_source.html#l04252">4252</a> of file <a class="el" href="a00093_source.html">bmfunc.h</a>.</p>

<p>References <a class="el" href="a00091_source.html#l00052">bm::set_block_size</a>, and <a class="el" href="a00098_source.html#l00228">VECT_XOR_ARR</a>.</p>

<p>Referenced by <a class="el" href="a00093_source.html#l04292">bm::bit_operation_xor()</a>, <a class="el" href="a00096_source.html#l03101">bm::iterator_deserializer&lt; BV, SerialIterator &gt;::deserialize()</a>, and <a class="el" href="a00096_source.html#l02105">bm::serial_stream_iterator&lt; DEC &gt;::get_bit_block_XOR()</a>.</p>

</div>
</div>
<a class="anchor" id="gafbc3ffafc859a503fdd2fc96e7fb60ce"></a><!-- doxytag: member="bm::bit_block_xor_any" ref="gafbc3ffafc859a503fdd2fc96e7fb60ce" args="(const bm::word_t *BMRESTRICT src1, const bm::word_t *BMRESTRICT src1_end, const bm::word_t *BMRESTRICT src2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned bm::bit_block_xor_any </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *BMRESTRICT&nbsp;</td>
          <td class="paramname"> <em>src1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *BMRESTRICT&nbsp;</td>
          <td class="paramname"> <em>src1_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *BMRESTRICT&nbsp;</td>
          <td class="paramname"> <em>src2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Function XORs two bitblocks and and tests for any bit. Function does not analyse availability of source blocks. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>src1</em>&nbsp;</td><td>- first bit block. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>src1_end</em>&nbsp;</td><td>- first bit block end </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>src2</em>&nbsp;</td><td>- second bit block. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="a00093_source.html#l03611">3611</a> of file <a class="el" href="a00093_source.html">bmfunc.h</a>.</p>

<p>Referenced by <a class="el" href="a00093_source.html#l04355">bm::bit_operation_xor_any()</a>.</p>

</div>
</div>
<a class="anchor" id="gaf8af8cfe8b49407be1af7398da28c939"></a><!-- doxytag: member="bm::bit_block_xor_count" ref="gaf8af8cfe8b49407be1af7398da28c939" args="(const bm::word_t *BMRESTRICT src1, const bm::word_t *BMRESTRICT src1_end, const bm::word_t *BMRESTRICT src2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned bm::bit_block_xor_count </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *BMRESTRICT&nbsp;</td>
          <td class="paramname"> <em>src1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *BMRESTRICT&nbsp;</td>
          <td class="paramname"> <em>src1_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *BMRESTRICT&nbsp;</td>
          <td class="paramname"> <em>src2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Function XORs two bitblocks and computes the bitcount. Function does not analyse availability of source blocks. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>src1</em>&nbsp;</td><td>- first bit block. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>src1_end</em>&nbsp;</td><td>- first bit block end </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>src2</em>&nbsp;</td><td>- second bit block. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="a00093_source.html#l03561">3561</a> of file <a class="el" href="a00093_source.html">bmfunc.h</a>.</p>

<p>References <a class="el" href="a00092_source.html#l00159">BM_INCWORD_BITCOUNT</a>, and <a class="el" href="a00098_source.html#l00210">VECT_BITCOUNT_XOR</a>.</p>

<p>Referenced by <a class="el" href="a00093_source.html#l04330">bm::bit_operation_xor_count()</a>.</p>

</div>
</div>
<a class="anchor" id="gaf24d85761f60877c2260f8160593f732"></a><!-- doxytag: member="bm::bit_convert_to_arr" ref="gaf24d85761f60877c2260f8160593f732" args="(T *BMRESTRICT dest, const unsigned *BMRESTRICT src, bm::id_t bits, unsigned dest_len, unsigned mask=0)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T bm::bit_convert_to_arr </td>
          <td>(</td>
          <td class="paramtype">T *BMRESTRICT&nbsp;</td>
          <td class="paramname"> <em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned *BMRESTRICT&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00115.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a>&nbsp;</td>
          <td class="paramname"> <em>bits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>dest_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>mask</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convert bit block into an array of ints corresponding to 1 bits. </p>

<p>Definition at line <a class="el" href="a00093_source.html#l04748">4748</a> of file <a class="el" href="a00093_source.html">bmfunc.h</a>.</p>

<p>References <a class="el" href="a00093_source.html#l04492">bm::bit_for_each_4()</a>, and <a class="el" href="a00093_source.html#l04634">bm::copy_to_array_functor_inc&lt; B &gt;::ptr()</a>.</p>

<p>Referenced by <a class="el" href="a00096_source.html#l00814">bm::serializer&lt; BV &gt;::serialize()</a>.</p>

</div>
</div>
<a class="anchor" id="gaafc87c4764bb30d95ba4088064a404e3"></a><!-- doxytag: member="bm::bit_count_change" ref="gaafc87c4764bb30d95ba4088064a404e3" args="(bm::word_t w)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00115.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a> bm::bit_count_change </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a>&nbsp;</td>
          <td class="paramname"> <em>w</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Function calculates number of times when bit value changed (1-0 or 0-1).</p>
<p>For 001 result is 2 010 - 3 011 - 2 111 - 1 </p>

<p>Definition at line <a class="el" href="a00093_source.html#l02786">2786</a> of file <a class="el" href="a00093_source.html">bmfunc.h</a>.</p>

<p>References <a class="el" href="a00092_source.html#l00159">BM_INCWORD_BITCOUNT</a>.</p>

</div>
</div>
<a class="anchor" id="ga0ff158706f2e194be67fb8267641c30a"></a><!-- doxytag: member="bm::bit_count_nonzero_size" ref="ga0ff158706f2e194be67fb8267641c30a" args="(const T *blk, unsigned data_size)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned bm::bit_count_nonzero_size </td>
          <td>(</td>
          <td class="paramtype">const T *&nbsp;</td>
          <td class="paramname"> <em>blk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>data_size</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Inspects block for full zero words. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>data</em>&nbsp;</td><td>- bit block pointer </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>data_size</em>&nbsp;</td><td>- data size</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>size of all non-zero words </dd></dl>

<p>Definition at line <a class="el" href="a00093_source.html#l04384">4384</a> of file <a class="el" href="a00093_source.html">bmfunc.h</a>.</p>

<p>References <a class="el" href="a00092_source.html#l00050">BM_ASSERT</a>.</p>

<p>Referenced by <a class="el" href="a00096_source.html#l00814">bm::serializer&lt; BV &gt;::serialize()</a>.</p>

</div>
</div>
<a class="anchor" id="gad6a7c549a625df7aa7d68d43a57238c7"></a><!-- doxytag: member="bm::bit_find_in_block" ref="gad6a7c549a625df7aa7d68d43a57238c7" args="(const bm::word_t *data, unsigned nbit, bm::id_t *prev)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int bm::bit_find_in_block </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *&nbsp;</td>
          <td class="paramname"> <em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>nbit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00115.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a> *&nbsp;</td>
          <td class="paramname"> <em>prev</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Searches for the next 1 bit in the BIT block. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>data</em>&nbsp;</td><td>- BIT buffer </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nbit</em>&nbsp;</td><td>- bit index to start checking from </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>prev</em>&nbsp;</td><td>- returns previously checked value </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="a00093_source.html#l04445">4445</a> of file <a class="el" href="a00093_source.html">bmfunc.h</a>.</p>

<p>References <a class="el" href="a00091_source.html#l00052">bm::set_block_size</a>, <a class="el" href="a00091_source.html#l00063">bm::set_word_mask</a>, and <a class="el" href="a00091_source.html#l00062">bm::set_word_shift</a>.</p>

<p>Referenced by <a class="el" href="a00096_source.html#l00814">bm::serializer&lt; BV &gt;::serialize()</a>.</p>

</div>
</div>
<a class="anchor" id="ga24be2ad5d8c2a8f18fdad142452aaae8"></a><!-- doxytag: member="bm::bit_for_each" ref="ga24be2ad5d8c2a8f18fdad142452aaae8" args="(T w, F &amp;func)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename F &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void bm::bit_for_each </td>
          <td>(</td>
          <td class="paramtype">T&nbsp;</td>
          <td class="paramname"> <em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F &amp;&nbsp;</td>
          <td class="paramname"> <em>func</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Templated algorithm to unpacks word into list of ON bit indexes. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>w</em>&nbsp;</td><td>- value </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>func</em>&nbsp;</td><td>- bit functor </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="a00093_source.html#l04562">4562</a> of file <a class="el" href="a00093_source.html">bmfunc.h</a>.</p>

<p>Referenced by <a class="el" href="a00093_source.html#l04700">bm::bit_list()</a>.</p>

</div>
</div>
<a class="anchor" id="gab9f80b3c898323ce77beb915e4c861f3"></a><!-- doxytag: member="bm::bit_for_each_4" ref="gab9f80b3c898323ce77beb915e4c861f3" args="(T w, F &amp;func)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename F &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void bm::bit_for_each_4 </td>
          <td>(</td>
          <td class="paramtype">T&nbsp;</td>
          <td class="paramname"> <em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F &amp;&nbsp;</td>
          <td class="paramname"> <em>func</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Templated algorithm to unpacks octet based word into list of ON bit indexes. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>w</em>&nbsp;</td><td>- value </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>func</em>&nbsp;</td><td>- bit functor </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="a00093_source.html#l04492">4492</a> of file <a class="el" href="a00093_source.html">bmfunc.h</a>.</p>

<p>References <a class="el" href="a00092_source.html#l00050">BM_ASSERT</a>.</p>

<p>Referenced by <a class="el" href="a00093_source.html#l04748">bm::bit_convert_to_arr()</a>, and <a class="el" href="a00093_source.html#l04685">bm::bit_list_4()</a>.</p>

</div>
</div>
<a class="anchor" id="gabdc11d48fda6a69873eefd219c4b7e75"></a><!-- doxytag: member="bm::bit_iblock_make_pcv" ref="gabdc11d48fda6a69873eefd219c4b7e75" args="(const unsigned distance[BPC][BPC], unsigned char *pc_vector)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , unsigned BPC, unsigned BPS&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void bm::bit_iblock_make_pcv </td>
          <td>(</td>
          <td class="paramtype">const unsigned&nbsp;</td>
          <td class="paramname"> <em>distance</em>[BPC][BPC], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char *&nbsp;</td>
          <td class="paramname"> <em>pc_vector</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>!&lt; ibpc limiter </p>
<p>Make a compression descriptor vector for bit-plains </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>distance</em>&nbsp;</td><td>- pairwise distance matrix </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pc_vector</em>&nbsp;</td><td>- OUT compression descriptor vector </p>
<pre>
        pc_vector[] format:
            each element (pc_vector[i]) describes the plain compression:
                first 3 bits - compression code:
                    0 - plain uncompressed
                    1 - plain is ALL ZERO (000000...)
                    2 - plain is ALL ONE  (111111...)
                    3 - plain is equal to another plain J (5 high bits (max 31))
                    4 - plain is close (but not equal) to plain J
                next 5 bits - number of plain used as a XOR expression
                 ( compression codes: 3,4 )
    </pre> </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="a00100_source.html#l00418">418</a> of file <a class="el" href="a00100_source.html">bmtrans.h</a>.</p>

<p>References <a class="el" href="a00092_source.html#l00050">BM_ASSERT</a>, <a class="el" href="a00100_source.html#l00390">bm::ibpc_all_one</a>, <a class="el" href="a00100_source.html#l00389">bm::ibpc_all_zero</a>, <a class="el" href="a00100_source.html#l00392">bm::ibpc_close</a>, <a class="el" href="a00100_source.html#l00391">bm::ibpc_equiv</a>, and <a class="el" href="a00100_source.html#l00388">bm::ibpc_uncompr</a>.</p>

<p>Referenced by <a class="el" href="a00100_source.html#l00830">bm::gap_transpose_engine&lt; GT, BT, BLOCK_SIZE &gt;::compute_distance_matrix()</a>.</p>

</div>
</div>
<a class="anchor" id="ga95854f9969985254a0f58b928da0eec6"></a><!-- doxytag: member="bm::bit_invert" ref="ga95854f9969985254a0f58b928da0eec6" args="(T *start, T *end)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void bm::bit_invert </td>
          <td>(</td>
          <td class="paramtype">T *&nbsp;</td>
          <td class="paramname"> <em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&nbsp;</td>
          <td class="paramname"> <em>end</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Function inverts block of bits </p>

<p>Definition at line <a class="el" href="a00093_source.html#l03081">3081</a> of file <a class="el" href="a00093_source.html">bmfunc.h</a>.</p>

<p>References <a class="el" href="a00098_source.html#l00216">VECT_INVERT_ARR</a>.</p>

</div>
</div>
<a class="anchor" id="gac6cfb9f92e4df6bb4c76f6efb2382860"></a><!-- doxytag: member="bm::bit_is_all_zero" ref="gac6cfb9f92e4df6bb4c76f6efb2382860" args="(const bm::wordop_t *start, const bm::wordop_t *end)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bm::bit_is_all_zero </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00115.html#a7176bf7817550ca24cb6612bd8d7957d">bm::wordop_t</a> *&nbsp;</td>
          <td class="paramname"> <em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00115.html#a7176bf7817550ca24cb6612bd8d7957d">bm::wordop_t</a> *&nbsp;</td>
          <td class="paramname"> <em>end</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns "true" if all bits in the block are 0. </p>

<p>Definition at line <a class="el" href="a00093_source.html#l03123">3123</a> of file <a class="el" href="a00093_source.html">bmfunc.h</a>.</p>

<p>Referenced by <a class="el" href="a00093_source.html#l04028">bm::bit_operation_or_any()</a>, <a class="el" href="a00093_source.html#l03966">bm::bit_operation_sub_any()</a>, <a class="el" href="a00093_source.html#l04355">bm::bit_operation_xor_any()</a>, <a class="el" href="a00089_source.html#l00366">bm::combine_any_operation_with_block()</a>, and <a class="el" href="a00087_source.html#l01914">bm::bvector&lt; Alloc &gt;::compare()</a>.</p>

</div>
</div>
<a class="anchor" id="gaae3ae537760044543f842363e4614e82"></a><!-- doxytag: member="bm::bit_list" ref="gaae3ae537760044543f842363e4614e82" args="(T w, B *bits)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename B &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned bm::bit_list </td>
          <td>(</td>
          <td class="paramtype">T&nbsp;</td>
          <td class="paramname"> <em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">B *&nbsp;</td>
          <td class="paramname"> <em>bits</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Unpacks word into list of ON bit indexes. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>w</em>&nbsp;</td><td>- value </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bits</em>&nbsp;</td><td>- pointer on the result array </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>number of bits in the list </dd></dl>

<p>Definition at line <a class="el" href="a00093_source.html#l04700">4700</a> of file <a class="el" href="a00093_source.html">bmfunc.h</a>.</p>

<p>References <a class="el" href="a00093_source.html#l04562">bm::bit_for_each()</a>, and <a class="el" href="a00093_source.html#l04588">bm::copy_to_array_functor&lt; B &gt;::ptr()</a>.</p>

</div>
</div>
<a class="anchor" id="ga3c81f6bff8866ec3ed0a94903eee96b7"></a><!-- doxytag: member="bm::bit_list_4" ref="ga3c81f6bff8866ec3ed0a94903eee96b7" args="(T w, B *bits)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename B &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned bm::bit_list_4 </td>
          <td>(</td>
          <td class="paramtype">T&nbsp;</td>
          <td class="paramname"> <em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">B *&nbsp;</td>
          <td class="paramname"> <em>bits</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Unpacks word into list of ON bit indexes (quad-bit based). </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>w</em>&nbsp;</td><td>- value </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bits</em>&nbsp;</td><td>- pointer on the result array </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>number of bits in the list </dd></dl>

<p>Definition at line <a class="el" href="a00093_source.html#l04685">4685</a> of file <a class="el" href="a00093_source.html">bmfunc.h</a>.</p>

<p>References <a class="el" href="a00093_source.html#l04492">bm::bit_for_each_4()</a>, and <a class="el" href="a00093_source.html#l04588">bm::copy_to_array_functor&lt; B &gt;::ptr()</a>.</p>

<p>Referenced by <a class="el" href="a00087_source.html#l00500">bm::bvector&lt; Alloc &gt;::enumerator::go_up()</a>.</p>

</div>
</div>
<a class="anchor" id="ga869fce5348076d4c7b92adcc2f1a49ab"></a><!-- doxytag: member="bm::bit_operation_and" ref="ga869fce5348076d4c7b92adcc2f1a49ab" args="(bm::word_t *BMRESTRICT dst, const bm::word_t *BMRESTRICT src)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a>* bm::bit_operation_and </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *BMRESTRICT&nbsp;</td>
          <td class="paramname"> <em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *BMRESTRICT&nbsp;</td>
          <td class="paramname"> <em>src</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>bitblock AND operation. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dst</em>&nbsp;</td><td>- destination block. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>src</em>&nbsp;</td><td>- source block.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>pointer on destination block. If returned value equal to src means that block mutation requested. NULL is valid return value. </dd></dl>

<p>Definition at line <a class="el" href="a00093_source.html#l03802">3802</a> of file <a class="el" href="a00093_source.html">bmfunc.h</a>.</p>

<p>References <a class="el" href="a00093_source.html#l03446">bm::bit_block_and()</a>, <a class="el" href="a00092_source.html#l00050">BM_ASSERT</a>, <a class="el" href="a00092_source.html#l00063">IS_EMPTY_BLOCK</a>, <a class="el" href="a00092_source.html#l00062">IS_FULL_BLOCK</a>, and <a class="el" href="a00092_source.html#l00061">IS_VALID_ADDR</a>.</p>

</div>
</div>
<a class="anchor" id="ga0e7995f7d6c791f6ff27a8dd21d324e5"></a><!-- doxytag: member="bm::bit_operation_and_any" ref="ga0e7995f7d6c791f6ff27a8dd21d324e5" args="(const bm::word_t *BMRESTRICT src1, const bm::word_t *BMRESTRICT src1_end, const bm::word_t *BMRESTRICT src2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00115.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a> bm::bit_operation_and_any </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *BMRESTRICT&nbsp;</td>
          <td class="paramname"> <em>src1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *BMRESTRICT&nbsp;</td>
          <td class="paramname"> <em>src1_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *BMRESTRICT&nbsp;</td>
          <td class="paramname"> <em>src2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Performs bitblock AND operation test. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>src1</em>&nbsp;</td><td>- first bit block. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>src1_end</em>&nbsp;</td><td>- first bit block end </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>src2</em>&nbsp;</td><td>- second bit block.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>non zero if there is any value </dd></dl>

<p>Definition at line <a class="el" href="a00093_source.html#l03890">3890</a> of file <a class="el" href="a00093_source.html">bmfunc.h</a>.</p>

<p>References <a class="el" href="a00093_source.html#l03530">bm::bit_block_and_any()</a>, and <a class="el" href="a00092_source.html#l00063">IS_EMPTY_BLOCK</a>.</p>

<p>Referenced by <a class="el" href="a00089_source.html#l00366">bm::combine_any_operation_with_block()</a>.</p>

</div>
</div>
<a class="anchor" id="ga9765914087df2fc22ec18db8128f2a12"></a><!-- doxytag: member="bm::bit_operation_and_count" ref="ga9765914087df2fc22ec18db8128f2a12" args="(const bm::word_t *BMRESTRICT src1, const bm::word_t *BMRESTRICT src1_end, const bm::word_t *BMRESTRICT src2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00115.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a> bm::bit_operation_and_count </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *BMRESTRICT&nbsp;</td>
          <td class="paramname"> <em>src1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *BMRESTRICT&nbsp;</td>
          <td class="paramname"> <em>src1_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *BMRESTRICT&nbsp;</td>
          <td class="paramname"> <em>src2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Performs bitblock AND operation and calculates bitcount of the result. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>src1</em>&nbsp;</td><td>- first bit block. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>src1_end</em>&nbsp;</td><td>- first bit block end </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>src2</em>&nbsp;</td><td>- second bit block.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>bitcount value </dd></dl>

<p>Definition at line <a class="el" href="a00093_source.html#l03867">3867</a> of file <a class="el" href="a00093_source.html">bmfunc.h</a>.</p>

<p>References <a class="el" href="a00093_source.html#l03480">bm::bit_block_and_count()</a>, and <a class="el" href="a00092_source.html#l00063">IS_EMPTY_BLOCK</a>.</p>

<p>Referenced by <a class="el" href="a00089_source.html#l00329">bm::combine_count_and_operation_with_block()</a>, and <a class="el" href="a00096_source.html#l02344">bm::serial_stream_iterator&lt; DEC &gt;::get_bit_block_COUNT_AND()</a>.</p>

</div>
</div>
<a class="anchor" id="ga0e945a9eaae699ad40f63b3f0632e6f9"></a><!-- doxytag: member="bm::bit_operation_or" ref="ga0e945a9eaae699ad40f63b3f0632e6f9" args="(bm::word_t *BMRESTRICT dst, const bm::word_t *BMRESTRICT src)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a>* bm::bit_operation_or </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *BMRESTRICT&nbsp;</td>
          <td class="paramname"> <em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *BMRESTRICT&nbsp;</td>
          <td class="paramname"> <em>src</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Block OR operation. Makes analysis if block is 0 or FULL. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dst</em>&nbsp;</td><td>- destination block. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>src</em>&nbsp;</td><td>- source block.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>pointer on destination block. If returned value equal to src means that block mutation requested. NULL is valid return value. </dd></dl>

<p>Definition at line <a class="el" href="a00093_source.html#l04098">4098</a> of file <a class="el" href="a00093_source.html">bmfunc.h</a>.</p>

<p>References <a class="el" href="a00093_source.html#l04060">bm::bit_block_or()</a>, <a class="el" href="a00092_source.html#l00050">BM_ASSERT</a>, <a class="el" href="a00092_source.html#l00060">FULL_BLOCK_ADDR</a>, <a class="el" href="a00092_source.html#l00062">IS_FULL_BLOCK</a>, <a class="el" href="a00092_source.html#l00061">IS_VALID_ADDR</a>, and <a class="el" href="a00091_source.html#l00052">bm::set_block_size</a>.</p>

</div>
</div>
<a class="anchor" id="ga6d26742bdc373074474a6932eab4f388"></a><!-- doxytag: member="bm::bit_operation_or_any" ref="ga6d26742bdc373074474a6932eab4f388" args="(const bm::word_t *BMRESTRICT src1, const bm::word_t *BMRESTRICT src1_end, const bm::word_t *BMRESTRICT src2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00115.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a> bm::bit_operation_or_any </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *BMRESTRICT&nbsp;</td>
          <td class="paramname"> <em>src1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *BMRESTRICT&nbsp;</td>
          <td class="paramname"> <em>src1_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *BMRESTRICT&nbsp;</td>
          <td class="paramname"> <em>src2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Performs bitblock OR operation test. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>src1</em>&nbsp;</td><td>- first bit block. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>src1_end</em>&nbsp;</td><td>- first bit block end </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>src2</em>&nbsp;</td><td>- second bit block.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>non zero value if there are any bits </dd></dl>

<p>Definition at line <a class="el" href="a00093_source.html#l04028">4028</a> of file <a class="el" href="a00093_source.html">bmfunc.h</a>.</p>

<p>References <a class="el" href="a00093_source.html#l03770">bm::bit_block_or_any()</a>, <a class="el" href="a00093_source.html#l03123">bm::bit_is_all_zero()</a>, and <a class="el" href="a00092_source.html#l00063">IS_EMPTY_BLOCK</a>.</p>

<p>Referenced by <a class="el" href="a00089_source.html#l00366">bm::combine_any_operation_with_block()</a>.</p>

</div>
</div>
<a class="anchor" id="ga5a267aff3b56cc6dadf5a3a338e00a1d"></a><!-- doxytag: member="bm::bit_operation_or_count" ref="ga5a267aff3b56cc6dadf5a3a338e00a1d" args="(const bm::word_t *BMRESTRICT src1, const bm::word_t *BMRESTRICT src1_end, const bm::word_t *BMRESTRICT src2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00115.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a> bm::bit_operation_or_count </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *BMRESTRICT&nbsp;</td>
          <td class="paramname"> <em>src1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *BMRESTRICT&nbsp;</td>
          <td class="paramname"> <em>src1_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *BMRESTRICT&nbsp;</td>
          <td class="paramname"> <em>src2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Performs bitblock OR operation and calculates bitcount of the result. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>src1</em>&nbsp;</td><td>- first bit block. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>src1_end</em>&nbsp;</td><td>- first bit block end </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>src2</em>&nbsp;</td><td>- second bit block.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>bitcount value </dd></dl>

<p>Definition at line <a class="el" href="a00093_source.html#l03996">3996</a> of file <a class="el" href="a00093_source.html">bmfunc.h</a>.</p>

<p>References <a class="el" href="a00093_source.html#l02726">bm::bit_block_calc_count()</a>, <a class="el" href="a00093_source.html#l03721">bm::bit_block_or_count()</a>, and <a class="el" href="a00092_source.html#l00063">IS_EMPTY_BLOCK</a>.</p>

<p>Referenced by <a class="el" href="a00096_source.html#l02403">bm::serial_stream_iterator&lt; DEC &gt;::get_bit_block_COUNT_OR()</a>.</p>

</div>
</div>
<a class="anchor" id="gad7afa9bce28a376360ca4826960d669f"></a><!-- doxytag: member="bm::bit_operation_sub" ref="gad7afa9bce28a376360ca4826960d669f" args="(bm::word_t *BMRESTRICT dst, const bm::word_t *BMRESTRICT src)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a>* bm::bit_operation_sub </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *BMRESTRICT&nbsp;</td>
          <td class="paramname"> <em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *BMRESTRICT&nbsp;</td>
          <td class="paramname"> <em>src</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>bitblock SUB operation. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dst</em>&nbsp;</td><td>- destination block. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>src</em>&nbsp;</td><td>- source block.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>pointer on destination block. If returned value equal to src means that block mutation requested. NULL is valid return value. </dd></dl>

<p>Definition at line <a class="el" href="a00093_source.html#l04196">4196</a> of file <a class="el" href="a00093_source.html">bmfunc.h</a>.</p>

<p>References <a class="el" href="a00093_source.html#l04156">bm::bit_block_sub()</a>, <a class="el" href="a00092_source.html#l00050">BM_ASSERT</a>, <a class="el" href="a00092_source.html#l00062">IS_FULL_BLOCK</a>, and <a class="el" href="a00092_source.html#l00061">IS_VALID_ADDR</a>.</p>

</div>
</div>
<a class="anchor" id="ga847d5a84673b284be984f0db583e2723"></a><!-- doxytag: member="bm::bit_operation_sub_any" ref="ga847d5a84673b284be984f0db583e2723" args="(const bm::word_t *BMRESTRICT src1, const bm::word_t *BMRESTRICT src1_end, const bm::word_t *BMRESTRICT src2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00115.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a> bm::bit_operation_sub_any </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *BMRESTRICT&nbsp;</td>
          <td class="paramname"> <em>src1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *BMRESTRICT&nbsp;</td>
          <td class="paramname"> <em>src1_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *BMRESTRICT&nbsp;</td>
          <td class="paramname"> <em>src2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Performs bitblock test of SUB operation. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>src1</em>&nbsp;</td><td>- first bit block. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>src1_end</em>&nbsp;</td><td>- first bit block end </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>src2</em>&nbsp;</td><td>- second bit block</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>non zero value if there are any bits </dd></dl>

<p>Definition at line <a class="el" href="a00093_source.html#l03966">3966</a> of file <a class="el" href="a00093_source.html">bmfunc.h</a>.</p>

<p>References <a class="el" href="a00093_source.html#l03691">bm::bit_block_sub_any()</a>, <a class="el" href="a00093_source.html#l03123">bm::bit_is_all_zero()</a>, and <a class="el" href="a00092_source.html#l00063">IS_EMPTY_BLOCK</a>.</p>

<p>Referenced by <a class="el" href="a00089_source.html#l00366">bm::combine_any_operation_with_block()</a>.</p>

</div>
</div>
<a class="anchor" id="gaabb39bf01bf973cb7bf3648873921ab7"></a><!-- doxytag: member="bm::bit_operation_sub_count" ref="gaabb39bf01bf973cb7bf3648873921ab7" args="(const bm::word_t *BMRESTRICT src1, const bm::word_t *BMRESTRICT src1_end, const bm::word_t *BMRESTRICT src2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00115.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a> bm::bit_operation_sub_count </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *BMRESTRICT&nbsp;</td>
          <td class="paramname"> <em>src1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *BMRESTRICT&nbsp;</td>
          <td class="paramname"> <em>src1_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *BMRESTRICT&nbsp;</td>
          <td class="paramname"> <em>src2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Performs bitblock SUB operation and calculates bitcount of the result. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>src1</em>&nbsp;</td><td>- first bit block. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>src1_end</em>&nbsp;</td><td>- first bit block end </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>src2</em>&nbsp;</td><td>- second bit block</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>bitcount value </dd></dl>

<p>Definition at line <a class="el" href="a00093_source.html#l03915">3915</a> of file <a class="el" href="a00093_source.html">bmfunc.h</a>.</p>

<p>References <a class="el" href="a00093_source.html#l02726">bm::bit_block_calc_count()</a>, <a class="el" href="a00093_source.html#l03642">bm::bit_block_sub_count()</a>, and <a class="el" href="a00092_source.html#l00063">IS_EMPTY_BLOCK</a>.</p>

<p>Referenced by <a class="el" href="a00093_source.html#l03945">bm::bit_operation_sub_count_inv()</a>, <a class="el" href="a00089_source.html#l00116">bm::combine_count_operation_with_block()</a>, <a class="el" href="a00096_source.html#l02559">bm::serial_stream_iterator&lt; DEC &gt;::get_bit_block_COUNT_SUB_AB()</a>, and <a class="el" href="a00096_source.html#l02638">bm::serial_stream_iterator&lt; DEC &gt;::get_bit_block_COUNT_SUB_BA()</a>.</p>

</div>
</div>
<a class="anchor" id="ga53867faf377db72324b858a37063c0b8"></a><!-- doxytag: member="bm::bit_operation_sub_count_inv" ref="ga53867faf377db72324b858a37063c0b8" args="(const bm::word_t *BMRESTRICT src1, const bm::word_t *BMRESTRICT src1_end, const bm::word_t *BMRESTRICT src2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00115.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a> bm::bit_operation_sub_count_inv </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *BMRESTRICT&nbsp;</td>
          <td class="paramname"> <em>src1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *BMRESTRICT&nbsp;</td>
          <td class="paramname"> <em>src1_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *BMRESTRICT&nbsp;</td>
          <td class="paramname"> <em>src2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Performs inverted bitblock SUB operation and calculates bitcount of the result. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>src1</em>&nbsp;</td><td>- first bit block. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>src1_end</em>&nbsp;</td><td>- first bit block end </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>src2</em>&nbsp;</td><td>- second bit block</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>bitcount value </dd></dl>

<p>Definition at line <a class="el" href="a00093_source.html#l03945">3945</a> of file <a class="el" href="a00093_source.html">bmfunc.h</a>.</p>

<p>References <a class="el" href="a00093_source.html#l03915">bm::bit_operation_sub_count()</a>.</p>

</div>
</div>
<a class="anchor" id="ga179de722e87ccf8189d975ca6beed025"></a><!-- doxytag: member="bm::bit_operation_xor" ref="ga179de722e87ccf8189d975ca6beed025" args="(bm::word_t *BMRESTRICT dst, const bm::word_t *BMRESTRICT src)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a>* bm::bit_operation_xor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *BMRESTRICT&nbsp;</td>
          <td class="paramname"> <em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *BMRESTRICT&nbsp;</td>
          <td class="paramname"> <em>src</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>bitblock XOR operation. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dst</em>&nbsp;</td><td>- destination block. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>src</em>&nbsp;</td><td>- source block.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>pointer on destination block. If returned value equal to src means that block mutation requested. NULL is valid return value. </dd></dl>

<p>Definition at line <a class="el" href="a00093_source.html#l04292">4292</a> of file <a class="el" href="a00093_source.html">bmfunc.h</a>.</p>

<p>References <a class="el" href="a00093_source.html#l04252">bm::bit_block_xor()</a>, <a class="el" href="a00092_source.html#l00050">BM_ASSERT</a>, and <a class="el" href="a00092_source.html#l00061">IS_VALID_ADDR</a>.</p>

</div>
</div>
<a class="anchor" id="gaa86561b6d11c3f01dd772563c692f732"></a><!-- doxytag: member="bm::bit_operation_xor_any" ref="gaa86561b6d11c3f01dd772563c692f732" args="(const bm::word_t *BMRESTRICT src1, const bm::word_t *BMRESTRICT src1_end, const bm::word_t *BMRESTRICT src2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00115.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a> bm::bit_operation_xor_any </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *BMRESTRICT&nbsp;</td>
          <td class="paramname"> <em>src1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *BMRESTRICT&nbsp;</td>
          <td class="paramname"> <em>src1_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *BMRESTRICT&nbsp;</td>
          <td class="paramname"> <em>src2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Performs bitblock XOR operation test. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>src1</em>&nbsp;</td><td>- first bit block. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>src2</em>&nbsp;</td><td>- second bit block.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>non zero value if there are bits </dd></dl>

<p>Definition at line <a class="el" href="a00093_source.html#l04355">4355</a> of file <a class="el" href="a00093_source.html">bmfunc.h</a>.</p>

<p>References <a class="el" href="a00093_source.html#l03611">bm::bit_block_xor_any()</a>, <a class="el" href="a00093_source.html#l03123">bm::bit_is_all_zero()</a>, and <a class="el" href="a00092_source.html#l00063">IS_EMPTY_BLOCK</a>.</p>

<p>Referenced by <a class="el" href="a00089_source.html#l00366">bm::combine_any_operation_with_block()</a>.</p>

</div>
</div>
<a class="anchor" id="gace08ab77feefb638daee164ee83118bc"></a><!-- doxytag: member="bm::bit_operation_xor_count" ref="gace08ab77feefb638daee164ee83118bc" args="(const bm::word_t *BMRESTRICT src1, const bm::word_t *BMRESTRICT src1_end, const bm::word_t *BMRESTRICT src2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00115.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a> bm::bit_operation_xor_count </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *BMRESTRICT&nbsp;</td>
          <td class="paramname"> <em>src1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *BMRESTRICT&nbsp;</td>
          <td class="paramname"> <em>src1_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *BMRESTRICT&nbsp;</td>
          <td class="paramname"> <em>src2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Performs bitblock XOR operation and calculates bitcount of the result. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>src1</em>&nbsp;</td><td>- first bit block. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>src2</em>&nbsp;</td><td>- second bit block.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>bitcount value </dd></dl>

<p>Definition at line <a class="el" href="a00093_source.html#l04330">4330</a> of file <a class="el" href="a00093_source.html">bmfunc.h</a>.</p>

<p>References <a class="el" href="a00093_source.html#l02726">bm::bit_block_calc_count()</a>, <a class="el" href="a00093_source.html#l03561">bm::bit_block_xor_count()</a>, and <a class="el" href="a00092_source.html#l00063">IS_EMPTY_BLOCK</a>.</p>

<p>Referenced by <a class="el" href="a00096_source.html#l02481">bm::serial_stream_iterator&lt; DEC &gt;::get_bit_block_COUNT_XOR()</a>.</p>

</div>
</div>
<a class="anchor" id="ga91fe9566575d9d66e1bb9d030b3d29a0"></a><!-- doxytag: member="bm::bitcmp" ref="ga91fe9566575d9d66e1bb9d030b3d29a0" args="(const T *buf1, const T *buf2, unsigned len)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int bm::bitcmp </td>
          <td>(</td>
          <td class="paramtype">const T *&nbsp;</td>
          <td class="paramname"> <em>buf1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&nbsp;</td>
          <td class="paramname"> <em>buf2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>len</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Lexicographical comparison of BIT buffers. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buf1</em>&nbsp;</td><td>- First buffer pointer. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>buf2</em>&nbsp;</td><td>- Second buffer pointer. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>len</em>&nbsp;</td><td>- Buffer length in elements (T). </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>&lt;0 - less, =0 - equal, &gt;0 - greater. </dd></dl>

<p>Definition at line <a class="el" href="a00093_source.html#l02489">2489</a> of file <a class="el" href="a00093_source.html">bmfunc.h</a>.</p>

<p>References <a class="el" href="a00092_source.html#l00050">BM_ASSERT</a>.</p>

<p>Referenced by <a class="el" href="a00087_source.html#l01914">bm::bvector&lt; Alloc &gt;::compare()</a>.</p>

</div>
</div>
<a class="anchor" id="gad6e40898b8836ae1923b06a3d028fcaa"></a><!-- doxytag: member="bm::gap_bitset_and_any" ref="gad6e40898b8836ae1923b06a3d028fcaa" args="(const unsigned *block, const T *buf)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00115.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a> bm::gap_bitset_and_any </td>
          <td>(</td>
          <td class="paramtype">const unsigned *&nbsp;</td>
          <td class="paramname"> <em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&nbsp;</td>
          <td class="paramname"> <em>buf</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Bitcount test of bit block AND masked by GAP block. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dest</em>&nbsp;</td><td>- bitblock buffer pointer. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>buf</em>&nbsp;</td><td>- GAP buffer pointer. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="a00093_source.html#l01837">1837</a> of file <a class="el" href="a00093_source.html">bmfunc.h</a>.</p>

<p>References <a class="el" href="a00093_source.html#l03016">bm::bit_block_any_range()</a>, and <a class="el" href="a00092_source.html#l00050">BM_ASSERT</a>.</p>

<p>Referenced by <a class="el" href="a00089_source.html#l00366">bm::combine_any_operation_with_block()</a>.</p>

</div>
</div>
<a class="anchor" id="gab87384cbf46a04d86c008ab2463d02cc"></a><!-- doxytag: member="bm::gap_bitset_and_count" ref="gab87384cbf46a04d86c008ab2463d02cc" args="(const unsigned *block, const T *buf)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00115.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a> bm::gap_bitset_and_count </td>
          <td>(</td>
          <td class="paramtype">const unsigned *&nbsp;</td>
          <td class="paramname"> <em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&nbsp;</td>
          <td class="paramname"> <em>buf</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute bitcount of bit block AND masked by GAP block. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dest</em>&nbsp;</td><td>- bitblock buffer pointer. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>buf</em>&nbsp;</td><td>- GAP buffer pointer. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="a00093_source.html#l01806">1806</a> of file <a class="el" href="a00093_source.html">bmfunc.h</a>.</p>

<p>References <a class="el" href="a00093_source.html#l02950">bm::bit_block_calc_count_range()</a>, and <a class="el" href="a00092_source.html#l00050">BM_ASSERT</a>.</p>

<p>Referenced by <a class="el" href="a00089_source.html#l00329">bm::combine_count_and_operation_with_block()</a>, and <a class="el" href="a00089_source.html#l00116">bm::combine_count_operation_with_block()</a>.</p>

</div>
</div>
<a class="anchor" id="gad15f1b92c70752cd3b97fa9e0c585f00"></a><!-- doxytag: member="bm::gap_bitset_or_any" ref="gad15f1b92c70752cd3b97fa9e0c585f00" args="(const unsigned *block, const T *buf)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00115.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a> bm::gap_bitset_or_any </td>
          <td>(</td>
          <td class="paramtype">const unsigned *&nbsp;</td>
          <td class="paramname"> <em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&nbsp;</td>
          <td class="paramname"> <em>buf</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute bitcount test of bit block OR masked by GAP block. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dest</em>&nbsp;</td><td>- bitblock buffer pointer. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>buf</em>&nbsp;</td><td>- GAP buffer pointer. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="a00093_source.html#l02075">2075</a> of file <a class="el" href="a00093_source.html">bmfunc.h</a>.</p>

<p>References <a class="el" href="a00093_source.html#l03016">bm::bit_block_any_range()</a>, and <a class="el" href="a00092_source.html#l00050">BM_ASSERT</a>.</p>

<p>Referenced by <a class="el" href="a00089_source.html#l00366">bm::combine_any_operation_with_block()</a>.</p>

</div>
</div>
<a class="anchor" id="ga23733890861063a59f787e26763a734a"></a><!-- doxytag: member="bm::gap_bitset_or_count" ref="ga23733890861063a59f787e26763a734a" args="(const unsigned *block, const T *buf)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00115.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a> bm::gap_bitset_or_count </td>
          <td>(</td>
          <td class="paramtype">const unsigned *&nbsp;</td>
          <td class="paramname"> <em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&nbsp;</td>
          <td class="paramname"> <em>buf</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute bitcount of bit block OR masked by GAP block. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dest</em>&nbsp;</td><td>- bitblock buffer pointer. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>buf</em>&nbsp;</td><td>- GAP buffer pointer. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="a00093_source.html#l02028">2028</a> of file <a class="el" href="a00093_source.html">bmfunc.h</a>.</p>

<p>References <a class="el" href="a00093_source.html#l02950">bm::bit_block_calc_count_range()</a>, and <a class="el" href="a00092_source.html#l00050">BM_ASSERT</a>.</p>

<p>Referenced by <a class="el" href="a00089_source.html#l00116">bm::combine_count_operation_with_block()</a>.</p>

</div>
</div>
<a class="anchor" id="gaab7c711122e8f189555dffd83a21111c"></a><!-- doxytag: member="bm::gap_bitset_sub_any" ref="gaab7c711122e8f189555dffd83a21111c" args="(const unsigned *block, const T *buf)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00115.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a> bm::gap_bitset_sub_any </td>
          <td>(</td>
          <td class="paramtype">const unsigned *&nbsp;</td>
          <td class="paramname"> <em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&nbsp;</td>
          <td class="paramname"> <em>buf</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute bitcount test of bit block SUB masked by GAP block. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dest</em>&nbsp;</td><td>- bitblock buffer pointer. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>buf</em>&nbsp;</td><td>- GAP buffer pointer. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="a00093_source.html#l01909">1909</a> of file <a class="el" href="a00093_source.html">bmfunc.h</a>.</p>

<p>References <a class="el" href="a00093_source.html#l03016">bm::bit_block_any_range()</a>, and <a class="el" href="a00092_source.html#l00050">BM_ASSERT</a>.</p>

<p>Referenced by <a class="el" href="a00089_source.html#l00366">bm::combine_any_operation_with_block()</a>.</p>

</div>
</div>
<a class="anchor" id="ga15a780da58d5aeb67ffc51c84fa6152e"></a><!-- doxytag: member="bm::gap_bitset_sub_count" ref="ga15a780da58d5aeb67ffc51c84fa6152e" args="(const unsigned *block, const T *buf)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00115.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a> bm::gap_bitset_sub_count </td>
          <td>(</td>
          <td class="paramtype">const unsigned *&nbsp;</td>
          <td class="paramname"> <em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&nbsp;</td>
          <td class="paramname"> <em>buf</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute bitcount of bit block SUB masked by GAP block. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dest</em>&nbsp;</td><td>- bitblock buffer pointer. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>buf</em>&nbsp;</td><td>- GAP buffer pointer. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="a00093_source.html#l01876">1876</a> of file <a class="el" href="a00093_source.html">bmfunc.h</a>.</p>

<p>References <a class="el" href="a00093_source.html#l02950">bm::bit_block_calc_count_range()</a>, and <a class="el" href="a00092_source.html#l00050">BM_ASSERT</a>.</p>

<p>Referenced by <a class="el" href="a00089_source.html#l00116">bm::combine_count_operation_with_block()</a>.</p>

</div>
</div>
<a class="anchor" id="gad0f7ee00f84ea357d55e6a2f507c8918"></a><!-- doxytag: member="bm::gap_bitset_xor_any" ref="gad0f7ee00f84ea357d55e6a2f507c8918" args="(const unsigned *block, const T *buf)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00115.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a> bm::gap_bitset_xor_any </td>
          <td>(</td>
          <td class="paramtype">const unsigned *&nbsp;</td>
          <td class="paramname"> <em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&nbsp;</td>
          <td class="paramname"> <em>buf</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute bitcount test of bit block XOR masked by GAP block. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dest</em>&nbsp;</td><td>- bitblock buffer pointer. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>buf</em>&nbsp;</td><td>- GAP buffer pointer. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="a00093_source.html#l01985">1985</a> of file <a class="el" href="a00093_source.html">bmfunc.h</a>.</p>

<p>References <a class="el" href="a00093_source.html#l03016">bm::bit_block_any_range()</a>, and <a class="el" href="a00092_source.html#l00050">BM_ASSERT</a>.</p>

<p>Referenced by <a class="el" href="a00089_source.html#l00366">bm::combine_any_operation_with_block()</a>.</p>

</div>
</div>
<a class="anchor" id="ga803fbc7c790f07b14175303e524bd2d8"></a><!-- doxytag: member="bm::gap_bitset_xor_count" ref="ga803fbc7c790f07b14175303e524bd2d8" args="(const unsigned *block, const T *buf)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00115.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a> bm::gap_bitset_xor_count </td>
          <td>(</td>
          <td class="paramtype">const unsigned *&nbsp;</td>
          <td class="paramname"> <em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&nbsp;</td>
          <td class="paramname"> <em>buf</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute bitcount of bit block XOR masked by GAP block. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dest</em>&nbsp;</td><td>- bitblock buffer pointer. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>buf</em>&nbsp;</td><td>- GAP buffer pointer. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="a00093_source.html#l01947">1947</a> of file <a class="el" href="a00093_source.html">bmfunc.h</a>.</p>

<p>References <a class="el" href="a00093_source.html#l02950">bm::bit_block_calc_count_range()</a>, and <a class="el" href="a00092_source.html#l00050">BM_ASSERT</a>.</p>

<p>Referenced by <a class="el" href="a00089_source.html#l00116">bm::combine_count_operation_with_block()</a>.</p>

</div>
</div>
<a class="anchor" id="ga97b1075250d4bf10f596ff2fbc334ceb"></a><!-- doxytag: member="bm::is_bits_one" ref="ga97b1075250d4bf10f596ff2fbc334ceb" args="(const bm::wordop_t *start, const bm::wordop_t *end)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bm::is_bits_one </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00115.html#a7176bf7817550ca24cb6612bd8d7957d">bm::wordop_t</a> *&nbsp;</td>
          <td class="paramname"> <em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00115.html#a7176bf7817550ca24cb6612bd8d7957d">bm::wordop_t</a> *&nbsp;</td>
          <td class="paramname"> <em>end</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns "true" if all bits in the block are 1. </p>

<p>Definition at line <a class="el" href="a00093_source.html#l03102">3102</a> of file <a class="el" href="a00093_source.html">bmfunc.h</a>.</p>

<p>References <a class="el" href="a00091_source.html#l00102">bm::all_bits_mask</a>.</p>

</div>
</div>
<a class="anchor" id="gad698b5242f5b629aa28e7338b7150497"></a><!-- doxytag: member="bm::or_bit_block" ref="gad698b5242f5b629aa28e7338b7150497" args="(unsigned *dest, unsigned bitpos, unsigned bitcount)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bm::or_bit_block </td>
          <td>(</td>
          <td class="paramtype">unsigned *&nbsp;</td>
          <td class="paramname"> <em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>bitpos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>bitcount</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets bits to 1 in the bitblock. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dest</em>&nbsp;</td><td>- Bitset buffer. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bitpos</em>&nbsp;</td><td>- Offset of the start bit. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bitcount</em>&nbsp;</td><td>- number of bits to set. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="a00093_source.html#l01491">1491</a> of file <a class="el" href="a00093_source.html">bmfunc.h</a>.</p>

<p>References <a class="el" href="a00091_source.html#l00054">bm::set_block_mask</a>, <a class="el" href="a00091_source.html#l00063">bm::set_word_mask</a>, and <a class="el" href="a00091_source.html#l00062">bm::set_word_shift</a>.</p>

<p>Referenced by <a class="el" href="a00093_source.html#l01733">bm::gap_add_to_bitset_l()</a>.</p>

</div>
</div>
<a class="anchor" id="ga2becf9a16ec20ab124ca8938e34b4aa8"></a><!-- doxytag: member="bm::set_bit" ref="ga2becf9a16ec20ab124ca8938e34b4aa8" args="(unsigned *dest, unsigned bitpos)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BMFORCEINLINE void bm::set_bit </td>
          <td>(</td>
          <td class="paramtype">unsigned *&nbsp;</td>
          <td class="paramname"> <em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>bitpos</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set 1 bit in a block. </p>

<p>Definition at line <a class="el" href="a00093_source.html#l01461">1461</a> of file <a class="el" href="a00093_source.html">bmfunc.h</a>.</p>

<p>References <a class="el" href="a00091_source.html#l00054">bm::set_block_mask</a>, <a class="el" href="a00091_source.html#l00063">bm::set_word_mask</a>, and <a class="el" href="a00091_source.html#l00062">bm::set_word_shift</a>.</p>

<p>Referenced by <a class="el" href="a00096_source.html#l01424">bm::deserializer&lt; BV, DEC &gt;::deserialize()</a>, and <a class="el" href="a00096_source.html#l02711">bm::serial_stream_iterator&lt; DEC &gt;::get_arr_bit()</a>.</p>

</div>
</div>
<a class="anchor" id="gaceaa54aa59b16299f5a87b925715e5e8"></a><!-- doxytag: member="bm::sub_bit_block" ref="gaceaa54aa59b16299f5a87b925715e5e8" args="(unsigned *dest, unsigned bitpos, unsigned bitcount)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bm::sub_bit_block </td>
          <td>(</td>
          <td class="paramtype">unsigned *&nbsp;</td>
          <td class="paramname"> <em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>bitpos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>bitcount</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>SUB (AND NOT) bit interval to 1 in the bitblock. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dest</em>&nbsp;</td><td>- Bitset buffer. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bitpos</em>&nbsp;</td><td>- Offset of the start bit. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bitcount</em>&nbsp;</td><td>- number of bits to set. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="a00093_source.html#l01553">1553</a> of file <a class="el" href="a00093_source.html">bmfunc.h</a>.</p>

<p>References <a class="el" href="a00091_source.html#l00054">bm::set_block_mask</a>, <a class="el" href="a00091_source.html#l00063">bm::set_word_mask</a>, and <a class="el" href="a00091_source.html#l00062">bm::set_word_shift</a>.</p>

<p>Referenced by <a class="el" href="a00093_source.html#l01777">bm::gap_and_to_bitset()</a>, and <a class="el" href="a00093_source.html#l01677">bm::gap_sub_to_bitset()</a>.</p>

</div>
</div>
<a class="anchor" id="ga9bccc586aa791f98f1bec284b799102c"></a><!-- doxytag: member="bm::test_bit" ref="ga9bccc586aa791f98f1bec284b799102c" args="(const unsigned *block, unsigned bitpos)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BMFORCEINLINE unsigned bm::test_bit </td>
          <td>(</td>
          <td class="paramtype">const unsigned *&nbsp;</td>
          <td class="paramname"> <em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>bitpos</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Test 1 bit in a block. </p>

<p>Definition at line <a class="el" href="a00093_source.html#l01474">1474</a> of file <a class="el" href="a00093_source.html">bmfunc.h</a>.</p>

<p>References <a class="el" href="a00091_source.html#l00054">bm::set_block_mask</a>, <a class="el" href="a00091_source.html#l00063">bm::set_word_mask</a>, and <a class="el" href="a00091_source.html#l00062">bm::set_word_shift</a>.</p>

</div>
</div>
<a class="anchor" id="ga3fe02492f64cd8a9dfbb1a00ec71c0ae"></a><!-- doxytag: member="bm::tmatrix_distance" ref="ga3fe02492f64cd8a9dfbb1a00ec71c0ae" args="(const T tmatrix[BPC][BPS], unsigned distance[BPC][BPC])" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , unsigned BPC, unsigned BPS&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void bm::tmatrix_distance </td>
          <td>(</td>
          <td class="paramtype">const T&nbsp;</td>
          <td class="paramname"> <em>tmatrix</em>[BPC][BPS], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>distance</em>[BPC][BPC]</td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute pairwise Row x Row Humming distances on plains(rows) of the transposed bit block. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="a00086.html" title="Mini-matrix for bit transposition purposes.">tmatrix</a></em>&nbsp;</td><td>- bit-block transposition matrix (bit-plains) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>distance</em>&nbsp;</td><td>- pairwise NxN Humming distance matrix (diagonal is popcnt) </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="a00100_source.html#l00352">352</a> of file <a class="el" href="a00100_source.html">bmtrans.h</a>.</p>

<p>References <a class="el" href="a00093_source.html#l02726">bm::bit_block_calc_count()</a>, and <a class="el" href="a00092_source.html#l00159">BM_INCWORD_BITCOUNT</a>.</p>

<p>Referenced by <a class="el" href="a00100_source.html#l00830">bm::gap_transpose_engine&lt; GT, BT, BLOCK_SIZE &gt;::compute_distance_matrix()</a>.</p>

</div>
</div>
<a class="anchor" id="gaef40342b0c318391df3db2b891acf7c1"></a><!-- doxytag: member="bm::word_bitcount" ref="gaef40342b0c318391df3db2b891acf7c1" args="(bm::id_t w)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BMFORCEINLINE <a class="el" href="a00115.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a> bm::word_bitcount </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00115.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a>&nbsp;</td>
          <td class="paramname"> <em>w</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns bit count </p>

<p>Definition at line <a class="el" href="a00093_source.html#l00165">165</a> of file <a class="el" href="a00093_source.html">bmfunc.h</a>.</p>

<p>Referenced by <a class="el" href="a00096_source.html#l02224">bm::serial_stream_iterator&lt; DEC &gt;::get_bit_block_COUNT()</a>, <a class="el" href="a00096_source.html#l02344">bm::serial_stream_iterator&lt; DEC &gt;::get_bit_block_COUNT_AND()</a>, <a class="el" href="a00096_source.html#l02403">bm::serial_stream_iterator&lt; DEC &gt;::get_bit_block_COUNT_OR()</a>, <a class="el" href="a00096_source.html#l02559">bm::serial_stream_iterator&lt; DEC &gt;::get_bit_block_COUNT_SUB_AB()</a>, <a class="el" href="a00096_source.html#l02638">bm::serial_stream_iterator&lt; DEC &gt;::get_bit_block_COUNT_SUB_BA()</a>, and <a class="el" href="a00096_source.html#l02481">bm::serial_stream_iterator&lt; DEC &gt;::get_bit_block_COUNT_XOR()</a>.</p>

</div>
</div>
<a class="anchor" id="ga5847533a73b7a5125fe5c2888ec827bd"></a><!-- doxytag: member="bm::wordcmp" ref="ga5847533a73b7a5125fe5c2888ec827bd" args="(T a, T b)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int bm::wordcmp </td>
          <td>(</td>
          <td class="paramtype">T&nbsp;</td>
          <td class="paramname"> <em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&nbsp;</td>
          <td class="paramname"> <em>b</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Lexicographical comparison of two words as bit strings. Auxiliary implementation for testing and reference purposes. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buf1</em>&nbsp;</td><td>- First word. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>buf2</em>&nbsp;</td><td>- Second word. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>&lt;0 - less, =0 - equal, &gt;0 - greater. </dd></dl>

<p>Definition at line <a class="el" href="a00093_source.html#l00371">371</a> of file <a class="el" href="a00093_source.html">bmfunc.h</a>.</p>

</div>
</div>
<a class="anchor" id="gafee2e8361c2e90a67dbaf9c7559d50e4"></a><!-- doxytag: member="bm::wordcmp0" ref="gafee2e8361c2e90a67dbaf9c7559d50e4" args="(T w1, T w2)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int bm::wordcmp0 </td>
          <td>(</td>
          <td class="paramtype">T&nbsp;</td>
          <td class="paramname"> <em>w1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&nbsp;</td>
          <td class="paramname"> <em>w2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Lexicographical comparison of two words as bit strings. Auxiliary implementation for testing and reference purposes. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buf1</em>&nbsp;</td><td>- First word. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>buf2</em>&nbsp;</td><td>- Second word. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>&lt;0 - less, =0 - equal, &gt;0 - greater. </dd></dl>

<p>Definition at line <a class="el" href="a00093_source.html#l00341">341</a> of file <a class="el" href="a00093_source.html">bmfunc.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga6191abb017003b633fab24e0c6357521"></a><!-- doxytag: member="bm::xor_bit_block" ref="ga6191abb017003b633fab24e0c6357521" args="(unsigned *dest, unsigned bitpos, unsigned bitcount)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bm::xor_bit_block </td>
          <td>(</td>
          <td class="paramtype">unsigned *&nbsp;</td>
          <td class="paramname"> <em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>bitpos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>bitcount</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>XOR bit interval to 1 in the bitblock. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dest</em>&nbsp;</td><td>- Bitset buffer. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bitpos</em>&nbsp;</td><td>- Offset of the start bit. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bitcount</em>&nbsp;</td><td>- number of bits to set. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="a00093_source.html#l01615">1615</a> of file <a class="el" href="a00093_source.html">bmfunc.h</a>.</p>

<p>References <a class="el" href="a00091_source.html#l00054">bm::set_block_mask</a>, <a class="el" href="a00091_source.html#l00063">bm::set_word_mask</a>, and <a class="el" href="a00091_source.html#l00062">bm::set_word_shift</a>.</p>

<p>Referenced by <a class="el" href="a00093_source.html#l01705">bm::gap_xor_to_bitset()</a>.</p>

</div>
</div>
</div>
<hr size="1"/><address style="text-align: right;"><small>Generated on Sun Apr 25 09:37:39 2010 for BitMagic by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
