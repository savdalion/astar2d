<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BitMagic: bm Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="namespaces.html"><span>Namespace&nbsp;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>bm Namespace Reference</h1><table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Data Structures</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00043.html">bvector</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">bitvector with runtime compression of bits.  <a href="a00043.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00042.html">bv_statistics</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Structure with statistical information about bitset's memory allocation details.  <a href="a00042.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00066.html">gap_len_table</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Default GAP lengths table.  <a href="a00066.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00067.html">gap_len_table_min</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Alternative GAP lengths table. Good for for memory saver mode and very sparse bitsets.  <a href="a00067.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00040.html">block_set_table</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Structure keeps all-left/right ON bits masks.  <a href="a00040.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00011.html">all_set</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Structure carries pointer on bit block with all bits 1.  <a href="a00011.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00010.html">_copyright</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Internal structure.  <a href="a00010.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00069.html">globals</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Internal structure.  <a href="a00069.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00049.html">d_copy_func</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">d-Gap copy functor  <a href="a00049.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00046.html">copy_to_array_functor</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adaptor to copy 1 bits to array.  <a href="a00046.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00047.html">copy_to_array_functor_inc</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adaptor to copy 1 bits to array with base increment.  <a href="a00047.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00035.html">bitblock_get_adapter</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Bit-block get adapter, takes bitblock and represents it as a <a class="el" href="a00035.html#a5fd937c34bcb5e5a2f6aa25333480db2">get_32()</a> accessor function /internal.  <a href="a00035.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00036.html">bitblock_store_adapter</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Bit-block store adapter, takes bitblock and saves results into it /internal.  <a href="a00036.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00037.html">bitblock_sum_adapter</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Bit-block sum adapter, takes values and sums it /internal.  <a href="a00037.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00056.html">decoder_range_adapter</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adapter to get words from a range stream (see range serialized bit-block).  <a href="a00056.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00013.html">bit_AND</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Bit AND functor.  <a href="a00013.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00029.html">bit_OR</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Bit OR functor.  <a href="a00029.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00031.html">bit_SUB</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Bit SUB functor.  <a href="a00031.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00033.html">bit_XOR</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Bit XOR functor.  <a href="a00033.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00014.html">bit_ASSIGN</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Bit ASSIGN functor.  <a href="a00014.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00015.html">bit_COUNT</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Bit COUNT functor.  <a href="a00015.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00017.html">bit_COUNT_AND</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Bit COUNT AND functor.  <a href="a00017.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00023.html">bit_COUNT_XOR</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Bit COUNT XOR functor.  <a href="a00023.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00019.html">bit_COUNT_OR</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Bit COUNT OR functor.  <a href="a00019.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00020.html">bit_COUNT_SUB_AB</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Bit COUNT SUB AB functor.  <a href="a00020.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00021.html">bit_COUNT_SUB_BA</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Bit SUB BA functor.  <a href="a00021.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00016.html">bit_COUNT_A</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Bit COUNT A functor.  <a href="a00016.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00018.html">bit_COUNT_B</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Bit COUNT B functor.  <a href="a00018.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00076.html">operation_functions</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00074.html">miniset</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Template class implements memory saving set functionality.  <a href="a00074.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00045.html">bvmini</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Mini bitvector used in <a class="el" href="a00043.html" title="bitvector with runtime compression of bits.">bvector</a> template to keep block type flags.  <a href="a00045.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00044.html">bvector_mini</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Bitvector class with very limited functionality.  <a href="a00044.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00061.html">encoder</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Memory encoding.  <a href="a00061.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00054.html">decoder_base</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Base class for all decoding functionality.  <a href="a00054.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00053.html">decoder</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Class for decoding data from memory buffer.  <a href="a00053.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00055.html">decoder_little_endian</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Class for decoding data from memory buffer.  <a href="a00055.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00030.html">bit_out</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Byte based writer for un-aligned bit streaming.  <a href="a00030.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00028.html">bit_in</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Byte based reader for un-aligned bit streaming.  <a href="a00028.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00065.html">gamma_encoder</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Functor for Elias Gamma encoding.  <a href="a00065.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00064.html">gamma_decoder</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Elias Gamma <a class="el" href="a00053.html" title="Class for decoding data from memory buffer.">decoder</a>.  <a href="a00064.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00052.html">DeBruijn_bit_position</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00063.html">first_bit_table</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Structure keeps index of first right 1 bit for every byte.  <a href="a00063.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00022.html">bit_count_table</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Structure to aid in counting bits table contains count of bits in 0-255 diapason of numbers.  <a href="a00022.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00084.html">sse_empty_guard</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">SSE2 reinitialization guard class.  <a href="a00084.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00060.html">distance_metric_descriptor</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Distance metric descriptor, holds metric code and result.  <a href="a00060.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00086.html">tmatrix</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Mini-matrix for bit transposition purposes.  <a href="a00086.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00024.html">bit_grabber</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00027.html">bit_grabber&lt; unsigned, 32 &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00026.html">bit_grabber&lt; unsigned short, 16 &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00025.html">bit_grabber&lt; unsigned char, 8 &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00032.html">bit_trans_grabber</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00068.html">gap_transpose_engine</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Bit-plain splicing of a GAP block.  <a href="a00068.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00078.html">ptr_guard</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Mini auto-pointer for internal memory management.  <a href="a00078.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00083.html">serializer</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Bit-vector serialization class.  <a href="a00083.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00057.html">deseriaizer_base</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Base deserialization class.  <a href="a00057.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00058.html">deserializer</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Class <a class="el" href="a00058.html" title="Class deserializer.">deserializer</a>.  <a href="a00058.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00072.html">iterator_deserializer</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Iterator to walk forward the serialized stream.  <a href="a00072.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00082.html">serial_stream_iterator</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Serialization stream iterator.  <a href="a00082.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00075.html">operation_deserializer</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Class <a class="el" href="a00058.html" title="Class deserializer.">deserializer</a>, can perform logical operation on bit-vector and serialized bit-vector.  <a href="a00075.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00038.html">block_allocator</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Default malloc based bitblock allocator class.  <a href="a00038.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00077.html">ptr_allocator</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Default malloc based bitblock allocator class.  <a href="a00077.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00073.html">mem_alloc</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">BM style allocator adapter.  <a href="a00073.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00079.html">random_subset</a></td></tr>
<tr><td colspan="2"><h2>Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef void(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00115.html#a18a8f03b151ca3a6d5e39e7709fb6c7c">gap_operation_to_bitset_func_type</a> )(unsigned *, const <a class="el" href="a00115.html#ac654d6319039a86546d235a236fc7cf6">gap_word_t</a> *)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="a00115.html#ac654d6319039a86546d235a236fc7cf6">gap_word_t</a> *(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00115.html#a8402de852093e5b23b5825f1974b9c12">gap_operation_func_type</a> )(const <a class="el" href="a00115.html#ac654d6319039a86546d235a236fc7cf6">gap_word_t</a> *BMRESTRICT, const <a class="el" href="a00115.html#ac654d6319039a86546d235a236fc7cf6">gap_word_t</a> *BMRESTRICT, <a class="el" href="a00115.html#ac654d6319039a86546d235a236fc7cf6">gap_word_t</a> *BMRESTRICT, unsigned &amp;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="a00115.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a>(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00115.html#ad93f96a77f223240b8c6b8f81c5db840">bit_operation_count_func_type</a> )(const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *BMRESTRICT, const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *BMRESTRICT, const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *BMRESTRICT)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="a00053.html">decoder</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00115.html#ac36d9b78ebf78baf0b92dc61487d9847">decoder_big_endian</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Class for decoding data from memory buffer.  <a href="#ac36d9b78ebf78baf0b92dc61487d9847"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef unsigned long long&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00115.html#a1f6a6dd108cd9e9f4fb284043ef518fe">id64_t</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00115.html#aa3824d882a037396370b16f2f0a8bf37">id_t</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">word_t</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef unsigned short&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00115.html#ae64960202b691ae1b6efe5fec12cb5af">short_t</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef unsigned short&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00115.html#ac654d6319039a86546d235a236fc7cf6">gap_word_t</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">word_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00115.html#a7176bf7817550ca24cb6612bd8d7957d">wordop_t</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="a00073.html">mem_alloc</a><br class="typebreak"/>
&lt; <a class="el" href="a00038.html">block_allocator</a>, <br class="typebreak"/>
<a class="el" href="a00077.html">ptr_allocator</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00127.html#gab9059bfb40a6588cdbacfd93901593c1">standard_allocator</a></td></tr>
<tr><td colspan="2"><h2>Enumerations</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00115.html#a76b70d2b9182a6dcac151d1bd9ec6109">set_operation</a> { <br/>
&nbsp;&nbsp;<a class="el" href="a00115.html#a76b70d2b9182a6dcac151d1bd9ec6109a949fba4d9b152e1cbba9a450e05e21a3">set_AND</a> =  0, 
<a class="el" href="a00115.html#a76b70d2b9182a6dcac151d1bd9ec6109a05d88a2639cbd3d2ac63436df3ed6780">set_OR</a> =  1, 
<a class="el" href="a00115.html#a76b70d2b9182a6dcac151d1bd9ec6109a348f23af148237ac49194815b222b769">set_SUB</a> =  2, 
<a class="el" href="a00115.html#a76b70d2b9182a6dcac151d1bd9ec6109ab823123a0d630167532a96be004e6304">set_XOR</a> =  3, 
<br/>
&nbsp;&nbsp;<a class="el" href="a00115.html#a76b70d2b9182a6dcac151d1bd9ec6109a34150dd6a8ac2e70b887565bd1c3f788">set_ASSIGN</a> =  4, 
<a class="el" href="a00115.html#a76b70d2b9182a6dcac151d1bd9ec6109a3f165b7944e33214e8721aaf2eb8378e">set_COUNT</a> =  5, 
<a class="el" href="a00115.html#a76b70d2b9182a6dcac151d1bd9ec6109a378be4b14cee6a341e859fd3157ab959">set_COUNT_AND</a> =  6, 
<a class="el" href="a00115.html#a76b70d2b9182a6dcac151d1bd9ec6109a1373054e4f243dffb762a55b8a8bfe4c">set_COUNT_XOR</a> =  7, 
<br/>
&nbsp;&nbsp;<a class="el" href="a00115.html#a76b70d2b9182a6dcac151d1bd9ec6109a27e34c148d06e3d8a405482d820cd7fb">set_COUNT_OR</a> =  8, 
<a class="el" href="a00115.html#a76b70d2b9182a6dcac151d1bd9ec6109a0028cc7084b37fe66ce5ae459b93b7f1">set_COUNT_SUB_AB</a> =  9, 
<a class="el" href="a00115.html#a76b70d2b9182a6dcac151d1bd9ec6109a2f7b894c11c058598d02722a7eeef03b">set_COUNT_SUB_BA</a> =  10, 
<a class="el" href="a00115.html#a76b70d2b9182a6dcac151d1bd9ec6109abafe8a971864164aeec7f43d1205ed29">set_COUNT_A</a> =  11, 
<br/>
&nbsp;&nbsp;<a class="el" href="a00115.html#a76b70d2b9182a6dcac151d1bd9ec6109a2ac4eb7f41d00f8387d5dd3ffb9d0617">set_COUNT_B</a> =  12, 
<a class="el" href="a00115.html#a76b70d2b9182a6dcac151d1bd9ec6109ad894d257a23664720dbf4155153a1e5c">set_END</a>
<br/>
 }</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>Nomenclature of set operations. </p>
 <a href="a00115.html#a76b70d2b9182a6dcac151d1bd9ec6109">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00115.html#a42405343976ec931388381cea4092bf1">operation</a> { <a class="el" href="a00115.html#a42405343976ec931388381cea4092bf1a546fdf33b301e5b9bee0591522ed9250">BM_AND</a> =  set_AND, 
<a class="el" href="a00115.html#a42405343976ec931388381cea4092bf1a0c8cf0197857d0bd73a63037e2f2c5c5">BM_OR</a> =  set_OR, 
<a class="el" href="a00115.html#a42405343976ec931388381cea4092bf1a1df0f4de7126bb2f7ce69d7a005affb5">BM_SUB</a> =  set_SUB, 
<a class="el" href="a00115.html#a42405343976ec931388381cea4092bf1a45c2fe36efb72dc03f03a842d253f64c">BM_XOR</a> =  set_XOR
 }</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>Bit operations enumeration. </p>
 <a href="a00115.html#a42405343976ec931388381cea4092bf1">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00115.html#a577905b348676c2bc556b51793350dbb">ByteOrder</a> { <a class="el" href="a00115.html#a577905b348676c2bc556b51793350dbbac959b97503c42581f3dd81fd3b93fff2">BigEndian</a> =  0, 
<a class="el" href="a00115.html#a577905b348676c2bc556b51793350dbba5ebe266b6d18ee74483c2bbf624e2cc2">LittleEndian</a> =  1
 }</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>Byte orders recognized by the library. </p>
 <a href="a00115.html#a577905b348676c2bc556b51793350dbb">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00118.html#gad0b87b3b7292383a864d27feaf1c9eff">strategy</a> { <a class="el" href="a00118.html#ggad0b87b3b7292383a864d27feaf1c9effa40920ae0ef7b4411d60463d8f576b5ba">BM_BIT</a> =  0, 
<a class="el" href="a00118.html#ggad0b87b3b7292383a864d27feaf1c9effa7fe09d1d7c62a813db922c396c0cbc9c">BM_GAP</a> =  1
 }</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>Block allocation strategies. </p>
 <a href="a00118.html#gad0b87b3b7292383a864d27feaf1c9eff">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00115.html#a593916a103395805070a3200720c6416">set_representation</a> { <a class="el" href="a00115.html#a593916a103395805070a3200720c6416a11f970b705c57a0572043e5cc5e2e333">set_bitset</a> =  0, 
<a class="el" href="a00115.html#a593916a103395805070a3200720c6416a4809f1871df2ba431e5b70d175f050ec">set_gap</a> =  1, 
<a class="el" href="a00115.html#a593916a103395805070a3200720c6416a4bd710c312645ed34e4db359a7e59c42">set_array1</a> =  2, 
<a class="el" href="a00115.html#a593916a103395805070a3200720c6416a8d71ac8a4f70b88d2a425d0c1e872fa2">set_array0</a> =  3
 }</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>set representation variants </p>
 <a href="a00115.html#a593916a103395805070a3200720c6416">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00125.html#gac38d64c8b27b652413a664cddd4d40ab">distance_metric</a> { <br/>
&nbsp;&nbsp;<a class="el" href="a00125.html#ggac38d64c8b27b652413a664cddd4d40abacb39376469ba778e9a9099ddbae5e7ce">COUNT_AND</a> =  set_COUNT_AND, 
<a class="el" href="a00125.html#ggac38d64c8b27b652413a664cddd4d40aba3e4861dde6e1179457ee0d3502ae8061">COUNT_XOR</a> =  set_COUNT_XOR, 
<a class="el" href="a00125.html#ggac38d64c8b27b652413a664cddd4d40abad0bd2d56c8ebd03f55c01b3cc6faaaeb">COUNT_OR</a> =  set_COUNT_OR, 
<a class="el" href="a00125.html#ggac38d64c8b27b652413a664cddd4d40aba9c101dab8904c0432f72ccce0a207e62">COUNT_SUB_AB</a> =  set_COUNT_SUB_AB, 
<br/>
&nbsp;&nbsp;<a class="el" href="a00125.html#ggac38d64c8b27b652413a664cddd4d40abafa036fb9d54bc659ed3c9e4185ccf400">COUNT_SUB_BA</a> =  set_COUNT_SUB_BA, 
<a class="el" href="a00125.html#ggac38d64c8b27b652413a664cddd4d40abaac7947d53eb3acf81251ee4130e6a4a2">COUNT_A</a> =  set_COUNT_A, 
<a class="el" href="a00125.html#ggac38d64c8b27b652413a664cddd4d40abac6dbadf2ab9405daa47dc0f10d082516">COUNT_B</a> =  set_COUNT_B
<br/>
 }</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>Distance metrics codes defined for vectors A and B. </p>
 <a href="a00125.html#gac38d64c8b27b652413a664cddd4d40ab">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00115.html#ab69f66b71d349b0757370f54318bb2c0">serialization_header_mask</a> { <br/>
&nbsp;&nbsp;<a class="el" href="a00115.html#ab69f66b71d349b0757370f54318bb2c0a97434d6617bb5f0d6f3bf44491f712ca">BM_HM_DEFAULT</a> =  1, 
<a class="el" href="a00115.html#ab69f66b71d349b0757370f54318bb2c0af4fbefa0ed0a8ff42dd664f120782c27">BM_HM_RESIZE</a> =  (1 &lt;&lt; 1), 
<a class="el" href="a00115.html#ab69f66b71d349b0757370f54318bb2c0a64c44c57a6f8b8e89f0916db9e120d47">BM_HM_ID_LIST</a> =  (1 &lt;&lt; 2), 
<a class="el" href="a00115.html#ab69f66b71d349b0757370f54318bb2c0a6b127bde401907318702dd4827c8f74e">BM_HM_NO_BO</a> =  (1 &lt;&lt; 3), 
<br/>
&nbsp;&nbsp;<a class="el" href="a00115.html#ab69f66b71d349b0757370f54318bb2c0a04c714af376c203bc8b082856ad622a3">BM_HM_NO_GAPL</a> =  (1 &lt;&lt; 4)
<br/>
 }</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00126.html#ga537dfe6318f1f1fe18d86dac312be978">serialization_flags</a> { <a class="el" href="a00126.html#gga537dfe6318f1f1fe18d86dac312be978acdd8c071c079589388c3ca7bd4f367c8">BM_NO_BYTE_ORDER</a> =  1, 
<a class="el" href="a00126.html#gga537dfe6318f1f1fe18d86dac312be978a5521473081d341bc32ac59538e6a8096">BM_NO_GAP_LENGTH</a> =  (1 &lt;&lt; 1)
 }</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>Bit mask flags for serialization algorithm. </p>
 <a href="a00126.html#ga537dfe6318f1f1fe18d86dac312be978">More...</a><br/></td></tr>
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class Alloc &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00043.html">bvector</a>&lt; Alloc &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00115.html#a9642fa6fb00fb9de2406e1eaea44b88d">operator&amp;</a> (const <a class="el" href="a00043.html">bvector</a>&lt; Alloc &gt; &amp;v1, const <a class="el" href="a00043.html">bvector</a>&lt; Alloc &gt; &amp;v2)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class Alloc &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00043.html">bvector</a>&lt; Alloc &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00115.html#acc5d3d9d78d8edbc6dba501c479c789e">operator|</a> (const <a class="el" href="a00043.html">bvector</a>&lt; Alloc &gt; &amp;v1, const <a class="el" href="a00043.html">bvector</a>&lt; Alloc &gt; &amp;v2)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class Alloc &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00043.html">bvector</a>&lt; Alloc &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00115.html#aeaf93e15a099b98ae8e314142c70f63a">operator^</a> (const <a class="el" href="a00043.html">bvector</a>&lt; Alloc &gt; &amp;v1, const <a class="el" href="a00043.html">bvector</a>&lt; Alloc &gt; &amp;v2)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class Alloc &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00043.html">bvector</a>&lt; Alloc &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00115.html#ac7b828f11454f40bcd07e6abc60990f2">operator-</a> (const <a class="el" href="a00043.html">bvector</a>&lt; Alloc &gt; &amp;v1, const <a class="el" href="a00043.html">bvector</a>&lt; Alloc &gt; &amp;v2)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">BMFORCEINLINE <a class="el" href="a00115.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00120.html#gaef40342b0c318391df3db2b891acf7c1">word_bitcount</a> (<a class="el" href="a00115.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a> w)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00115.html#a30cec2c137813460f4b4c65c5879a4c3">parallel_popcnt_32</a> (unsigned int n)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00115.html#a3deb310cdf11bca948817f94adfec160">is_const_set_operation</a> (<a class="el" href="a00115.html#a76b70d2b9182a6dcac151d1bd9ec6109">set_operation</a> op)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns true if set operation is constant (bitcount).  <a href="#a3deb310cdf11bca948817f94adfec160"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00115.html#a42405343976ec931388381cea4092bf1">bm::operation</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00115.html#a7c192b64adb0590a09b5c2dad77c4b76">setop2op</a> (<a class="el" href="a00115.html#a76b70d2b9182a6dcac151d1bd9ec6109">bm::set_operation</a> op)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convert set operation to operation.  <a href="#a7c192b64adb0590a09b5c2dad77c4b76"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename W &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00115.html#afb2c1acc56270abb381741a709a2b17c">xor_swap</a> (W &amp;x, W &amp;y)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">XOR swap two scalar variables.  <a href="#afb2c1acc56270abb381741a709a2b17c"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">int&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00120.html#gafee2e8361c2e90a67dbaf9c7559d50e4">wordcmp0</a> (T w1, T w2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Lexicographical comparison of two words as bit strings. Auxiliary implementation for testing and reference purposes.  <a href="a00120.html#gafee2e8361c2e90a67dbaf9c7559d50e4"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">int&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00120.html#ga5847533a73b7a5125fe5c2888ec827bd">wordcmp</a> (T a, T b)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Lexicographical comparison of two words as bit strings. Auxiliary implementation for testing and reference purposes.  <a href="a00120.html#ga5847533a73b7a5125fe5c2888ec827bd"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">unsigned&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00115.html#acebed8b533c2c9e17167617501477693">gap_bfind</a> (const T *buf, unsigned pos, unsigned *is_set)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">unsigned&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00119.html#ga866352ef5986a7d2b709795d127b666b">gap_test</a> (const T *buf, unsigned pos)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Tests if bit = pos is true.  <a href="a00119.html#ga866352ef5986a7d2b709795d127b666b"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T , class F &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00115.html#a46953a43cfc3da7192d883b6dd822d99">for_each_nzblock</a> (T ***root, unsigned size1, F &amp;f)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T , class F &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00115.html#ac6f5529fcc26412fc796b85770aa3a26">for_each_nzblock2</a> (T ***root, unsigned size1, F &amp;f)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T , class F &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00115.html#a5b4e99c8ed7b929be87bd5a1ad76fd37">for_each_nzblock_if</a> (T ***root, unsigned size1, F &amp;f)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T , class F &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00115.html#a8abecc773e9aaee744215278d1e6924e">for_each_block</a> (T ***root, unsigned size1, F &amp;f)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T , class F &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">F&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00115.html#abf587377ca70f11b8eb75f95494830b5">bmfor_each</a> (T first, T last, F f)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">T&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00115.html#ac8f3443ba8fcd1b28face4b09dfd21bf">sum_arr</a> (T *first, T *last)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">unsigned&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00119.html#ga570a6f573ffb9ac9e41a688d2bdc6004">gap_bit_count</a> (const T *buf, unsigned dsize=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Calculates number of bits ON in GAP buffer.  <a href="a00119.html#ga570a6f573ffb9ac9e41a688d2bdc6004"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">unsigned&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00115.html#a7324ebded429e15361f62117a2ff18d1">gap_bit_count_range</a> (const T *buf, T left, T right)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Counts 1 bits in GAP buffer in the closed [left, right] diapason.  <a href="#a7324ebded429e15361f62117a2ff18d1"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T , class Func &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00115.html#a6a7bfe8af49ed785f0e96c7ca37a2155">for_each_dgap</a> (const T *gap_buf, Func &amp;func)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">T *&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00115.html#afa6ea0cce0cdd88738a01fad393376b3">gap_2_dgap</a> (const T *gap_buf, T *dgap_buf, bool copy_head=true)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convert GAP buffer into D-GAP buffer.  <a href="#afa6ea0cce0cdd88738a01fad393376b3"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00115.html#a528894002dcd8edda28c8fb2b0aa8c64">dgap_2_gap</a> (const T *dgap_buf, T *gap_buf, T gap_header=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convert D-GAP buffer into GAP buffer.  <a href="#a528894002dcd8edda28c8fb2b0aa8c64"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">int&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00119.html#ga406952734f1b05962941b32e37b3eb96">gapcmp</a> (const T *buf1, const T *buf2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Lexicographical comparison of GAP buffers.  <a href="a00119.html#ga406952734f1b05962941b32e37b3eb96"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T , class F &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00115.html#aac0daaac2b5a7c88e6be726c77f52c68">gap_buff_op</a> (T *BMRESTRICT dest, const T *BMRESTRICT vect1, unsigned vect1_mask, const T *BMRESTRICT vect2, unsigned vect2_mask, F &amp;f, unsigned &amp;dlen)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Abstract operation for GAP buffers. Receives functor F as a template argument.  <a href="#aac0daaac2b5a7c88e6be726c77f52c68"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T , class F &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">unsigned&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00119.html#ga5e3123c3c9d3587f470abdbe6c8c3ad3">gap_buff_any_op</a> (const T *BMRESTRICT vect1, unsigned vect1_mask, const T *BMRESTRICT vect2, unsigned vect2_mask, F f)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Abstract distance test operation for GAP buffers. Receives functor F as a template argument.  <a href="a00119.html#ga5e3123c3c9d3587f470abdbe6c8c3ad3"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T , class F &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">unsigned&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00119.html#ga9a5ff7782f3de0d1c699eb72d432f255">gap_buff_count_op</a> (const T *vect1, const T *vect2, F f)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Abstract distance(similarity) operation for GAP buffers. Receives functor F as a template argument.  <a href="a00119.html#ga9a5ff7782f3de0d1c699eb72d432f255"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">unsigned&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00119.html#ga69186bd13bda27e04b3e33683ff884c2">gap_set_value</a> (unsigned val, T *BMRESTRICT buf, unsigned pos, unsigned *BMRESTRICT is_set)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets or clears bit in the GAP buffer.  <a href="a00119.html#ga69186bd13bda27e04b3e33683ff884c2"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">unsigned&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00119.html#gadae4001e2834125b9c08b154a8a874a7">gap_add_value</a> (T *buf, T pos)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add new value to the end of GAP buffer.  <a href="a00119.html#gadae4001e2834125b9c08b154a8a874a7"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">unsigned&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00119.html#ga550394048c163d41a135fb9068f2251b">gap_set_array</a> (T *buf, const T *arr, unsigned len)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convert array to GAP buffer.  <a href="a00119.html#ga550394048c163d41a135fb9068f2251b"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">unsigned&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00119.html#ga68e53a96e93a31e8a323d10c7a2f21f5">bit_array_compute_gaps</a> (const T *arr, unsigned len)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute number of GAPs in bit-array.  <a href="a00119.html#ga68e53a96e93a31e8a323d10c7a2f21f5"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">int&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00119.html#gaa7df7193094353ea24b8519debf745be">gap_find_in_block</a> (const T *buf, unsigned nbit, <a class="el" href="a00115.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a> *prev)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Searches for the next 1 bit in the GAP block.  <a href="a00119.html#gaa7df7193094353ea24b8519debf745be"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">BMFORCEINLINE void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00120.html#ga2becf9a16ec20ab124ca8938e34b4aa8">set_bit</a> (unsigned *dest, unsigned bitpos)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set 1 bit in a block.  <a href="a00120.html#ga2becf9a16ec20ab124ca8938e34b4aa8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">BMFORCEINLINE unsigned&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00120.html#ga9bccc586aa791f98f1bec284b799102c">test_bit</a> (const unsigned *block, unsigned bitpos)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Test 1 bit in a block.  <a href="a00120.html#ga9bccc586aa791f98f1bec284b799102c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00120.html#gad698b5242f5b629aa28e7338b7150497">or_bit_block</a> (unsigned *dest, unsigned bitpos, unsigned bitcount)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets bits to 1 in the bitblock.  <a href="a00120.html#gad698b5242f5b629aa28e7338b7150497"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00120.html#gaceaa54aa59b16299f5a87b925715e5e8">sub_bit_block</a> (unsigned *dest, unsigned bitpos, unsigned bitcount)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">SUB (AND NOT) bit interval to 1 in the bitblock.  <a href="a00120.html#gaceaa54aa59b16299f5a87b925715e5e8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00120.html#ga6191abb017003b633fab24e0c6357521">xor_bit_block</a> (unsigned *dest, unsigned bitpos, unsigned bitcount)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">XOR bit interval to 1 in the bitblock.  <a href="a00120.html#ga6191abb017003b633fab24e0c6357521"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00119.html#gabcedad4aea1a503c30f10e6d09b523f2">gap_sub_to_bitset</a> (unsigned *BMRESTRICT dest, const T *BMRESTRICT buf)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">SUB (AND NOT) GAP block to bitblock.  <a href="a00119.html#gabcedad4aea1a503c30f10e6d09b523f2"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00119.html#ga63c33428c2f5eac9f69d663203cd2172">gap_xor_to_bitset</a> (unsigned *BMRESTRICT dest, const T *BMRESTRICT buf)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">XOR GAP block to bitblock.  <a href="a00119.html#ga63c33428c2f5eac9f69d663203cd2172"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00119.html#ga78510a39b6e8c6b8904ecbffb6ab215b">gap_add_to_bitset_l</a> (unsigned *dest, const T *buf, unsigned buf_len)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds(OR) GAP block to bitblock.  <a href="a00119.html#ga78510a39b6e8c6b8904ecbffb6ab215b"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00119.html#ga12615cd62f2e5367e1bc688d00a2188f">gap_add_to_bitset</a> (unsigned *dest, const T *buf)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds(OR) GAP block to bitblock.  <a href="a00119.html#ga12615cd62f2e5367e1bc688d00a2188f"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00119.html#gafe6f72a009618290eeab3cddee869543">gap_and_to_bitset</a> (unsigned *dest, const T *buf)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">ANDs GAP block to bitblock.  <a href="a00119.html#gafe6f72a009618290eeab3cddee869543"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00115.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00120.html#gab87384cbf46a04d86c008ab2463d02cc">gap_bitset_and_count</a> (const unsigned *block, const T *buf)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute bitcount of bit block AND masked by GAP block.  <a href="a00120.html#gab87384cbf46a04d86c008ab2463d02cc"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00115.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00120.html#gad6e40898b8836ae1923b06a3d028fcaa">gap_bitset_and_any</a> (const unsigned *block, const T *buf)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Bitcount test of bit block AND masked by GAP block.  <a href="a00120.html#gad6e40898b8836ae1923b06a3d028fcaa"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00115.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00120.html#ga15a780da58d5aeb67ffc51c84fa6152e">gap_bitset_sub_count</a> (const unsigned *block, const T *buf)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute bitcount of bit block SUB masked by GAP block.  <a href="a00120.html#ga15a780da58d5aeb67ffc51c84fa6152e"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00115.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00120.html#gaab7c711122e8f189555dffd83a21111c">gap_bitset_sub_any</a> (const unsigned *block, const T *buf)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute bitcount test of bit block SUB masked by GAP block.  <a href="a00120.html#gaab7c711122e8f189555dffd83a21111c"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00115.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00120.html#ga803fbc7c790f07b14175303e524bd2d8">gap_bitset_xor_count</a> (const unsigned *block, const T *buf)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute bitcount of bit block XOR masked by GAP block.  <a href="a00120.html#ga803fbc7c790f07b14175303e524bd2d8"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00115.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00120.html#gad0f7ee00f84ea357d55e6a2f507c8918">gap_bitset_xor_any</a> (const unsigned *block, const T *buf)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute bitcount test of bit block XOR masked by GAP block.  <a href="a00120.html#gad0f7ee00f84ea357d55e6a2f507c8918"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00115.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00120.html#ga23733890861063a59f787e26763a734a">gap_bitset_or_count</a> (const unsigned *block, const T *buf)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute bitcount of bit block OR masked by GAP block.  <a href="a00120.html#ga23733890861063a59f787e26763a734a"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00115.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00120.html#gad15f1b92c70752cd3b97fa9e0c585f00">gap_bitset_or_any</a> (const unsigned *block, const T *buf)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute bitcount test of bit block OR masked by GAP block.  <a href="a00120.html#gad15f1b92c70752cd3b97fa9e0c585f00"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00120.html#gaada8b13c35acd8df90129b45edcfc5de">bit_block_set</a> (<a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *BMRESTRICT dst, <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> value)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Bitblock memset operation.  <a href="a00120.html#gaada8b13c35acd8df90129b45edcfc5de"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00119.html#ga4862f4dcdcb7c0575e2e2db9e5f2a849">gap_convert_to_bitset</a> (unsigned *dest, const T *buf)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">GAP block to bitblock conversion.  <a href="a00119.html#ga4862f4dcdcb7c0575e2e2db9e5f2a849"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00119.html#ga1dd58e3576239c49010b62a3add42417">gap_convert_to_bitset_l</a> (unsigned *dest, const T *buf, unsigned buf_len)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">GAP block to bitblock conversion.  <a href="a00119.html#ga1dd58e3576239c49010b62a3add42417"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00119.html#ga9bb80c42ee0ecf8f2af8250d7f5d327b">gap_convert_to_bitset</a> (unsigned *dest, const T *buf, unsigned dest_len)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">GAP block to bitblock conversion.  <a href="a00119.html#ga9bb80c42ee0ecf8f2af8250d7f5d327b"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">unsigned *&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00119.html#ga3f01bb7c1ae7983aa8c4ba82e1e3f54c">gap_convert_to_bitset_smart</a> (unsigned *dest, const T *buf, <a class="el" href="a00115.html#aa3824d882a037396370b16f2f0a8bf37">id_t</a> set_max)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Smart GAP block to bitblock conversion.  <a href="a00119.html#ga3f01bb7c1ae7983aa8c4ba82e1e3f54c"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">unsigned&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00119.html#ga14d29338ffd1387758810b3f9e3a72c6">gap_control_sum</a> (const T *buf)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Calculates sum of all words in GAP block. (For debugging purposes).  <a href="a00119.html#ga14d29338ffd1387758810b3f9e3a72c6"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00119.html#gaef53b2877ff369badd7bb25b26bb9029">gap_set_all</a> (T *buf, unsigned set_max, unsigned value)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets all bits to 0 or 1 (GAP).  <a href="a00119.html#gaef53b2877ff369badd7bb25b26bb9029"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00119.html#ga510ab7feb60c19f7d7811cc304fdf649">gap_init_range_block</a> (T *buf, T from, T to, T value, unsigned set_max)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Init gap block so it has block in it (can be whole block).  <a href="a00119.html#ga510ab7feb60c19f7d7811cc304fdf649"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00119.html#ga3f22bfde5dfe06d6d77dc2598b8c0845">gap_invert</a> (T *buf)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Inverts all bits in the GAP buffer.  <a href="a00119.html#ga3f22bfde5dfe06d6d77dc2598b8c0845"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00119.html#ga690ff7c8b16e1821a77663b7194267e7">gap_is_all_zero</a> (const T *buf, unsigned set_max)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Temporary inverts all bits in the GAP buffer.  <a href="a00119.html#ga690ff7c8b16e1821a77663b7194267e7"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00119.html#ga1427d43e91872f981c6311fa76ab5633">gap_is_all_one</a> (const T *buf, unsigned set_max)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Checks if GAP block is all-one.  <a href="a00119.html#ga1427d43e91872f981c6311fa76ab5633"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">T&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00119.html#ga02541ec6c2930c292eda4313b78e874c">gap_length</a> (const T *buf)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returs GAP block length.  <a href="a00119.html#ga02541ec6c2930c292eda4313b78e874c"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">unsigned&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00119.html#ga0419ed06e2f0b7891e7d721546f5fb45">gap_capacity</a> (const T *buf, const T *glevel_len)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returs GAP block capacity.  <a href="a00119.html#ga0419ed06e2f0b7891e7d721546f5fb45"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">unsigned&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00119.html#ga94a5371b5dc6a1560d95d7c2dde88815">gap_limit</a> (const T *buf, const T *glevel_len)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returs GAP block capacity limit.  <a href="a00119.html#ga94a5371b5dc6a1560d95d7c2dde88815"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">unsigned&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00119.html#ga1defe73aa4227a0e7204363ac6bb1ac1">gap_level</a> (const T *buf)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returs GAP blocks capacity level.  <a href="a00119.html#ga1defe73aa4227a0e7204363ac6bb1ac1"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00119.html#ga501aa9bf029e7f9ea9518e7003fe5549">set_gap_level</a> (T *buf, unsigned level)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets GAP block capacity level.  <a href="a00119.html#ga501aa9bf029e7f9ea9518e7003fe5549"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">int&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00119.html#ga3bfaebeeb4b2d479c5a9ac9d57607165">gap_calc_level</a> (int len, const T *glevel_len)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Calculates GAP block capacity level.  <a href="a00119.html#ga3bfaebeeb4b2d479c5a9ac9d57607165"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">unsigned&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00119.html#gafd76869eb44fac688da5e26e0e74f41f">gap_free_elements</a> (const T *buf, const T *glevel_len)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns number of free elements in GAP block array. Difference between GAP block capacity on this level and actual GAP length.  <a href="a00119.html#gafd76869eb44fac688da5e26e0e74f41f"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">int&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00120.html#ga91fe9566575d9d66e1bb9d030b3d29a0">bitcmp</a> (const T *buf1, const T *buf2, unsigned len)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Lexicographical comparison of BIT buffers.  <a href="a00120.html#ga91fe9566575d9d66e1bb9d030b3d29a0"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">unsigned&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00119.html#ga80d09bb6ab244e68ab0c1fdccc17b95b">bit_convert_to_gap</a> (T *BMRESTRICT dest, const unsigned *BMRESTRICT src, <a class="el" href="a00115.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a> bits, unsigned dest_len)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Converts bit block to GAP.  <a href="a00119.html#ga80d09bb6ab244e68ab0c1fdccc17b95b"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T , class F &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00119.html#ga11bc26da8533752bb23756632fd30a00">for_each_gap_dbit</a> (const T *buf, F &amp;func)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Iterate gap block as delta-bits with a functor.  <a href="a00119.html#ga11bc26da8533752bb23756632fd30a00"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename D , typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">D&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00119.html#ga5cd7e0cfee401da1b8f702151c083b27">gap_convert_to_arr</a> (D *BMRESTRICT dest, const T *BMRESTRICT buf, unsigned dest_len, bool invert=false)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convert gap block into array of ints corresponding to 1 bits.  <a href="a00119.html#ga5cd7e0cfee401da1b8f702151c083b27"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00115.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00120.html#gab30df14a61f036d690c091878feaff1c">bit_block_calc_count</a> (const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *block, const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *block_end)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Bitcount for bit string.  <a href="a00120.html#gab30df14a61f036d690c091878feaff1c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00115.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00120.html#gaafc87c4764bb30d95ba4088064a404e3">bit_count_change</a> (<a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> w)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00115.html#ae2222be6fd45b4bab5100ce70e3b4f88">bit_count_change32</a> (const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *block, const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *block_end, unsigned *bit_count, unsigned *gap_count)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00115.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00120.html#gaca91016aeb08ae1b610d6d407aae0e4c">bit_block_calc_count_change</a> (const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *block, const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *block_end, unsigned *bit_count)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00115.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00120.html#ga2485f707b2629c5ce7681cf9fe385b91">bit_block_calc_count_range</a> (const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *block, <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> left, <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> right)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00115.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00120.html#ga503e0f3e79f819d9b58e4b0e905be116">bit_block_any_range</a> (const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *block, <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> left, <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> right)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00120.html#ga95854f9969985254a0f58b928da0eec6">bit_invert</a> (T *start, T *end)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00120.html#ga97b1075250d4bf10f596ff2fbc334ceb">is_bits_one</a> (const <a class="el" href="a00115.html#a7176bf7817550ca24cb6612bd8d7957d">bm::wordop_t</a> *start, const <a class="el" href="a00115.html#a7176bf7817550ca24cb6612bd8d7957d">bm::wordop_t</a> *end)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns "true" if all bits in the block are 1.  <a href="a00120.html#ga97b1075250d4bf10f596ff2fbc334ceb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00120.html#gac6cfb9f92e4df6bb4c76f6efb2382860">bit_is_all_zero</a> (const <a class="el" href="a00115.html#a7176bf7817550ca24cb6612bd8d7957d">bm::wordop_t</a> *start, const <a class="el" href="a00115.html#a7176bf7817550ca24cb6612bd8d7957d">bm::wordop_t</a> *end)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns "true" if all bits in the block are 0.  <a href="a00120.html#gac6cfb9f92e4df6bb4c76f6efb2382860"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">BMFORCEINLINE unsigned&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00115.html#a8d943cf66c4592e2baddf5bc0667adbd">and_op</a> (unsigned v1, unsigned v2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">GAP and functor.  <a href="#a8d943cf66c4592e2baddf5bc0667adbd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">BMFORCEINLINE unsigned&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00115.html#a6e7085de3103a42f81c0d3d82903cd5f">xor_op</a> (unsigned v1, unsigned v2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">GAP xor functor.  <a href="#a6e7085de3103a42f81c0d3d82903cd5f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">BMFORCEINLINE unsigned&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00115.html#ac330d13a0846ca89ff6fc6927e675a93">or_op</a> (unsigned v1, unsigned v2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">GAP or functor.  <a href="#ac330d13a0846ca89ff6fc6927e675a93"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">BMFORCEINLINE unsigned&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00115.html#a35c5866395bfb88b68913b32539a2b96">sub_op</a> (unsigned v1, unsigned v2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">GAP or functor.  <a href="#a35c5866395bfb88b68913b32539a2b96"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">BMFORCEINLINE <a class="el" href="a00115.html#ac654d6319039a86546d235a236fc7cf6">gap_word_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00119.html#gac18d7da0492983802511999a4ad0764a">gap_operation_and</a> (const <a class="el" href="a00115.html#ac654d6319039a86546d235a236fc7cf6">gap_word_t</a> *BMRESTRICT vect1, const <a class="el" href="a00115.html#ac654d6319039a86546d235a236fc7cf6">gap_word_t</a> *BMRESTRICT vect2, <a class="el" href="a00115.html#ac654d6319039a86546d235a236fc7cf6">gap_word_t</a> *BMRESTRICT tmp_buf, unsigned &amp;dsize)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">GAP AND operation.  <a href="a00119.html#gac18d7da0492983802511999a4ad0764a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">BMFORCEINLINE unsigned&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00119.html#ga58e0312d3ab0551e883176b170c0a3e8">gap_operation_any_and</a> (const <a class="el" href="a00115.html#ac654d6319039a86546d235a236fc7cf6">gap_word_t</a> *BMRESTRICT vect1, const <a class="el" href="a00115.html#ac654d6319039a86546d235a236fc7cf6">gap_word_t</a> *BMRESTRICT vect2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">GAP AND operation test.  <a href="a00119.html#ga58e0312d3ab0551e883176b170c0a3e8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">BMFORCEINLINE unsigned&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00119.html#gafd92d013b0c377604831f401ef6917b8">gap_count_and</a> (const <a class="el" href="a00115.html#ac654d6319039a86546d235a236fc7cf6">gap_word_t</a> *BMRESTRICT vect1, const <a class="el" href="a00115.html#ac654d6319039a86546d235a236fc7cf6">gap_word_t</a> *BMRESTRICT vect2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">GAP bitcount AND operation test.  <a href="a00119.html#gafd92d013b0c377604831f401ef6917b8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">BMFORCEINLINE <a class="el" href="a00115.html#ac654d6319039a86546d235a236fc7cf6">gap_word_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00119.html#ga72d2d3933b4410413eeb02e9ee0a910d">gap_operation_xor</a> (const <a class="el" href="a00115.html#ac654d6319039a86546d235a236fc7cf6">gap_word_t</a> *BMRESTRICT vect1, const <a class="el" href="a00115.html#ac654d6319039a86546d235a236fc7cf6">gap_word_t</a> *BMRESTRICT vect2, <a class="el" href="a00115.html#ac654d6319039a86546d235a236fc7cf6">gap_word_t</a> *BMRESTRICT tmp_buf, unsigned &amp;dsize)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">GAP XOR operation.  <a href="a00119.html#ga72d2d3933b4410413eeb02e9ee0a910d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">BMFORCEINLINE unsigned&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00119.html#gab8800dff60eb05404a83159035e8e72f">gap_operation_any_xor</a> (const <a class="el" href="a00115.html#ac654d6319039a86546d235a236fc7cf6">gap_word_t</a> *BMRESTRICT vect1, const <a class="el" href="a00115.html#ac654d6319039a86546d235a236fc7cf6">gap_word_t</a> *BMRESTRICT vect2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">GAP XOR operation test.  <a href="a00119.html#gab8800dff60eb05404a83159035e8e72f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">BMFORCEINLINE unsigned&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00119.html#gae38d6a3296f0562be512f47b4edfb1ad">gap_count_xor</a> (const <a class="el" href="a00115.html#ac654d6319039a86546d235a236fc7cf6">gap_word_t</a> *BMRESTRICT vect1, const <a class="el" href="a00115.html#ac654d6319039a86546d235a236fc7cf6">gap_word_t</a> *BMRESTRICT vect2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">GAP bitcount XOR operation test.  <a href="a00119.html#gae38d6a3296f0562be512f47b4edfb1ad"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00115.html#ac654d6319039a86546d235a236fc7cf6">gap_word_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00119.html#gacda280af8910ae5fde37731a3a7a1226">gap_operation_or</a> (const <a class="el" href="a00115.html#ac654d6319039a86546d235a236fc7cf6">gap_word_t</a> *BMRESTRICT vect1, const <a class="el" href="a00115.html#ac654d6319039a86546d235a236fc7cf6">gap_word_t</a> *BMRESTRICT vect2, <a class="el" href="a00115.html#ac654d6319039a86546d235a236fc7cf6">gap_word_t</a> *BMRESTRICT tmp_buf, unsigned &amp;dsize)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">GAP OR operation.  <a href="a00119.html#gacda280af8910ae5fde37731a3a7a1226"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">BMFORCEINLINE unsigned&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00119.html#ga125fc8dc68245a11a171e7793c6588a2">gap_count_or</a> (const <a class="el" href="a00115.html#ac654d6319039a86546d235a236fc7cf6">gap_word_t</a> *BMRESTRICT vect1, const <a class="el" href="a00115.html#ac654d6319039a86546d235a236fc7cf6">gap_word_t</a> *BMRESTRICT vect2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">GAP bitcount OR operation test.  <a href="a00119.html#ga125fc8dc68245a11a171e7793c6588a2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00115.html#ac654d6319039a86546d235a236fc7cf6">gap_word_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00119.html#gabe4c83e5e162c38e297116dd1cd05ac4">gap_operation_sub</a> (const <a class="el" href="a00115.html#ac654d6319039a86546d235a236fc7cf6">gap_word_t</a> *BMRESTRICT vect1, const <a class="el" href="a00115.html#ac654d6319039a86546d235a236fc7cf6">gap_word_t</a> *BMRESTRICT vect2, <a class="el" href="a00115.html#ac654d6319039a86546d235a236fc7cf6">gap_word_t</a> *BMRESTRICT tmp_buf, unsigned &amp;dsize)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">GAP SUB (AND NOT) operation.  <a href="a00119.html#gabe4c83e5e162c38e297116dd1cd05ac4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">BMFORCEINLINE unsigned&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00119.html#ga1c9b33d00f74206ad655dc2cef52428b">gap_operation_any_sub</a> (const <a class="el" href="a00115.html#ac654d6319039a86546d235a236fc7cf6">gap_word_t</a> *BMRESTRICT vect1, const <a class="el" href="a00115.html#ac654d6319039a86546d235a236fc7cf6">gap_word_t</a> *BMRESTRICT vect2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">GAP SUB operation test.  <a href="a00119.html#ga1c9b33d00f74206ad655dc2cef52428b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">BMFORCEINLINE unsigned&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00119.html#gacacf55c60da82a1c384f3ac3a51229d4">gap_count_sub</a> (const <a class="el" href="a00115.html#ac654d6319039a86546d235a236fc7cf6">gap_word_t</a> *BMRESTRICT vect1, const <a class="el" href="a00115.html#ac654d6319039a86546d235a236fc7cf6">gap_word_t</a> *BMRESTRICT vect2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">GAP bitcount SUB (AND NOT) operation test.  <a href="a00119.html#gacacf55c60da82a1c384f3ac3a51229d4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00120.html#ga9090de87d53e7f25eff96c8259b3485c">bit_block_copy</a> (<a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *BMRESTRICT dst, const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *BMRESTRICT src)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Bitblock copy operation.  <a href="a00120.html#ga9090de87d53e7f25eff96c8259b3485c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00120.html#ga882f79df0a0175ad4ddf483c5f1eeb0e">bit_block_and</a> (<a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *BMRESTRICT dst, const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *BMRESTRICT src)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Plain bitblock AND operation. Function does not analyse availability of source and destination blocks.  <a href="a00120.html#ga882f79df0a0175ad4ddf483c5f1eeb0e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00120.html#ga0070984bb1d332610150a9106ab8eb0a">bit_block_and_count</a> (const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *src1, const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *src1_end, const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *src2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Function ANDs two bitblocks and computes the bitcount. Function does not analyse availability of source blocks.  <a href="a00120.html#ga0070984bb1d332610150a9106ab8eb0a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00120.html#ga9fe2d12ddac5293fe53038c687c732f3">bit_block_and_any</a> (const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *src1, const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *src1_end, const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *src2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Function ANDs two bitblocks and tests for any bit. Function does not analyse availability of source blocks.  <a href="a00120.html#ga9fe2d12ddac5293fe53038c687c732f3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00120.html#gaf8af8cfe8b49407be1af7398da28c939">bit_block_xor_count</a> (const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *BMRESTRICT src1, const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *BMRESTRICT src1_end, const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *BMRESTRICT src2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Function XORs two bitblocks and computes the bitcount. Function does not analyse availability of source blocks.  <a href="a00120.html#gaf8af8cfe8b49407be1af7398da28c939"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00120.html#gafbc3ffafc859a503fdd2fc96e7fb60ce">bit_block_xor_any</a> (const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *BMRESTRICT src1, const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *BMRESTRICT src1_end, const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *BMRESTRICT src2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Function XORs two bitblocks and and tests for any bit. Function does not analyse availability of source blocks.  <a href="a00120.html#gafbc3ffafc859a503fdd2fc96e7fb60ce"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00120.html#gad34175255e9860a572fcf2e664a6de8e">bit_block_sub_count</a> (const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *BMRESTRICT src1, const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *BMRESTRICT src1_end, const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *BMRESTRICT src2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Function SUBs two bitblocks and computes the bitcount. Function does not analyse availability of source blocks.  <a href="a00120.html#gad34175255e9860a572fcf2e664a6de8e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00120.html#ga3f51735d2ca08e5a9fae2c9c49138c5c">bit_block_sub_any</a> (const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *BMRESTRICT src1, const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *BMRESTRICT src1_end, const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *BMRESTRICT src2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Function SUBs two bitblocks and and tests for any bit. Function does not analyse availability of source blocks.  <a href="a00120.html#ga3f51735d2ca08e5a9fae2c9c49138c5c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00120.html#gacf4f8ab164277278448a541863c07517">bit_block_or_count</a> (const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *src1, const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *src1_end, const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *src2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Function ORs two bitblocks and computes the bitcount. Function does not analyse availability of source blocks.  <a href="a00120.html#gacf4f8ab164277278448a541863c07517"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00120.html#gab2047495f7844d3014ff697503669d24">bit_block_or_any</a> (const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *BMRESTRICT src1, const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *BMRESTRICT src1_end, const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *BMRESTRICT src2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Function ORs two bitblocks and and tests for any bit. Function does not analyse availability of source blocks.  <a href="a00120.html#gab2047495f7844d3014ff697503669d24"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00120.html#ga869fce5348076d4c7b92adcc2f1a49ab">bit_operation_and</a> (<a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *BMRESTRICT dst, const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *BMRESTRICT src)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">bitblock AND operation.  <a href="a00120.html#ga869fce5348076d4c7b92adcc2f1a49ab"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00115.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00120.html#ga9765914087df2fc22ec18db8128f2a12">bit_operation_and_count</a> (const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *BMRESTRICT src1, const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *BMRESTRICT src1_end, const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *BMRESTRICT src2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs bitblock AND operation and calculates bitcount of the result.  <a href="a00120.html#ga9765914087df2fc22ec18db8128f2a12"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00115.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00120.html#ga0e7995f7d6c791f6ff27a8dd21d324e5">bit_operation_and_any</a> (const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *BMRESTRICT src1, const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *BMRESTRICT src1_end, const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *BMRESTRICT src2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs bitblock AND operation test.  <a href="a00120.html#ga0e7995f7d6c791f6ff27a8dd21d324e5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00115.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00120.html#gaabb39bf01bf973cb7bf3648873921ab7">bit_operation_sub_count</a> (const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *BMRESTRICT src1, const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *BMRESTRICT src1_end, const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *BMRESTRICT src2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs bitblock SUB operation and calculates bitcount of the result.  <a href="a00120.html#gaabb39bf01bf973cb7bf3648873921ab7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00115.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00120.html#ga53867faf377db72324b858a37063c0b8">bit_operation_sub_count_inv</a> (const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *BMRESTRICT src1, const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *BMRESTRICT src1_end, const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *BMRESTRICT src2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs inverted bitblock SUB operation and calculates bitcount of the result.  <a href="a00120.html#ga53867faf377db72324b858a37063c0b8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00115.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00120.html#ga847d5a84673b284be984f0db583e2723">bit_operation_sub_any</a> (const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *BMRESTRICT src1, const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *BMRESTRICT src1_end, const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *BMRESTRICT src2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs bitblock test of SUB operation.  <a href="a00120.html#ga847d5a84673b284be984f0db583e2723"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00115.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00120.html#ga5a267aff3b56cc6dadf5a3a338e00a1d">bit_operation_or_count</a> (const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *BMRESTRICT src1, const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *BMRESTRICT src1_end, const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *BMRESTRICT src2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs bitblock OR operation and calculates bitcount of the result.  <a href="a00120.html#ga5a267aff3b56cc6dadf5a3a338e00a1d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00115.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00120.html#ga6d26742bdc373074474a6932eab4f388">bit_operation_or_any</a> (const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *BMRESTRICT src1, const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *BMRESTRICT src1_end, const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *BMRESTRICT src2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs bitblock OR operation test.  <a href="a00120.html#ga6d26742bdc373074474a6932eab4f388"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00120.html#ga3515d8eb5da7f9d41d63dc90ad9523a4">bit_block_or</a> (<a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *BMRESTRICT dst, const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *BMRESTRICT src)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Plain bitblock OR operation. Function does not analyse availability of source and destination blocks.  <a href="a00120.html#ga3515d8eb5da7f9d41d63dc90ad9523a4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00120.html#ga0e945a9eaae699ad40f63b3f0632e6f9">bit_operation_or</a> (<a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *BMRESTRICT dst, const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *BMRESTRICT src)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Block OR operation. Makes analysis if block is 0 or FULL.  <a href="a00120.html#ga0e945a9eaae699ad40f63b3f0632e6f9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00120.html#gafed81435f74c0542857842d4461686e4">bit_block_sub</a> (<a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *BMRESTRICT dst, const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *BMRESTRICT src)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Plain bitblock SUB (AND NOT) operation. Function does not analyse availability of source and destination blocks.  <a href="a00120.html#gafed81435f74c0542857842d4461686e4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00120.html#gad7afa9bce28a376360ca4826960d669f">bit_operation_sub</a> (<a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *BMRESTRICT dst, const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *BMRESTRICT src)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">bitblock SUB operation.  <a href="a00120.html#gad7afa9bce28a376360ca4826960d669f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00120.html#gae6a46c5e671ea1c9312219ceb41025ef">bit_block_xor</a> (<a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *BMRESTRICT dst, const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *BMRESTRICT src)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Plain bitblock XOR operation. Function does not analyse availability of source and destination blocks.  <a href="a00120.html#gae6a46c5e671ea1c9312219ceb41025ef"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00120.html#ga179de722e87ccf8189d975ca6beed025">bit_operation_xor</a> (<a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *BMRESTRICT dst, const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *BMRESTRICT src)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">bitblock XOR operation.  <a href="a00120.html#ga179de722e87ccf8189d975ca6beed025"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00115.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00120.html#gace08ab77feefb638daee164ee83118bc">bit_operation_xor_count</a> (const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *BMRESTRICT src1, const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *BMRESTRICT src1_end, const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *BMRESTRICT src2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs bitblock XOR operation and calculates bitcount of the result.  <a href="a00120.html#gace08ab77feefb638daee164ee83118bc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00115.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00120.html#gaa86561b6d11c3f01dd772563c692f732">bit_operation_xor_any</a> (const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *BMRESTRICT src1, const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *BMRESTRICT src1_end, const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *BMRESTRICT src2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs bitblock XOR operation test.  <a href="a00120.html#gaa86561b6d11c3f01dd772563c692f732"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">unsigned&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00120.html#ga0ff158706f2e194be67fb8267641c30a">bit_count_nonzero_size</a> (const T *blk, unsigned data_size)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Inspects block for full zero words.  <a href="a00120.html#ga0ff158706f2e194be67fb8267641c30a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00120.html#gad6a7c549a625df7aa7d68d43a57238c7">bit_find_in_block</a> (const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *data, unsigned nbit, <a class="el" href="a00115.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a> *prev)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Searches for the next 1 bit in the BIT block.  <a href="a00120.html#gad6a7c549a625df7aa7d68d43a57238c7"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T , typename F &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00120.html#gab9f80b3c898323ce77beb915e4c861f3">bit_for_each_4</a> (T w, F &amp;func)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Templated algorithm to unpacks octet based word into list of ON bit indexes.  <a href="a00120.html#gab9f80b3c898323ce77beb915e4c861f3"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T , typename F &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00120.html#ga24be2ad5d8c2a8f18fdad142452aaae8">bit_for_each</a> (T w, F &amp;func)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Templated algorithm to unpacks word into list of ON bit indexes.  <a href="a00120.html#ga24be2ad5d8c2a8f18fdad142452aaae8"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T , typename B &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">unsigned&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00120.html#ga3c81f6bff8866ec3ed0a94903eee96b7">bit_list_4</a> (T w, B *bits)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unpacks word into list of ON bit indexes (quad-bit based).  <a href="a00120.html#ga3c81f6bff8866ec3ed0a94903eee96b7"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T , typename B &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">unsigned&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00120.html#gaae3ae537760044543f842363e4614e82">bit_list</a> (T w, B *bits)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unpacks word into list of ON bit indexes.  <a href="a00120.html#gaae3ae537760044543f842363e4614e82"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00115.html#a593916a103395805070a3200720c6416">bm::set_representation</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00120.html#ga20610fae6b0de84957b74ed17429667f">best_representation</a> (unsigned bit_count, unsigned total_possible_bitcount, unsigned gap_count, unsigned block_size)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Choose best representation for a bit-block.  <a href="a00120.html#ga20610fae6b0de84957b74ed17429667f"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">T&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00120.html#gaf24d85761f60877c2260f8160593f732">bit_convert_to_arr</a> (T *BMRESTRICT dest, const unsigned *BMRESTRICT src, <a class="el" href="a00115.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a> bits, unsigned dest_len, unsigned mask=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convert bit block into an array of ints corresponding to 1 bits.  <a href="a00120.html#gaf24d85761f60877c2260f8160593f732"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">unsigned&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00119.html#gacc578010f3700940829c600c812d23b1">gap_overhead</a> (const T *length, const T *length_end, const T *glevel_len)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convert bit block into an array of ints corresponding to 1 bits.  <a href="a00119.html#gacc578010f3700940829c600c812d23b1"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00119.html#ga2daff3a0ceda6fef87d3b0e892da5813">improve_gap_levels</a> (const T *length, const T *length_end, T *glevel_len)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Finds optimal gap blocks lengths.  <a href="a00119.html#ga2daff3a0ceda6fef87d3b0e892da5813"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class It1 , class It2 , class BinaryOp , class Encoder &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00115.html#a503fecc0ee281059897412d68f489e1e">bit_recomb</a> (It1 &amp;it1, It2 &amp;it2, BinaryOp &amp;op, Encoder &amp;enc, unsigned block_size=<a class="el" href="a00115.html#a91319dbc0d0e1bf3a3efc4d92bac7972">bm::set_block_size</a>)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">BMFORCEINLINE void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00122.html#ga75c6ddeb0d8a279caa92341878309b50">sse2_xor_arr_2_mask</a> (__m128i *BMRESTRICT dst, const __m128i *BMRESTRICT src, const __m128i *BMRESTRICT src_end, <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> mask)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">XOR array elements to specified mask dst = *src ^ mask.  <a href="a00122.html#ga75c6ddeb0d8a279caa92341878309b50"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">BMFORCEINLINE void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00122.html#gab7b21f448684c4d84927792661e67ed5">sse2_andnot_arr_2_mask</a> (__m128i *BMRESTRICT dst, const __m128i *BMRESTRICT src, const __m128i *BMRESTRICT src_end, <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> mask)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Inverts array elements and NOT them to specified mask dst = ~*src &amp; mask.  <a href="a00122.html#gab7b21f448684c4d84927792661e67ed5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">BMFORCEINLINE void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00122.html#ga795b544f311409a55da4ee61a3cd939a">sse2_and_arr</a> (__m128i *BMRESTRICT dst, const __m128i *BMRESTRICT src, const __m128i *BMRESTRICT src_end)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">AND array elements against another array dst &amp;= *src.  <a href="a00122.html#ga795b544f311409a55da4ee61a3cd939a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">BMFORCEINLINE void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00122.html#ga3a7d61e4e8ad8791ab38fd1c3436aa67">sse2_or_arr</a> (__m128i *BMRESTRICT dst, const __m128i *BMRESTRICT src, const __m128i *BMRESTRICT src_end)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">OR array elements against another array dst |= *src.  <a href="a00122.html#ga3a7d61e4e8ad8791ab38fd1c3436aa67"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">BMFORCEINLINE void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00122.html#gaf1a5ad26557cc4d71d7421c35a8445fe">sse2_xor_arr</a> (__m128i *BMRESTRICT dst, const __m128i *BMRESTRICT src, const __m128i *BMRESTRICT src_end)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">OR array elements against another array dst ^= *src.  <a href="a00122.html#gaf1a5ad26557cc4d71d7421c35a8445fe"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">BMFORCEINLINE void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00122.html#gac99f3b138f8a5e8ffb1296b129f618f0">sse2_sub_arr</a> (__m128i *BMRESTRICT dst, const __m128i *BMRESTRICT src, const __m128i *BMRESTRICT src_end)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">AND-NOT (SUB) array elements against another array dst &amp;= ~*src.  <a href="a00122.html#gac99f3b138f8a5e8ffb1296b129f618f0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">BMFORCEINLINE void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00122.html#ga302f4fcd0abf355957b305d16d04f452">sse2_set_block</a> (__m128i *BMRESTRICT dst, __m128i *BMRESTRICT dst_end, <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> value)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">SSE2 block memset dst = value.  <a href="a00122.html#ga302f4fcd0abf355957b305d16d04f452"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">BMFORCEINLINE void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00122.html#ga571dd54af5c555cad9dfa6bef4561777">sse2_copy_block</a> (__m128i *BMRESTRICT dst, const __m128i *BMRESTRICT src, const __m128i *BMRESTRICT src_end)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">SSE2 block copy dst = *src.  <a href="a00122.html#ga571dd54af5c555cad9dfa6bef4561777"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">BMFORCEINLINE void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00122.html#ga8d506147673d88005f92caee7f5dd23a">sse2_invert_arr</a> (<a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *first, <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *last)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Invert array elements dst = ~*dst or dst ^= *dst.  <a href="a00122.html#ga8d506147673d88005f92caee7f5dd23a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">BMFORCEINLINE __m128i&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00115.html#ac0c75fb7b3dc61602843ac4e1b9b7ef5">sse2_and</a> (__m128i a, __m128i b)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">BMFORCEINLINE __m128i&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00115.html#adea798a9a95a04845c33876087a2f46b">sse2_or</a> (__m128i a, __m128i b)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">BMFORCEINLINE __m128i&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00115.html#a6f5de19ee3e1be05037908b4777c4da8">sse2_xor</a> (__m128i a, __m128i b)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">BMFORCEINLINE __m128i&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00115.html#ab3e6d46fcba1bc2a1a5390c10f571382">sse2_sub</a> (__m128i a, __m128i b)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00115.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00123.html#ga266ed6594dc786e46c1f353443dc41fe">sse4_bit_count</a> (const __m128i *block, const __m128i *block_end)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">BMFORCEINLINE unsigned&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00115.html#a6d8f327a7d19c11125ac77383a34e986">op_xor</a> (unsigned a, unsigned b)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">BMFORCEINLINE unsigned&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00115.html#a0ed9a1bcd143f7763b4b59ef442f6994">op_or</a> (unsigned a, unsigned b)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">BMFORCEINLINE unsigned&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00115.html#a515b2862b33efd4e36d72e4ba7729199">op_and</a> (unsigned a, unsigned b)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class Func &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00115.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00115.html#a295c6323a972a90e28c36e6012427a26">sse4_bit_count_op</a> (const __m128i *BMRESTRICT block, const __m128i *BMRESTRICT block_end, const __m128i *BMRESTRICT mask_block, Func sse2_func)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00115.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00123.html#gad686391db4cdc6382ae6785f62981474">sse4_bit_block_calc_count_change</a> (const __m128i *BMRESTRICT block, const __m128i *BMRESTRICT block_end, unsigned *BMRESTRICT bit_count)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00115.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00122.html#ga0f7e0b2eb9ac7b2c6a8cd3b8f15b071f">sse2_bit_count</a> (const __m128i *block, const __m128i *block_end)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class Func &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00115.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00115.html#a8831a88ef538b3997d04d2ebf513160d">sse2_bit_count_op</a> (const __m128i *BMRESTRICT block, const __m128i *BMRESTRICT block_end, const __m128i *BMRESTRICT mask_block, Func sse2_func)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00115.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00115.html#a0479b7b6704c6ab64396e2365b8b5fa7">sse2_bit_block_calc_count_change</a> (const __m128i *BMRESTRICT block, const __m128i *BMRESTRICT block_end, unsigned *BMRESTRICT bit_count)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00125.html#gac38d64c8b27b652413a664cddd4d40ab">distance_metric</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00125.html#ga158946ea41ca66c3e1bca62c92684788">operation2metric</a> (<a class="el" href="a00115.html#a76b70d2b9182a6dcac151d1bd9ec6109">set_operation</a> op)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convert set operation into compatible distance metric.  <a href="a00125.html#ga158946ea41ca66c3e1bca62c92684788"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00115.html#a5e19a65218d5423e3ae1e426ac37a378">combine_count_operation_with_block</a> (const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *blk, const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *arg_blk, <a class="el" href="a00060.html">distance_metric_descriptor</a> *dmit, <a class="el" href="a00060.html">distance_metric_descriptor</a> *dmit_end)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Internal function computes different distance metrics.  <a href="#a5e19a65218d5423e3ae1e426ac37a378"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00115.html#ab8b78e416da269fca3dc03c98c00ac6a">combine_count_and_operation_with_block</a> (const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *blk, const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *arg_blk)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Internal function computes AND distance.  <a href="#ab8b78e416da269fca3dc03c98c00ac6a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00115.html#a1e4a2084ce5e7bc77197b9c616004659">combine_any_operation_with_block</a> (const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *blk, unsigned gap, const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *arg_blk, int arg_gap, <a class="el" href="a00060.html">distance_metric_descriptor</a> *dmit, <a class="el" href="a00060.html">distance_metric_descriptor</a> *dmit_end)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Internal function computes different existense of distance metric.  <a href="#a1e4a2084ce5e7bc77197b9c616004659"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00115.html#a408a8c098c43feeb0af7af706c796650">combine_count_operation_with_block</a> (const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *blk, const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *arg_blk, <a class="el" href="a00125.html#gac38d64c8b27b652413a664cddd4d40ab">distance_metric</a> metric)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00115.html#af901d98c77c801206fbede3f2c74d4b4">combine_any_operation_with_block</a> (const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *blk, unsigned gap, const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *arg_blk, int arg_gap, <a class="el" href="a00125.html#gac38d64c8b27b652413a664cddd4d40ab">distance_metric</a> metric)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00115.html#adfd7e03426f4b8c0952e97d43ed75abf">distance_stage</a> (const <a class="el" href="a00060.html">distance_metric_descriptor</a> *dmit, const <a class="el" href="a00060.html">distance_metric_descriptor</a> *dmit_end, bool *is_all_and)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Staging function for distance operation.  <a href="#adfd7e03426f4b8c0952e97d43ed75abf"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class BV &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00125.html#ga815fef76f02576ab9ab58de0a45d8a4b">distance_operation</a> (const BV &amp;bv1, const BV &amp;bv2, <a class="el" href="a00060.html">distance_metric_descriptor</a> *dmit, <a class="el" href="a00060.html">distance_metric_descriptor</a> *dmit_end)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Distance computing template function.  <a href="a00125.html#ga815fef76f02576ab9ab58de0a45d8a4b"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class BV &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">unsigned&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00125.html#gad3ce9974302b0da70c5f029f620409f4">distance_and_operation</a> (const BV &amp;bv1, const BV &amp;bv2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Distance AND computing template function.  <a href="a00125.html#gad3ce9974302b0da70c5f029f620409f4"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class BV &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00125.html#gaa66525fd7a3f823d73678252a235982e">distance_operation_any</a> (const BV &amp;bv1, const BV &amp;bv2, <a class="el" href="a00060.html">distance_metric_descriptor</a> *dmit, <a class="el" href="a00060.html">distance_metric_descriptor</a> *dmit_end)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Distance screening template function.  <a href="a00125.html#gaa66525fd7a3f823d73678252a235982e"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class BV &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00115.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00125.html#gae451cb4b87e8c0859b0614d2ffb99737">count_and</a> (const BV &amp;bv1, const BV &amp;bv2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes bitcount of AND operation of two bitsets.  <a href="a00125.html#gae451cb4b87e8c0859b0614d2ffb99737"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class BV &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00115.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00125.html#ga2d5393e05bcfc540840a4cee67fb771f">any_and</a> (const BV &amp;bv1, const BV &amp;bv2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes if there is any bit in AND operation of two bitsets.  <a href="a00125.html#ga2d5393e05bcfc540840a4cee67fb771f"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class BV &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00115.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00125.html#gafc64a082dcaee07f70f7faf3e24f844e">count_xor</a> (const BV &amp;bv1, const BV &amp;bv2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes bitcount of XOR operation of two bitsets.  <a href="a00125.html#gafc64a082dcaee07f70f7faf3e24f844e"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class BV &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00115.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00125.html#ga2d63f41244b82d233acb53d88b326b82">any_xor</a> (const BV &amp;bv1, const BV &amp;bv2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes if there is any bit in XOR operation of two bitsets.  <a href="a00125.html#ga2d63f41244b82d233acb53d88b326b82"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class BV &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00115.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00125.html#ga902d8c1cd1f8a2538cd47d47f5d8d605">count_sub</a> (const BV &amp;bv1, const BV &amp;bv2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes bitcount of SUB operation of two bitsets.  <a href="a00125.html#ga902d8c1cd1f8a2538cd47d47f5d8d605"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class BV &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00115.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00125.html#gabde2e210b9b1edd190e1f5a9ff22344c">any_sub</a> (const BV &amp;bv1, const BV &amp;bv2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes if there is any bit in SUB operation of two bitsets.  <a href="a00125.html#gabde2e210b9b1edd190e1f5a9ff22344c"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class BV &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00115.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00125.html#ga803c564668703fc3bf80067570c2c905">count_or</a> (const BV &amp;bv1, const BV &amp;bv2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes bitcount of OR operation of two bitsets.  <a href="a00125.html#ga803c564668703fc3bf80067570c2c905"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class BV &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00115.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00125.html#gaeda4f0cf54aa464cec09e740100caa79">any_or</a> (const BV &amp;bv1, const BV &amp;bv2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes if there is any bit in OR operation of two bitsets.  <a href="a00125.html#gaeda4f0cf54aa464cec09e740100caa79"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class It &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">It&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00115.html#a86d5d5ccdb79d2b2ad552bd1caf34b2f">block_range_scan</a> (It first, It last, unsigned nblock, unsigned *max_id)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Internal algorithms scans the input for the block range limit.  <a href="#a86d5d5ccdb79d2b2ad552bd1caf34b2f"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class BV , class It &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00124.html#ga54ff78528c99ae3ca443eb99ba44785b">combine_or</a> (BV &amp;bv, It first, It last)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">OR Combine bitvector and the iterable sequence.  <a href="a00124.html#ga54ff78528c99ae3ca443eb99ba44785b"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class BV , class It &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00124.html#ga3cb362aee03de6a321495100ae5c8375">combine_xor</a> (BV &amp;bv, It first, It last)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">XOR Combine bitvector and the iterable sequence.  <a href="a00124.html#ga3cb362aee03de6a321495100ae5c8375"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class BV , class It &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00124.html#gab88c5bf51484323e0139aa789d7f0b98">combine_sub</a> (BV &amp;bv, It first, It last)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">SUB Combine bitvector and the iterable sequence.  <a href="a00124.html#gab88c5bf51484323e0139aa789d7f0b98"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class BV , class It &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00124.html#ga22922f71bd1eec8a5b663dc77b90cf6c">combine_and_sorted</a> (BV &amp;bv, It first, It last)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">AND Combine bitvector and the iterable sequence.  <a href="a00124.html#ga22922f71bd1eec8a5b663dc77b90cf6c"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class BV , class It &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00124.html#ga819bdab57a624a08456ea79161b9c5d2">combine_and</a> (BV &amp;bv, It first, It last)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">AND Combine bitvector and the iterable sequence.  <a href="a00124.html#ga819bdab57a624a08456ea79161b9c5d2"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class BV &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00115.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00124.html#gac7a59d3bc266310ec127cb3efadb0d33">count_intervals</a> (const BV &amp;bv)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute number of bit intervals (GAPs) in the bitvector.  <a href="a00124.html#gac7a59d3bc266310ec127cb3efadb0d33"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class BV , class It &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00124.html#gacd88ed9539553dd93419b7029e8a4584">export_array</a> (BV &amp;bv, It first, It last)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Export bitset from an array of binary data representing the bit vector.  <a href="a00124.html#gacd88ed9539553dd93419b7029e8a4584"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T , unsigned BPC, unsigned BPS&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00115.html#a2e3af9c9f2eb481130d240ba4cd6fd68">vect_bit_transpose</a> (const T *arr, unsigned arr_size, T <a class="el" href="a00086.html">tmatrix</a>[BPC][BPS])</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Generic bit-array transposition function T - array type (any int) BPC - bit plain count BPS - bit plain size.  <a href="#a2e3af9c9f2eb481130d240ba4cd6fd68"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T , unsigned BPC, unsigned BPS&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00115.html#a089ac7cd17ddca4bf3c661c96f749f3f">vect_bit_trestore</a> (const T <a class="el" href="a00086.html">tmatrix</a>[BPC][BPS], T *arr)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Restore bit array from the transposition matrix T - array type (any int) BPC - bit plain count BPS - bit plain size.  <a href="#a089ac7cd17ddca4bf3c661c96f749f3f"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T , unsigned BPC, unsigned BPS&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00120.html#ga3fe02492f64cd8a9dfbb1a00ec71c0ae">tmatrix_distance</a> (const T <a class="el" href="a00086.html">tmatrix</a>[BPC][BPS], unsigned distance[BPC][BPC])</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute pairwise Row x Row Humming distances on plains(rows) of the transposed bit block.  <a href="a00120.html#ga3fe02492f64cd8a9dfbb1a00ec71c0ae"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T , unsigned BPC, unsigned BPS&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00120.html#gabdc11d48fda6a69873eefd219c4b7e75">bit_iblock_make_pcv</a> (const unsigned distance[BPC][BPC], unsigned char *pc_vector)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">!&lt; ibpc limiter  <a href="a00120.html#gabdc11d48fda6a69873eefd219c4b7e75"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00115.html#adfae226f696ef821c7d351216c00fe0d">bit_iblock_pcv_stat</a> (const unsigned char *BMRESTRICT pc_vector, const unsigned char *BMRESTRICT pc_vector_end, unsigned *BMRESTRICT pc_vector_stat)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute number of ibpc codes in pc_vector.  <a href="#adfae226f696ef821c7d351216c00fe0d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00115.html#a62808b64adfcf2a7e610a4f713f470c0">bit_iblock_reduce</a> (const unsigned <a class="el" href="a00086.html">tmatrix</a>[<a class="el" href="a00115.html#a3428cf384446982017ba9ee68152d238">bm::set_block_plain_cnt</a>][<a class="el" href="a00115.html#a35780565f6d8f2831ebff8877d3ba662">bm::set_block_plain_size</a>], const unsigned char *BMRESTRICT pc_vector, const unsigned char *BMRESTRICT pc_vector_end, unsigned tmatrix_out[<a class="el" href="a00115.html#a3428cf384446982017ba9ee68152d238">bm::set_block_plain_cnt</a>][<a class="el" href="a00115.html#a35780565f6d8f2831ebff8877d3ba662">bm::set_block_plain_size</a>])</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Matrix reduction based on transformation pc vector.  <a href="#a62808b64adfcf2a7e610a4f713f470c0"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class TMatrix &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00115.html#a336ed7eb10da60438793f0ecff0fb7b1">tmatrix_reduce</a> (TMatrix &amp;<a class="el" href="a00086.html">tmatrix</a>, const unsigned char *pc_vector, const unsigned effective_cols)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Transposed Matrix reduction based on transformation pc vector.  <a href="#a336ed7eb10da60438793f0ecff0fb7b1"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class TMatrix &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00115.html#ab7544e494744b2c0b265ab7d81f766b8">tmatrix_restore</a> (TMatrix &amp;<a class="el" href="a00086.html">tmatrix</a>, const unsigned char *pc_vector, const unsigned effective_cols)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Transposed Matrix restore based on transformation pc vector.  <a href="#ab7544e494744b2c0b265ab7d81f766b8"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename GT &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00115.html#a6d89da7149cc4444d699f4bfa442ab87">gap_2_bitblock</a> (const GT *BMRESTRICT gap_buf, GT *BMRESTRICT block, unsigned block_size)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copy GAP block body to bit block with DGap transformation.  <a href="#a6d89da7149cc4444d699f4bfa442ab87"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class TMatrix &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00115.html#a3788dd32c39556f0aef90b50e5a5e62c">compute_tmatrix_rstat</a> (const TMatrix &amp;<a class="el" href="a00086.html">tmatrix</a>, const unsigned char *pc_vector, typename TMatrix::rstat *rstat, unsigned effective_cols)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute t-matrix rows statistics used for compression.  <a href="#a3788dd32c39556f0aef90b50e5a5e62c"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename TM &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">unsigned&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00115.html#af92597461aff2926f9adcbf51bac98f9">find_effective_columns</a> (const TM &amp;<a class="el" href="a00086.html">tmatrix</a>)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute effective right column border of the t-matrix.  <a href="#af92597461aff2926f9adcbf51bac98f9"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">T&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00115.html#a7267df2bcc9c575c50dd1c68589c6ac1">bit_scan_fwd</a> (T v)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">T&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00115.html#a35c6dfc6504cd79f788121f361b01bf9">min_value</a> (T v1, T v2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get minimum of 2 values.  <a href="#a35c6dfc6504cd79f788121f361b01bf9"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">T&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00115.html#a46f258f92ab40e2a0c76aa775338faaa">ilog2</a> (T x)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fast loop-less function to find LOG2.  <a href="#a46f258f92ab40e2a0c76aa775338faaa"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00115.html#ac654d6319039a86546d235a236fc7cf6">bm::gap_word_t</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00115.html#a5f818ac575622da8a9a75511e649ea90">ilog2</a> (<a class="el" href="a00115.html#ac654d6319039a86546d235a236fc7cf6">gap_word_t</a> x)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">T&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00115.html#a3ab126a6fd7ffd872a4001638819a330">ilog2_LUT</a> (T x)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Lookup table based integer LOG2.  <a href="#a3ab126a6fd7ffd872a4001638819a330"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00115.html#ac654d6319039a86546d235a236fc7cf6">bm::gap_word_t</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00115.html#a7074ee06dc4ee023170c2f85c78b50fe">ilog2_LUT&lt; bm::gap_word_t &gt;</a> (<a class="el" href="a00115.html#ac654d6319039a86546d235a236fc7cf6">bm::gap_word_t</a> x)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Lookup table based short integer LOG2.  <a href="#a7074ee06dc4ee023170c2f85c78b50fe"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class BV &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">unsigned&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00126.html#ga5210c3bda57254ef2e8c71e23306cc88">serialize</a> (const BV &amp;bv, unsigned char *buf, <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *temp_block, unsigned <a class="el" href="a00126.html#ga537dfe6318f1f1fe18d86dac312be978">serialization_flags</a>=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Saves bitvector into memory.  <a href="a00126.html#ga5210c3bda57254ef2e8c71e23306cc88"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class BV &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">unsigned&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00126.html#ga213033b5cc6add74aa4bd1d614b56192">serialize</a> (BV &amp;bv, unsigned char *buf, unsigned <a class="el" href="a00126.html#ga537dfe6318f1f1fe18d86dac312be978">serialization_flags</a>=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Saves bitvector into memory. Allocates temporary memory block for <a class="el" href="a00043.html" title="bitvector with runtime compression of bits.">bvector</a>.  <a href="a00126.html#ga213033b5cc6add74aa4bd1d614b56192"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class BV &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">unsigned&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00126.html#gafbe633db8da3d867f098468269fd8d3d">deserialize</a> (BV &amp;bv, const unsigned char *buf, <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *temp_block=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Bitvector deserialization from memory.  <a href="a00126.html#gafbe633db8da3d867f098468269fd8d3d"></a><br/></td></tr>
<tr><td colspan="2"><h2>Variables</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const unsigned&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00115.html#a104b924a1df81542db2a6296fbf26a65">id_max</a> = 0xFFFFFFFF</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const unsigned&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00115.html#a91319dbc0d0e1bf3a3efc4d92bac7972">set_block_size</a> = 2048u</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const unsigned&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00115.html#ad8723fbeea6290d3daa8917ea7ce9bb2">set_block_shift</a> = 16u</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const unsigned&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00115.html#a201fb8b1f81b7487f1c1c129fc3d6557">set_block_mask</a> = 0xFFFFu</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const unsigned&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00115.html#a2d1bf97ae342a7759943e62090fcf5d3">set_blkblk_mask</a> = 0xFFFFFFu</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const unsigned&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00115.html#a35780565f6d8f2831ebff8877d3ba662">set_block_plain_size</a> = <a class="el" href="a00115.html#a91319dbc0d0e1bf3a3efc4d92bac7972">set_block_size</a> / 32u</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const unsigned&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00115.html#a3428cf384446982017ba9ee68152d238">set_block_plain_cnt</a> = sizeof(<a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a>) * 8u</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const unsigned&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00115.html#a83d76bccf6fe3770f32d5ba11d2a37ad">set_word_shift</a> = 5u</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const unsigned&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00115.html#addbf345be3733d5e4575d71733ed1da8">set_word_mask</a> = 0x1Fu</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const unsigned&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00115.html#aa5e01dfb650d168f9be0525e042af647">gap_max_buff_len</a> = 1280</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const unsigned&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00115.html#aa5b9ff05b8f4c8a9e6b17bb04988b48f">gap_length_threashold</a> = <a class="el" href="a00115.html#a91319dbc0d0e1bf3a3efc4d92bac7972">set_block_size</a> * 3</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const unsigned&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00115.html#ad0b8714080144ac70197840ff96752b7">gap_max_bits</a> = 65536</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const unsigned&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00115.html#a9b1715d6d9164d56172e75bbbd0e3000">gap_equiv_len</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const unsigned&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00115.html#a773e9f5341919d58000bd54d50038733">gap_levels</a> = 4</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const unsigned&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00115.html#a13793ad631e2b2fcbaaae9000ea1a924">gap_max_level</a> = <a class="el" href="a00115.html#a773e9f5341919d58000bd54d50038733">bm::gap_levels</a> - 1</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const unsigned&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00115.html#a40ad34d6c46a2fb20ba2baa7f95d80b4">set_array_size</a> = 256u</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const unsigned&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00115.html#ac1ff8647a089c751ec330cecee01907e">set_array_shift</a> = 8u</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const unsigned&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00115.html#a00ffa7b38d7fcc7e522d864991a6de68">set_array_mask</a> = 0xFFu</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const unsigned&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00115.html#a505011007f54598794e0b9477c0b0b11">set_total_blocks</a> = (<a class="el" href="a00115.html#a40ad34d6c46a2fb20ba2baa7f95d80b4">bm::set_array_size</a> * <a class="el" href="a00115.html#a40ad34d6c46a2fb20ba2baa7f95d80b4">bm::set_array_size</a>)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const unsigned&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00115.html#ae9916f69ced0347d94472d7944ea0e45">bits_in_block</a> = <a class="el" href="a00115.html#a91319dbc0d0e1bf3a3efc4d92bac7972">bm::set_block_size</a> * sizeof(<a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a>) * 8</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const unsigned&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00115.html#a4dedd13a7b8a27c5067b20118002f025">bits_in_array</a> = <a class="el" href="a00115.html#ae9916f69ced0347d94472d7944ea0e45">bm::bits_in_block</a> * <a class="el" href="a00115.html#a40ad34d6c46a2fb20ba2baa7f95d80b4">bm::set_array_size</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">word_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00115.html#ad81dea46a256b93b2af3568ce409d40b">all_bits_mask</a> = 0xffffffff</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const unsigned&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00115.html#a7049fd70220fc3a3072e9f82abf4ad66">set_block_size_op</a> = <a class="el" href="a00115.html#a91319dbc0d0e1bf3a3efc4d92bac7972">bm::set_block_size</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const unsigned char&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00115.html#ae34de9206be7a8aa05db9d5dc38bfc90">ibpc_uncompr</a> = 0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const unsigned char&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00115.html#aaca6d3c887b5b7b66a78e95471f9a326">ibpc_all_zero</a> = 1</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">!&lt; plain uncompressed  <a href="#aaca6d3c887b5b7b66a78e95471f9a326"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const unsigned char&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00115.html#aa6f59be0b838db693e0f081bcaf750f0">ibpc_all_one</a> = 2</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">!&lt; plain ALL ZERO  <a href="#aa6f59be0b838db693e0f081bcaf750f0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const unsigned char&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00115.html#a748d4095c39c9372a590b431e0ec17fe">ibpc_equiv</a> = 3</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">!&lt; plain ALL ONE  <a href="#a748d4095c39c9372a590b431e0ec17fe"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const unsigned char&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00115.html#aa61bf7691d32a9bc7c65c05bb62657e5">ibpc_close</a> = 4</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">!&lt; plain is equal to plain M  <a href="#aa61bf7691d32a9bc7c65c05bb62657e5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const unsigned char&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00115.html#ae4f14f0c2c5a9ee277808d36fd94693f">ibpc_end</a> = 8</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">!&lt; plain is close to plain M  <a href="#ae4f14f0c2c5a9ee277808d36fd94693f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const unsigned char&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00115.html#aa24e7c08930cf959d383c6b930fb0508">set_block_end</a> = 0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">End of serialization.  <a href="#aa24e7c08930cf959d383c6b930fb0508"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const unsigned char&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00115.html#a9e9cf918ca2ebec84eaf844d0e4c8bdb">set_block_1zero</a> = 1</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">One all-zero block.  <a href="#a9e9cf918ca2ebec84eaf844d0e4c8bdb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const unsigned char&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00115.html#a715131318a361bcccf59fc0b1e41d444">set_block_1one</a> = 2</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">One block all-set (1111...).  <a href="#a715131318a361bcccf59fc0b1e41d444"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const unsigned char&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00115.html#ac9b85b261ab49b37d5e15b84ed2d8b99">set_block_8zero</a> = 3</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Up to 256 zero blocks.  <a href="#ac9b85b261ab49b37d5e15b84ed2d8b99"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const unsigned char&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00115.html#a57ad1090d6f380cf5de5f98c699b5a75">set_block_8one</a> = 4</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Up to 256 all-set blocks.  <a href="#a57ad1090d6f380cf5de5f98c699b5a75"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const unsigned char&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00115.html#aef47eda6538ebf2624c1612d35694c01">set_block_16zero</a> = 5</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Up to 65536 zero blocks.  <a href="#aef47eda6538ebf2624c1612d35694c01"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const unsigned char&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00115.html#a3fad4a939708df59b1201910c7d37e30">set_block_16one</a> = 6</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">UP to 65536 all-set blocks.  <a href="#a3fad4a939708df59b1201910c7d37e30"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const unsigned char&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00115.html#ac7dfbd94a0534df88849bbce9e6c419a">set_block_32zero</a> = 7</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Up to 4G zero blocks.  <a href="#ac7dfbd94a0534df88849bbce9e6c419a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const unsigned char&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00115.html#a5b87c58ae617ad1f104b4c6bc3ed6447">set_block_32one</a> = 8</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">UP to 4G all-set blocks.  <a href="#a5b87c58ae617ad1f104b4c6bc3ed6447"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const unsigned char&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00115.html#ae87b5c61d7ba6e2e592a279db0b21cc0">set_block_azero</a> = 9</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">All other blocks zero.  <a href="#ae87b5c61d7ba6e2e592a279db0b21cc0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const unsigned char&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00115.html#ad506b63262c52870758432a95e71907e">set_block_aone</a> = 10</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">All other blocks one.  <a href="#ad506b63262c52870758432a95e71907e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const unsigned char&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00115.html#aef86ab2eb42c198272eea7cdfe42951b">set_block_bit</a> = 11</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Plain bit block.  <a href="#aef86ab2eb42c198272eea7cdfe42951b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const unsigned char&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00115.html#afe4b1011b09271c5f3882b926e250d39">set_block_sgapbit</a> = 12</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">SGAP compressed bitblock.  <a href="#afe4b1011b09271c5f3882b926e250d39"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const unsigned char&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00115.html#ab3a8d57c0b898c3c5a23cd27a8f856ad">set_block_sgapgap</a> = 13</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">SGAP compressed GAP block.  <a href="#ab3a8d57c0b898c3c5a23cd27a8f856ad"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const unsigned char&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00115.html#a09b8c4b17b7d6f613c237c46d04a9cd6">set_block_gap</a> = 14</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Plain GAP block.  <a href="#a09b8c4b17b7d6f613c237c46d04a9cd6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const unsigned char&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00115.html#a77dc965397e31a1d39c3d8e628792779">set_block_gapbit</a> = 15</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">GAP compressed bitblock.  <a href="#a77dc965397e31a1d39c3d8e628792779"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const unsigned char&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00115.html#a6ec6acb175ce77a229003f088ecd3923">set_block_arrbit</a> = 16</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">List of bits ON.  <a href="#a6ec6acb175ce77a229003f088ecd3923"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const unsigned char&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00115.html#a0f2d3289a95dc3bd224a6a73c3d3afce">set_block_bit_interval</a> = 17</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Interval block.  <a href="#a0f2d3289a95dc3bd224a6a73c3d3afce"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const unsigned char&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00115.html#aae33ceefae804cdd94412beee8c52720">set_block_arrgap</a> = 18</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">List of bits ON (GAP block).  <a href="#aae33ceefae804cdd94412beee8c52720"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const unsigned char&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00115.html#ad0e6607a9771fa49a658c3078208c2dc">set_block_bit_1bit</a> = 19</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Bit block with 1 bit ON.  <a href="#ad0e6607a9771fa49a658c3078208c2dc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const unsigned char&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00115.html#ac47dea3917e15264ed3ba0cf4055adbe">set_block_gap_egamma</a> = 20</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gamma compressed GAP block.  <a href="#ac47dea3917e15264ed3ba0cf4055adbe"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const unsigned char&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00115.html#a9674ddb1b9ee66948465249688708188">set_block_arrgap_egamma</a> = 21</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gamma compressed delta GAP array.  <a href="#a9674ddb1b9ee66948465249688708188"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const unsigned char&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00115.html#a5e21adca3bc6902f33e43e5cfd824f0e">set_block_bit_0runs</a> = 22</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Bit block with encoded zero intervals.  <a href="#a5e21adca3bc6902f33e43e5cfd824f0e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const unsigned char&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00115.html#a1caddb62b332a568ba590794800610f6">set_block_arrgap_egamma_inv</a> = 23</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gamma compressed inverted delta GAP array.  <a href="#a1caddb62b332a568ba590794800610f6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const unsigned char&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00115.html#a746a03f6f5563cc8c75db93bba40095d">set_block_arrgap_inv</a> = 24</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">List of bits OFF (GAP block).  <a href="#a746a03f6f5563cc8c75db93bba40095d"></a><br/></td></tr>
</table>
<hr/><h2>Typedef Documentation</h2>
<a class="anchor" id="ad93f96a77f223240b8c6b8f81c5db840"></a><!-- doxytag: member="bm::bit_operation_count_func_type" ref="ad93f96a77f223240b8c6b8f81c5db840" args=")(const bm::word_t *BMRESTRICT, const bm::word_t *BMRESTRICT, const bm::word_t *BMRESTRICT)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="a00115.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a>(* <a class="el" href="a00115.html#ad93f96a77f223240b8c6b8f81c5db840">bm::bit_operation_count_func_type</a>)(const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *BMRESTRICT, const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *BMRESTRICT, const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *BMRESTRICT)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="a00093_source.html#l05197">5197</a> of file <a class="el" href="a00093_source.html">bmfunc.h</a>.</p>

</div>
</div>
<a class="anchor" id="ac36d9b78ebf78baf0b92dc61487d9847"></a><!-- doxytag: member="bm::decoder_big_endian" ref="ac36d9b78ebf78baf0b92dc61487d9847" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="a00053.html">decoder</a> <a class="el" href="a00053.html">bm::decoder_big_endian</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Class for decoding data from memory buffer. </p>
<p>Properly handles aligment issues with integer data types. Converts data to big endian architecture (presumed it was encoded as little endian) </p>

<p>Definition at line <a class="el" href="a00104_source.html#l00114">114</a> of file <a class="el" href="a00104_source.html">encoding.h</a>.</p>

</div>
</div>
<a class="anchor" id="a8402de852093e5b23b5825f1974b9c12"></a><!-- doxytag: member="bm::gap_operation_func_type" ref="a8402de852093e5b23b5825f1974b9c12" args=")(const gap_word_t *BMRESTRICT, const gap_word_t *BMRESTRICT, gap_word_t *BMRESTRICT, unsigned &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="a00115.html#ac654d6319039a86546d235a236fc7cf6">gap_word_t</a>*(* <a class="el" href="a00115.html#a8402de852093e5b23b5825f1974b9c12">bm::gap_operation_func_type</a>)(const <a class="el" href="a00115.html#ac654d6319039a86546d235a236fc7cf6">gap_word_t</a> *BMRESTRICT, const <a class="el" href="a00115.html#ac654d6319039a86546d235a236fc7cf6">gap_word_t</a> *BMRESTRICT, <a class="el" href="a00115.html#ac654d6319039a86546d235a236fc7cf6">gap_word_t</a> *BMRESTRICT, unsigned &amp;)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="a00093_source.html#l05191">5191</a> of file <a class="el" href="a00093_source.html">bmfunc.h</a>.</p>

</div>
</div>
<a class="anchor" id="a18a8f03b151ca3a6d5e39e7709fb6c7c"></a><!-- doxytag: member="bm::gap_operation_to_bitset_func_type" ref="a18a8f03b151ca3a6d5e39e7709fb6c7c" args=")(unsigned *, const gap_word_t *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* <a class="el" href="a00115.html#a18a8f03b151ca3a6d5e39e7709fb6c7c">bm::gap_operation_to_bitset_func_type</a>)(unsigned *, const <a class="el" href="a00115.html#ac654d6319039a86546d235a236fc7cf6">gap_word_t</a> *)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="a00093_source.html#l05187">5187</a> of file <a class="el" href="a00093_source.html">bmfunc.h</a>.</p>

</div>
</div>
<a class="anchor" id="ac654d6319039a86546d235a236fc7cf6"></a><!-- doxytag: member="bm::gap_word_t" ref="ac654d6319039a86546d235a236fc7cf6" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef unsigned short <a class="el" href="a00115.html#ac654d6319039a86546d235a236fc7cf6">bm::gap_word_t</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="a00091_source.html#l00068">68</a> of file <a class="el" href="a00091_source.html">bmconst.h</a>.</p>

</div>
</div>
<a class="anchor" id="a1f6a6dd108cd9e9f4fb284043ef518fe"></a><!-- doxytag: member="bm::id64_t" ref="a1f6a6dd108cd9e9f4fb284043ef518fe" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef unsigned long long <a class="el" href="a00115.html#a1f6a6dd108cd9e9f4fb284043ef518fe">bm::id64_t</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="a00091_source.html#l00038">38</a> of file <a class="el" href="a00091_source.html">bmconst.h</a>.</p>

</div>
</div>
<a class="anchor" id="aa3824d882a037396370b16f2f0a8bf37"></a><!-- doxytag: member="bm::id_t" ref="aa3824d882a037396370b16f2f0a8bf37" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef unsigned int <a class="el" href="a00115.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="a00091_source.html#l00042">42</a> of file <a class="el" href="a00091_source.html">bmconst.h</a>.</p>

</div>
</div>
<a class="anchor" id="ae64960202b691ae1b6efe5fec12cb5af"></a><!-- doxytag: member="bm::short_t" ref="ae64960202b691ae1b6efe5fec12cb5af" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef unsigned short <a class="el" href="a00115.html#ae64960202b691ae1b6efe5fec12cb5af">bm::short_t</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="a00091_source.html#l00044">44</a> of file <a class="el" href="a00091_source.html">bmconst.h</a>.</p>

</div>
</div>
<a class="anchor" id="a17fd5ba52db3ddda05e6f8dd5000a1a4"></a><!-- doxytag: member="bm::word_t" ref="a17fd5ba52db3ddda05e6f8dd5000a1a4" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef unsigned int <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="a00006.html#a3">sample6.cpp</a>.</dd>
</dl>
<p>Definition at line <a class="el" href="a00091_source.html#l00043">43</a> of file <a class="el" href="a00091_source.html">bmconst.h</a>.</p>

</div>
</div>
<a class="anchor" id="a7176bf7817550ca24cb6612bd8d7957d"></a><!-- doxytag: member="bm::wordop_t" ref="a7176bf7817550ca24cb6612bd8d7957d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">word_t</a> <a class="el" href="a00115.html#a7176bf7817550ca24cb6612bd8d7957d">bm::wordop_t</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="a00091_source.html#l00101">101</a> of file <a class="el" href="a00091_source.html">bmconst.h</a>.</p>

</div>
</div>
<hr/><h2>Enumeration Type Documentation</h2>
<a class="anchor" id="a577905b348676c2bc556b51793350dbb"></a><!-- doxytag: member="bm::ByteOrder" ref="a577905b348676c2bc556b51793350dbb" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="a00115.html#a577905b348676c2bc556b51793350dbb">bm::ByteOrder</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Byte orders recognized by the library. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="a577905b348676c2bc556b51793350dbbac959b97503c42581f3dd81fd3b93fff2"></a><!-- doxytag: member="BigEndian" ref="a577905b348676c2bc556b51793350dbbac959b97503c42581f3dd81fd3b93fff2" args="" -->BigEndian</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a577905b348676c2bc556b51793350dbba5ebe266b6d18ee74483c2bbf624e2cc2"></a><!-- doxytag: member="LittleEndian" ref="a577905b348676c2bc556b51793350dbba5ebe266b6d18ee74483c2bbf624e2cc2" args="" -->LittleEndian</em>&nbsp;</td><td>
</td></tr>
</table>
</dd>
</dl>

<p>Definition at line <a class="el" href="a00093_source.html#l00397">397</a> of file <a class="el" href="a00093_source.html">bmfunc.h</a>.</p>

</div>
</div>
<a class="anchor" id="a42405343976ec931388381cea4092bf1"></a><!-- doxytag: member="bm::operation" ref="a42405343976ec931388381cea4092bf1" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="a00115.html#a42405343976ec931388381cea4092bf1">bm::operation</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Bit operations enumeration. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="a42405343976ec931388381cea4092bf1a546fdf33b301e5b9bee0591522ed9250"></a><!-- doxytag: member="BM_AND" ref="a42405343976ec931388381cea4092bf1a546fdf33b301e5b9bee0591522ed9250" args="" -->BM_AND</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a42405343976ec931388381cea4092bf1a0c8cf0197857d0bd73a63037e2f2c5c5"></a><!-- doxytag: member="BM_OR" ref="a42405343976ec931388381cea4092bf1a0c8cf0197857d0bd73a63037e2f2c5c5" args="" -->BM_OR</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a42405343976ec931388381cea4092bf1a1df0f4de7126bb2f7ce69d7a005affb5"></a><!-- doxytag: member="BM_SUB" ref="a42405343976ec931388381cea4092bf1a1df0f4de7126bb2f7ce69d7a005affb5" args="" -->BM_SUB</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a42405343976ec931388381cea4092bf1a45c2fe36efb72dc03f03a842d253f64c"></a><!-- doxytag: member="BM_XOR" ref="a42405343976ec931388381cea4092bf1a45c2fe36efb72dc03f03a842d253f64c" args="" -->BM_XOR</em>&nbsp;</td><td>
</td></tr>
</table>
</dd>
</dl>

<p>Definition at line <a class="el" href="a00093_source.html#l00274">274</a> of file <a class="el" href="a00093_source.html">bmfunc.h</a>.</p>

</div>
</div>
<a class="anchor" id="ab69f66b71d349b0757370f54318bb2c0"></a><!-- doxytag: member="bm::serialization_header_mask" ref="ab69f66b71d349b0757370f54318bb2c0" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="a00115.html#ab69f66b71d349b0757370f54318bb2c0">bm::serialization_header_mask</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="ab69f66b71d349b0757370f54318bb2c0a97434d6617bb5f0d6f3bf44491f712ca"></a><!-- doxytag: member="BM_HM_DEFAULT" ref="ab69f66b71d349b0757370f54318bb2c0a97434d6617bb5f0d6f3bf44491f712ca" args="" -->BM_HM_DEFAULT</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ab69f66b71d349b0757370f54318bb2c0af4fbefa0ed0a8ff42dd664f120782c27"></a><!-- doxytag: member="BM_HM_RESIZE" ref="ab69f66b71d349b0757370f54318bb2c0af4fbefa0ed0a8ff42dd664f120782c27" args="" -->BM_HM_RESIZE</em>&nbsp;</td><td>
<p>resized vector </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ab69f66b71d349b0757370f54318bb2c0a64c44c57a6f8b8e89f0916db9e120d47"></a><!-- doxytag: member="BM_HM_ID_LIST" ref="ab69f66b71d349b0757370f54318bb2c0a64c44c57a6f8b8e89f0916db9e120d47" args="" -->BM_HM_ID_LIST</em>&nbsp;</td><td>
<p>id list stored </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ab69f66b71d349b0757370f54318bb2c0a6b127bde401907318702dd4827c8f74e"></a><!-- doxytag: member="BM_HM_NO_BO" ref="ab69f66b71d349b0757370f54318bb2c0a6b127bde401907318702dd4827c8f74e" args="" -->BM_HM_NO_BO</em>&nbsp;</td><td>
<p>no byte-order </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ab69f66b71d349b0757370f54318bb2c0a04c714af376c203bc8b082856ad622a3"></a><!-- doxytag: member="BM_HM_NO_GAPL" ref="ab69f66b71d349b0757370f54318bb2c0a04c714af376c203bc8b082856ad622a3" args="" -->BM_HM_NO_GAPL</em>&nbsp;</td><td>
<p>no GAP levels </p>
</td></tr>
</table>
</dd>
</dl>

<p>Definition at line <a class="el" href="a00096_source.html#l00096">96</a> of file <a class="el" href="a00096_source.html">bmserial.h</a>.</p>

</div>
</div>
<a class="anchor" id="a76b70d2b9182a6dcac151d1bd9ec6109"></a><!-- doxytag: member="bm::set_operation" ref="a76b70d2b9182a6dcac151d1bd9ec6109" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="a00115.html#a76b70d2b9182a6dcac151d1bd9ec6109">bm::set_operation</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Nomenclature of set operations. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="a76b70d2b9182a6dcac151d1bd9ec6109a949fba4d9b152e1cbba9a450e05e21a3"></a><!-- doxytag: member="set_AND" ref="a76b70d2b9182a6dcac151d1bd9ec6109a949fba4d9b152e1cbba9a450e05e21a3" args="" -->set_AND</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a76b70d2b9182a6dcac151d1bd9ec6109a05d88a2639cbd3d2ac63436df3ed6780"></a><!-- doxytag: member="set_OR" ref="a76b70d2b9182a6dcac151d1bd9ec6109a05d88a2639cbd3d2ac63436df3ed6780" args="" -->set_OR</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a76b70d2b9182a6dcac151d1bd9ec6109a348f23af148237ac49194815b222b769"></a><!-- doxytag: member="set_SUB" ref="a76b70d2b9182a6dcac151d1bd9ec6109a348f23af148237ac49194815b222b769" args="" -->set_SUB</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a76b70d2b9182a6dcac151d1bd9ec6109ab823123a0d630167532a96be004e6304"></a><!-- doxytag: member="set_XOR" ref="a76b70d2b9182a6dcac151d1bd9ec6109ab823123a0d630167532a96be004e6304" args="" -->set_XOR</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a76b70d2b9182a6dcac151d1bd9ec6109a34150dd6a8ac2e70b887565bd1c3f788"></a><!-- doxytag: member="set_ASSIGN" ref="a76b70d2b9182a6dcac151d1bd9ec6109a34150dd6a8ac2e70b887565bd1c3f788" args="" -->set_ASSIGN</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a76b70d2b9182a6dcac151d1bd9ec6109a3f165b7944e33214e8721aaf2eb8378e"></a><!-- doxytag: member="set_COUNT" ref="a76b70d2b9182a6dcac151d1bd9ec6109a3f165b7944e33214e8721aaf2eb8378e" args="" -->set_COUNT</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a76b70d2b9182a6dcac151d1bd9ec6109a378be4b14cee6a341e859fd3157ab959"></a><!-- doxytag: member="set_COUNT_AND" ref="a76b70d2b9182a6dcac151d1bd9ec6109a378be4b14cee6a341e859fd3157ab959" args="" -->set_COUNT_AND</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a76b70d2b9182a6dcac151d1bd9ec6109a1373054e4f243dffb762a55b8a8bfe4c"></a><!-- doxytag: member="set_COUNT_XOR" ref="a76b70d2b9182a6dcac151d1bd9ec6109a1373054e4f243dffb762a55b8a8bfe4c" args="" -->set_COUNT_XOR</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a76b70d2b9182a6dcac151d1bd9ec6109a27e34c148d06e3d8a405482d820cd7fb"></a><!-- doxytag: member="set_COUNT_OR" ref="a76b70d2b9182a6dcac151d1bd9ec6109a27e34c148d06e3d8a405482d820cd7fb" args="" -->set_COUNT_OR</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a76b70d2b9182a6dcac151d1bd9ec6109a0028cc7084b37fe66ce5ae459b93b7f1"></a><!-- doxytag: member="set_COUNT_SUB_AB" ref="a76b70d2b9182a6dcac151d1bd9ec6109a0028cc7084b37fe66ce5ae459b93b7f1" args="" -->set_COUNT_SUB_AB</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a76b70d2b9182a6dcac151d1bd9ec6109a2f7b894c11c058598d02722a7eeef03b"></a><!-- doxytag: member="set_COUNT_SUB_BA" ref="a76b70d2b9182a6dcac151d1bd9ec6109a2f7b894c11c058598d02722a7eeef03b" args="" -->set_COUNT_SUB_BA</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a76b70d2b9182a6dcac151d1bd9ec6109abafe8a971864164aeec7f43d1205ed29"></a><!-- doxytag: member="set_COUNT_A" ref="a76b70d2b9182a6dcac151d1bd9ec6109abafe8a971864164aeec7f43d1205ed29" args="" -->set_COUNT_A</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a76b70d2b9182a6dcac151d1bd9ec6109a2ac4eb7f41d00f8387d5dd3ffb9d0617"></a><!-- doxytag: member="set_COUNT_B" ref="a76b70d2b9182a6dcac151d1bd9ec6109a2ac4eb7f41d00f8387d5dd3ffb9d0617" args="" -->set_COUNT_B</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a76b70d2b9182a6dcac151d1bd9ec6109ad894d257a23664720dbf4155153a1e5c"></a><!-- doxytag: member="set_END" ref="a76b70d2b9182a6dcac151d1bd9ec6109ad894d257a23664720dbf4155153a1e5c" args="" -->set_END</em>&nbsp;</td><td>
</td></tr>
</table>
</dd>
</dl>

<p>Definition at line <a class="el" href="a00093_source.html#l00245">245</a> of file <a class="el" href="a00093_source.html">bmfunc.h</a>.</p>

</div>
</div>
<a class="anchor" id="a593916a103395805070a3200720c6416"></a><!-- doxytag: member="bm::set_representation" ref="a593916a103395805070a3200720c6416" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="a00115.html#a593916a103395805070a3200720c6416">bm::set_representation</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>set representation variants </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="a593916a103395805070a3200720c6416a11f970b705c57a0572043e5cc5e2e333"></a><!-- doxytag: member="set_bitset" ref="a593916a103395805070a3200720c6416a11f970b705c57a0572043e5cc5e2e333" args="" -->set_bitset</em>&nbsp;</td><td>
<p>Simple bitset. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a593916a103395805070a3200720c6416a4809f1871df2ba431e5b70d175f050ec"></a><!-- doxytag: member="set_gap" ref="a593916a103395805070a3200720c6416a4809f1871df2ba431e5b70d175f050ec" args="" -->set_gap</em>&nbsp;</td><td>
<p>GAP-RLE compression. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a593916a103395805070a3200720c6416a4bd710c312645ed34e4db359a7e59c42"></a><!-- doxytag: member="set_array1" ref="a593916a103395805070a3200720c6416a4bd710c312645ed34e4db359a7e59c42" args="" -->set_array1</em>&nbsp;</td><td>
<p>array of set 1 values </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a593916a103395805070a3200720c6416a8d71ac8a4f70b88d2a425d0c1e872fa2"></a><!-- doxytag: member="set_array0" ref="a593916a103395805070a3200720c6416a8d71ac8a4f70b88d2a425d0c1e872fa2" args="" -->set_array0</em>&nbsp;</td><td>
<p>array of 0 values </p>
</td></tr>
</table>
</dd>
</dl>

<p>Definition at line <a class="el" href="a00091_source.html#l00126">126</a> of file <a class="el" href="a00091_source.html">bmconst.h</a>.</p>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="a8d943cf66c4592e2baddf5bc0667adbd"></a><!-- doxytag: member="bm::and_op" ref="a8d943cf66c4592e2baddf5bc0667adbd" args="(unsigned v1, unsigned v2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BMFORCEINLINE unsigned bm::and_op </td>
          <td>(</td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>v2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>GAP and functor. </p>

<p>Definition at line <a class="el" href="a00093_source.html#l03143">3143</a> of file <a class="el" href="a00093_source.html">bmfunc.h</a>.</p>

<p>Referenced by <a class="el" href="a00093_source.html#l03227">gap_count_and()</a>, <a class="el" href="a00093_source.html#l03186">gap_operation_and()</a>, <a class="el" href="a00093_source.html#l03210">gap_operation_any_and()</a>, <a class="el" href="a00093_source.html#l03388">gap_operation_any_sub()</a>, <a class="el" href="a00093_source.html#l03318">gap_operation_or()</a>, and <a class="el" href="a00093_source.html#l03363">gap_operation_sub()</a>.</p>

</div>
</div>
<a class="anchor" id="ae2222be6fd45b4bab5100ce70e3b4f88"></a><!-- doxytag: member="bm::bit_count_change32" ref="ae2222be6fd45b4bab5100ce70e3b4f88" args="(const bm::word_t *block, const bm::word_t *block_end, unsigned *bit_count, unsigned *gap_count)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bm::bit_count_change32 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *&nbsp;</td>
          <td class="paramname"> <em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *&nbsp;</td>
          <td class="paramname"> <em>block_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned *&nbsp;</td>
          <td class="paramname"> <em>bit_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned *&nbsp;</td>
          <td class="paramname"> <em>gap_count</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Function calculates number of times when bit value changed </p>

<p>Definition at line <a class="el" href="a00093_source.html#l02802">2802</a> of file <a class="el" href="a00093_source.html">bmfunc.h</a>.</p>

<p>References <a class="el" href="a00092_source.html#l00050">BM_ASSERT</a>, and <a class="el" href="a00092_source.html#l00159">BM_INCWORD_BITCOUNT</a>.</p>

<p>Referenced by <a class="el" href="a00093_source.html#l02864">bit_block_calc_count_change()</a>, and <a class="el" href="a00100_source.html#l00687">compute_tmatrix_rstat()</a>.</p>

</div>
</div>
<a class="anchor" id="adfae226f696ef821c7d351216c00fe0d"></a><!-- doxytag: member="bm::bit_iblock_pcv_stat" ref="adfae226f696ef821c7d351216c00fe0d" args="(const unsigned char *BMRESTRICT pc_vector, const unsigned char *BMRESTRICT pc_vector_end, unsigned *BMRESTRICT pc_vector_stat)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bm::bit_iblock_pcv_stat </td>
          <td>(</td>
          <td class="paramtype">const unsigned char *BMRESTRICT&nbsp;</td>
          <td class="paramname"> <em>pc_vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned char *BMRESTRICT&nbsp;</td>
          <td class="paramname"> <em>pc_vector_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned *BMRESTRICT&nbsp;</td>
          <td class="paramname"> <em>pc_vector_stat</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute number of ibpc codes in pc_vector. </p>

<p>Definition at line <a class="el" href="a00100_source.html#l00478">478</a> of file <a class="el" href="a00100_source.html">bmtrans.h</a>.</p>

<p>References <a class="el" href="a00092_source.html#l00050">BM_ASSERT</a>.</p>

<p>Referenced by <a class="el" href="a00100_source.html#l00830">bm::gap_transpose_engine&lt; GT, BT, BLOCK_SIZE &gt;::compute_distance_matrix()</a>.</p>

</div>
</div>
<a class="anchor" id="a62808b64adfcf2a7e610a4f713f470c0"></a><!-- doxytag: member="bm::bit_iblock_reduce" ref="a62808b64adfcf2a7e610a4f713f470c0" args="(const unsigned tmatrix[bm::set_block_plain_cnt][bm::set_block_plain_size], const unsigned char *BMRESTRICT pc_vector, const unsigned char *BMRESTRICT pc_vector_end, unsigned tmatrix_out[bm::set_block_plain_cnt][bm::set_block_plain_size])" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bm::bit_iblock_reduce </td>
          <td>(</td>
          <td class="paramtype">const unsigned&nbsp;</td>
          <td class="paramname"> <em>tmatrix</em>[bm::set_block_plain_cnt][bm::set_block_plain_size], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned char *BMRESTRICT&nbsp;</td>
          <td class="paramname"> <em>pc_vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned char *BMRESTRICT&nbsp;</td>
          <td class="paramname"> <em>pc_vector_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>tmatrix_out</em>[bm::set_block_plain_cnt][bm::set_block_plain_size]</td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Matrix reduction based on transformation pc vector. </p>

<p>Definition at line <a class="el" href="a00100_source.html#l00498">498</a> of file <a class="el" href="a00100_source.html">bmtrans.h</a>.</p>

<p>References <a class="el" href="a00092_source.html#l00050">BM_ASSERT</a>, <a class="el" href="a00100_source.html#l00390">ibpc_all_one</a>, <a class="el" href="a00100_source.html#l00389">ibpc_all_zero</a>, <a class="el" href="a00100_source.html#l00392">ibpc_close</a>, <a class="el" href="a00100_source.html#l00391">ibpc_equiv</a>, and <a class="el" href="a00100_source.html#l00388">ibpc_uncompr</a>.</p>

</div>
</div>
<a class="anchor" id="a503fecc0ee281059897412d68f489e1e"></a><!-- doxytag: member="bm::bit_recomb" ref="a503fecc0ee281059897412d68f489e1e" args="(It1 &amp;it1, It2 &amp;it2, BinaryOp &amp;op, Encoder &amp;enc, unsigned block_size=bm::set_block_size)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class It1 , class It2 , class BinaryOp , class Encoder &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void bm::bit_recomb </td>
          <td>(</td>
          <td class="paramtype">It1 &amp;&nbsp;</td>
          <td class="paramname"> <em>it1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">It2 &amp;&nbsp;</td>
          <td class="paramname"> <em>it2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BinaryOp &amp;&nbsp;</td>
          <td class="paramname"> <em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Encoder &amp;&nbsp;</td>
          <td class="paramname"> <em>enc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>block_size</em> = <code><a class="el" href="a00115.html#a91319dbc0d0e1bf3a3efc4d92bac7972">bm::set_block_size</a></code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Abstract recombination algorithm for two bit-blocks Bit blocks can come as dserialization decoders or bit-streams </p>

<p>Definition at line <a class="el" href="a00093_source.html#l05053">5053</a> of file <a class="el" href="a00093_source.html">bmfunc.h</a>.</p>

<p>Referenced by <a class="el" href="a00096_source.html#l02403">bm::serial_stream_iterator&lt; DEC &gt;::get_bit_block_COUNT_OR()</a>, <a class="el" href="a00096_source.html#l02559">bm::serial_stream_iterator&lt; DEC &gt;::get_bit_block_COUNT_SUB_AB()</a>, <a class="el" href="a00096_source.html#l02638">bm::serial_stream_iterator&lt; DEC &gt;::get_bit_block_COUNT_SUB_BA()</a>, <a class="el" href="a00096_source.html#l02481">bm::serial_stream_iterator&lt; DEC &gt;::get_bit_block_COUNT_XOR()</a>, and <a class="el" href="a00096_source.html#l01972">bm::serial_stream_iterator&lt; DEC &gt;::get_bit_block_OR()</a>.</p>

</div>
</div>
<a class="anchor" id="a7267df2bcc9c575c50dd1c68589c6ac1"></a><!-- doxytag: member="bm::bit_scan_fwd" ref="a7267df2bcc9c575c50dd1c68589c6ac1" args="(T v)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T bm::bit_scan_fwd </td>
          <td>(</td>
          <td class="paramtype">T&nbsp;</td>
          <td class="paramname"> <em>v</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="a00102_source.html#l00058">58</a> of file <a class="el" href="a00102_source.html">bmutil.h</a>.</p>

<p>Referenced by <a class="el" href="a00104_source.html#l00343">bm::bit_in&lt; TDecoder &gt;::gamma()</a>.</p>

</div>
</div>
<a class="anchor" id="a86d5d5ccdb79d2b2ad552bd1caf34b2f"></a><!-- doxytag: member="bm::block_range_scan" ref="a86d5d5ccdb79d2b2ad552bd1caf34b2f" args="(It first, It last, unsigned nblock, unsigned *max_id)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class It &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">It bm::block_range_scan </td>
          <td>(</td>
          <td class="paramtype">It&nbsp;</td>
          <td class="paramname"> <em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">It&nbsp;</td>
          <td class="paramname"> <em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>nblock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned *&nbsp;</td>
          <td class="paramname"> <em>max_id</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Internal algorithms scans the input for the block range limit. </p>

<p>Definition at line <a class="el" href="a00089_source.html#l01111">1111</a> of file <a class="el" href="a00089_source.html">bmalgo_impl.h</a>.</p>

<p>References <a class="el" href="a00092_source.html#l00050">BM_ASSERT</a>, <a class="el" href="a00091_source.html#l00048">id_max</a>, and <a class="el" href="a00091_source.html#l00053">set_block_shift</a>.</p>

<p>Referenced by <a class="el" href="a00089_source.html#l01141">combine_or()</a>, <a class="el" href="a00089_source.html#l01304">combine_sub()</a>, and <a class="el" href="a00089_source.html#l01220">combine_xor()</a>.</p>

</div>
</div>
<a class="anchor" id="abf587377ca70f11b8eb75f95494830b5"></a><!-- doxytag: member="bm::bmfor_each" ref="abf587377ca70f11b8eb75f95494830b5" args="(T first, T last, F f)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class F &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">F bm::bmfor_each </td>
          <td>(</td>
          <td class="paramtype">T&nbsp;</td>
          <td class="paramname"> <em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&nbsp;</td>
          <td class="paramname"> <em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F&nbsp;</td>
          <td class="paramname"> <em>f</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Special BM optimized analog of STL for_each </p>

<p>Definition at line <a class="el" href="a00093_source.html#l00646">646</a> of file <a class="el" href="a00093_source.html">bmfunc.h</a>.</p>

</div>
</div>
<a class="anchor" id="af901d98c77c801206fbede3f2c74d4b4"></a><!-- doxytag: member="bm::combine_any_operation_with_block" ref="af901d98c77c801206fbede3f2c74d4b4" args="(const bm::word_t *blk, unsigned gap, const bm::word_t *arg_blk, int arg_gap, distance_metric metric)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned bm::combine_any_operation_with_block </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *&nbsp;</td>
          <td class="paramname"> <em>blk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>gap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *&nbsp;</td>
          <td class="paramname"> <em>arg_blk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>arg_gap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">distance_metric&nbsp;</td>
          <td class="paramname"> <em>metric</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Convenience internal function to compute combine any for one metric </p>

<p>Definition at line <a class="el" href="a00089_source.html#l00638">638</a> of file <a class="el" href="a00089_source.html">bmalgo_impl.h</a>.</p>

<p>References <a class="el" href="a00089_source.html#l00366">combine_any_operation_with_block()</a>, and <a class="el" href="a00089_source.html#l00088">bm::distance_metric_descriptor::result</a>.</p>

</div>
</div>
<a class="anchor" id="a1e4a2084ce5e7bc77197b9c616004659"></a><!-- doxytag: member="bm::combine_any_operation_with_block" ref="a1e4a2084ce5e7bc77197b9c616004659" args="(const bm::word_t *blk, unsigned gap, const bm::word_t *arg_blk, int arg_gap, distance_metric_descriptor *dmit, distance_metric_descriptor *dmit_end)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bm::combine_any_operation_with_block </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *&nbsp;</td>
          <td class="paramname"> <em>blk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>gap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *&nbsp;</td>
          <td class="paramname"> <em>arg_blk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>arg_gap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">distance_metric_descriptor *&nbsp;</td>
          <td class="paramname"> <em>dmit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">distance_metric_descriptor *&nbsp;</td>
          <td class="paramname"> <em>dmit_end</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Internal function computes different existense of distance metric. </p>

<p>Definition at line <a class="el" href="a00089_source.html#l00366">366</a> of file <a class="el" href="a00089_source.html">bmalgo_impl.h</a>.</p>

<p>References <a class="el" href="a00093_source.html#l03123">bit_is_all_zero()</a>, <a class="el" href="a00093_source.html#l03890">bit_operation_and_any()</a>, <a class="el" href="a00093_source.html#l04028">bit_operation_or_any()</a>, <a class="el" href="a00093_source.html#l03966">bit_operation_sub_any()</a>, <a class="el" href="a00093_source.html#l04355">bit_operation_xor_any()</a>, <a class="el" href="a00092_source.html#l00144">BM_ALIGN16ATTR</a>, <a class="el" href="a00092_source.html#l00086">BMGAP_PTR</a>, <a class="el" href="a00089_source.html#l00062">COUNT_A</a>, <a class="el" href="a00089_source.html#l00057">COUNT_AND</a>, <a class="el" href="a00089_source.html#l00063">COUNT_B</a>, <a class="el" href="a00089_source.html#l00059">COUNT_OR</a>, <a class="el" href="a00089_source.html#l00060">COUNT_SUB_AB</a>, <a class="el" href="a00089_source.html#l00061">COUNT_SUB_BA</a>, <a class="el" href="a00089_source.html#l00058">COUNT_XOR</a>, <a class="el" href="a00093_source.html#l01837">gap_bitset_and_any()</a>, <a class="el" href="a00093_source.html#l02075">gap_bitset_or_any()</a>, <a class="el" href="a00093_source.html#l01909">gap_bitset_sub_any()</a>, <a class="el" href="a00093_source.html#l01985">gap_bitset_xor_any()</a>, <a class="el" href="a00093_source.html#l02144">gap_convert_to_bitset()</a>, <a class="el" href="a00093_source.html#l02352">gap_is_all_zero()</a>, <a class="el" href="a00091_source.html#l00072">gap_max_bits</a>, <a class="el" href="a00091_source.html#l00070">gap_max_buff_len</a>, <a class="el" href="a00093_source.html#l03210">gap_operation_any_and()</a>, <a class="el" href="a00093_source.html#l03388">gap_operation_any_sub()</a>, <a class="el" href="a00093_source.html#l03277">gap_operation_any_xor()</a>, <a class="el" href="a00093_source.html#l03318">gap_operation_or()</a>, <a class="el" href="a00089_source.html#l00087">bm::distance_metric_descriptor::metric</a>, <a class="el" href="a00089_source.html#l00088">bm::distance_metric_descriptor::result</a>, and <a class="el" href="a00091_source.html#l00052">set_block_size</a>.</p>

<p>Referenced by <a class="el" href="a00089_source.html#l00638">combine_any_operation_with_block()</a>, and <a class="el" href="a00089_source.html#l00853">distance_operation_any()</a>.</p>

</div>
</div>
<a class="anchor" id="ab8b78e416da269fca3dc03c98c00ac6a"></a><!-- doxytag: member="bm::combine_count_and_operation_with_block" ref="ab8b78e416da269fca3dc03c98c00ac6a" args="(const bm::word_t *blk, const bm::word_t *arg_blk)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned bm::combine_count_and_operation_with_block </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *&nbsp;</td>
          <td class="paramname"> <em>blk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *&nbsp;</td>
          <td class="paramname"> <em>arg_blk</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Internal function computes AND distance. </p>

<p>Definition at line <a class="el" href="a00089_source.html#l00329">329</a> of file <a class="el" href="a00089_source.html">bmalgo_impl.h</a>.</p>

<p>References <a class="el" href="a00093_source.html#l03867">bit_operation_and_count()</a>, <a class="el" href="a00092_source.html#l00088">BM_IS_GAP</a>, <a class="el" href="a00092_source.html#l00086">BMGAP_PTR</a>, <a class="el" href="a00093_source.html#l01806">gap_bitset_and_count()</a>, <a class="el" href="a00093_source.html#l03227">gap_count_and()</a>, and <a class="el" href="a00091_source.html#l00052">set_block_size</a>.</p>

<p>Referenced by <a class="el" href="a00089_source.html#l00783">distance_and_operation()</a>.</p>

</div>
</div>
<a class="anchor" id="a408a8c098c43feeb0af7af706c796650"></a><!-- doxytag: member="bm::combine_count_operation_with_block" ref="a408a8c098c43feeb0af7af706c796650" args="(const bm::word_t *blk, const bm::word_t *arg_blk, distance_metric metric)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned bm::combine_count_operation_with_block </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *&nbsp;</td>
          <td class="paramname"> <em>blk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *&nbsp;</td>
          <td class="paramname"> <em>arg_blk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">distance_metric&nbsp;</td>
          <td class="paramname"> <em>metric</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Convenience internal function to compute combine count for one metric </p>

<p>Definition at line <a class="el" href="a00089_source.html#l00619">619</a> of file <a class="el" href="a00089_source.html">bmalgo_impl.h</a>.</p>

<p>References <a class="el" href="a00089_source.html#l00116">combine_count_operation_with_block()</a>, and <a class="el" href="a00089_source.html#l00088">bm::distance_metric_descriptor::result</a>.</p>

</div>
</div>
<a class="anchor" id="a5e19a65218d5423e3ae1e426ac37a378"></a><!-- doxytag: member="bm::combine_count_operation_with_block" ref="a5e19a65218d5423e3ae1e426ac37a378" args="(const bm::word_t *blk, const bm::word_t *arg_blk, distance_metric_descriptor *dmit, distance_metric_descriptor *dmit_end)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bm::combine_count_operation_with_block </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *&nbsp;</td>
          <td class="paramname"> <em>blk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a> *&nbsp;</td>
          <td class="paramname"> <em>arg_blk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">distance_metric_descriptor *&nbsp;</td>
          <td class="paramname"> <em>dmit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">distance_metric_descriptor *&nbsp;</td>
          <td class="paramname"> <em>dmit_end</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Internal function computes different distance metrics. </p>

<p>Definition at line <a class="el" href="a00089_source.html#l00116">116</a> of file <a class="el" href="a00089_source.html">bmalgo_impl.h</a>.</p>

<p>References <a class="el" href="a00093_source.html#l02726">bit_block_calc_count()</a>, <a class="el" href="a00093_source.html#l05225">bm::operation_functions&lt; T &gt;::bit_operation_count()</a>, <a class="el" href="a00093_source.html#l03915">bit_operation_sub_count()</a>, <a class="el" href="a00092_source.html#l00144">BM_ALIGN16ATTR</a>, <a class="el" href="a00092_source.html#l00050">BM_ASSERT</a>, <a class="el" href="a00092_source.html#l00088">BM_IS_GAP</a>, <a class="el" href="a00092_source.html#l00086">BMGAP_PTR</a>, <a class="el" href="a00089_source.html#l00062">COUNT_A</a>, <a class="el" href="a00089_source.html#l00057">COUNT_AND</a>, <a class="el" href="a00089_source.html#l00063">COUNT_B</a>, <a class="el" href="a00089_source.html#l00059">COUNT_OR</a>, <a class="el" href="a00089_source.html#l00060">COUNT_SUB_AB</a>, <a class="el" href="a00089_source.html#l00061">COUNT_SUB_BA</a>, <a class="el" href="a00089_source.html#l00058">COUNT_XOR</a>, <a class="el" href="a00093_source.html#l00678">gap_bit_count()</a>, <a class="el" href="a00093_source.html#l01806">gap_bitset_and_count()</a>, <a class="el" href="a00093_source.html#l02028">gap_bitset_or_count()</a>, <a class="el" href="a00093_source.html#l01876">gap_bitset_sub_count()</a>, <a class="el" href="a00093_source.html#l01947">gap_bitset_xor_count()</a>, <a class="el" href="a00093_source.html#l02144">gap_convert_to_bitset()</a>, <a class="el" href="a00093_source.html#l03227">gap_count_and()</a>, <a class="el" href="a00093_source.html#l03338">gap_count_or()</a>, <a class="el" href="a00093_source.html#l03405">gap_count_sub()</a>, <a class="el" href="a00093_source.html#l03293">gap_count_xor()</a>, <a class="el" href="a00089_source.html#l00087">bm::distance_metric_descriptor::metric</a>, <a class="el" href="a00089_source.html#l00088">bm::distance_metric_descriptor::result</a>, and <a class="el" href="a00091_source.html#l00052">set_block_size</a>.</p>

<p>Referenced by <a class="el" href="a00089_source.html#l00619">combine_count_operation_with_block()</a>, <a class="el" href="a00096_source.html#l03319">bm::iterator_deserializer&lt; BV, SerialIterator &gt;::deserialize()</a>, and <a class="el" href="a00089_source.html#l00693">distance_operation()</a>.</p>

</div>
</div>
<a class="anchor" id="a3788dd32c39556f0aef90b50e5a5e62c"></a><!-- doxytag: member="bm::compute_tmatrix_rstat" ref="a3788dd32c39556f0aef90b50e5a5e62c" args="(const TMatrix &amp;tmatrix, const unsigned char *pc_vector, typename TMatrix::rstat *rstat, unsigned effective_cols)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TMatrix &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void bm::compute_tmatrix_rstat </td>
          <td>(</td>
          <td class="paramtype">const TMatrix &amp;&nbsp;</td>
          <td class="paramname"> <em>tmatrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned char *&nbsp;</td>
          <td class="paramname"> <em>pc_vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename TMatrix::rstat *&nbsp;</td>
          <td class="paramname"> <em>rstat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>effective_cols</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute t-matrix rows statistics used for compression. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="a00086.html" title="Mini-matrix for bit transposition purposes.">tmatrix</a></em>&nbsp;</td><td>- transposed matrix </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pc_vector</em>&nbsp;</td><td>- row content vector </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rstat</em>&nbsp;</td><td>- output row vector </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="a00100_source.html#l00687">687</a> of file <a class="el" href="a00100_source.html">bmtrans.h</a>.</p>

<p>References <a class="el" href="a00093_source.html#l04713">best_representation()</a>, <a class="el" href="a00093_source.html#l02802">bit_count_change32()</a>, <a class="el" href="a00092_source.html#l00050">BM_ASSERT</a>, <a class="el" href="a00100_source.html#l00390">ibpc_all_one</a>, <a class="el" href="a00100_source.html#l00389">ibpc_all_zero</a>, <a class="el" href="a00100_source.html#l00392">ibpc_close</a>, <a class="el" href="a00100_source.html#l00391">ibpc_equiv</a>, <a class="el" href="a00100_source.html#l00388">ibpc_uncompr</a>, and <a class="el" href="a00091_source.html#l00128">set_bitset</a>.</p>

<p>Referenced by <a class="el" href="a00100_source.html#l00846">bm::gap_transpose_engine&lt; GT, BT, BLOCK_SIZE &gt;::reduce()</a>.</p>

</div>
</div>
<a class="anchor" id="a528894002dcd8edda28c8fb2b0aa8c64"></a><!-- doxytag: member="bm::dgap_2_gap" ref="a528894002dcd8edda28c8fb2b0aa8c64" args="(const T *dgap_buf, T *gap_buf, T gap_header=0)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void bm::dgap_2_gap </td>
          <td>(</td>
          <td class="paramtype">const T *&nbsp;</td>
          <td class="paramname"> <em>dgap_buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&nbsp;</td>
          <td class="paramname"> <em>gap_buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&nbsp;</td>
          <td class="paramname"> <em>gap_header</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convert D-GAP buffer into GAP buffer. </p>
<p>GAP representation is GAP[N] = DGAP[N] + DGAP[N-1]</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dgap_buf</em>&nbsp;</td><td>- Delta-GAP buffer </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>gap_buf</em>&nbsp;</td><td>- GAP buffer </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="a00093_source.html#l00826">826</a> of file <a class="el" href="a00093_source.html">bmfunc.h</a>.</p>

</div>
</div>
<a class="anchor" id="adfd7e03426f4b8c0952e97d43ed75abf"></a><!-- doxytag: member="bm::distance_stage" ref="adfd7e03426f4b8c0952e97d43ed75abf" args="(const distance_metric_descriptor *dmit, const distance_metric_descriptor *dmit_end, bool *is_all_and)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bm::distance_stage </td>
          <td>(</td>
          <td class="paramtype">const distance_metric_descriptor *&nbsp;</td>
          <td class="paramname"> <em>dmit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const distance_metric_descriptor *&nbsp;</td>
          <td class="paramname"> <em>dmit_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&nbsp;</td>
          <td class="paramname"> <em>is_all_and</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Staging function for distance operation. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>temp block allocated (or NULL) </dd></dl>

<p>Definition at line <a class="el" href="a00089_source.html#l00659">659</a> of file <a class="el" href="a00089_source.html">bmalgo_impl.h</a>.</p>

<p>References <a class="el" href="a00089_source.html#l00057">COUNT_AND</a>.</p>

<p>Referenced by <a class="el" href="a00089_source.html#l00693">distance_operation()</a>, and <a class="el" href="a00089_source.html#l00853">distance_operation_any()</a>.</p>

</div>
</div>
<a class="anchor" id="af92597461aff2926f9adcbf51bac98f9"></a><!-- doxytag: member="bm::find_effective_columns" ref="af92597461aff2926f9adcbf51bac98f9" args="(const TM &amp;tmatrix)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TM &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned bm::find_effective_columns </td>
          <td>(</td>
          <td class="paramtype">const TM &amp;&nbsp;</td>
          <td class="paramname"> <em>tmatrix</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute effective right column border of the t-matrix. </p>

<p>Definition at line <a class="el" href="a00100_source.html#l00745">745</a> of file <a class="el" href="a00100_source.html">bmtrans.h</a>.</p>

<p>Referenced by <a class="el" href="a00100_source.html#l00791">bm::gap_transpose_engine&lt; GT, BT, BLOCK_SIZE &gt;::transpose()</a>.</p>

</div>
</div>
<a class="anchor" id="a8abecc773e9aaee744215278d1e6924e"></a><!-- doxytag: member="bm::for_each_block" ref="a8abecc773e9aaee744215278d1e6924e" args="(T ***root, unsigned size1, F &amp;f)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class F &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void bm::for_each_block </td>
          <td>(</td>
          <td class="paramtype">T ***&nbsp;</td>
          <td class="paramname"> <em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>size1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F &amp;&nbsp;</td>
          <td class="paramname"> <em>f</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>For each block executes supplied function. </p>

<p>Definition at line <a class="el" href="a00093_source.html#l00617">617</a> of file <a class="el" href="a00093_source.html">bmfunc.h</a>.</p>

<p>References <a class="el" href="a00091_source.html#l00081">set_array_size</a>.</p>

<p>Referenced by <a class="el" href="a00089_source.html#l01441">count_intervals()</a>, and <a class="el" href="a00087_source.html#l01781">bm::bvector&lt; Alloc &gt;::invert()</a>.</p>

</div>
</div>
<a class="anchor" id="a6a7bfe8af49ed785f0e96c7ca37a2155"></a><!-- doxytag: member="bm::for_each_dgap" ref="a6a7bfe8af49ed785f0e96c7ca37a2155" args="(const T *gap_buf, Func &amp;func)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Func &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void bm::for_each_dgap </td>
          <td>(</td>
          <td class="paramtype">const T *&nbsp;</td>
          <td class="paramname"> <em>gap_buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func &amp;&nbsp;</td>
          <td class="paramname"> <em>func</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>D-GAP block for_each algorithm</p>
<p>D-Gap Functor is called for each element but last one.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>gap_buf</em>&nbsp;</td><td>- GAP buffer </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="a00093_source.html#l00761">761</a> of file <a class="el" href="a00093_source.html">bmfunc.h</a>.</p>

<p>Referenced by <a class="el" href="a00096_source.html#l00625">bm::serializer&lt; BV &gt;::gamma_gap_block()</a>.</p>

</div>
</div>
<a class="anchor" id="a46953a43cfc3da7192d883b6dd822d99"></a><!-- doxytag: member="bm::for_each_nzblock" ref="a46953a43cfc3da7192d883b6dd822d99" args="(T ***root, unsigned size1, F &amp;f)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class F &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void bm::for_each_nzblock </td>
          <td>(</td>
          <td class="paramtype">T ***&nbsp;</td>
          <td class="paramname"> <em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>size1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F &amp;&nbsp;</td>
          <td class="paramname"> <em>f</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>For each non-zero block executes supplied function. </p>

<p>Definition at line <a class="el" href="a00093_source.html#l00528">528</a> of file <a class="el" href="a00093_source.html">bmfunc.h</a>.</p>

<p>References <a class="el" href="a00091_source.html#l00081">set_array_size</a>.</p>

<p>Referenced by <a class="el" href="a00087_source.html#l01106">bm::bvector&lt; Alloc &gt;::count_blocks()</a>, <a class="el" href="a00087_source.html#l01838">bm::bvector&lt; Alloc &gt;::optimize()</a>, and <a class="el" href="a00087_source.html#l01901">bm::bvector&lt; Alloc &gt;::set_gap_levels()</a>.</p>

</div>
</div>
<a class="anchor" id="ac6f5529fcc26412fc796b85770aa3a26"></a><!-- doxytag: member="bm::for_each_nzblock2" ref="ac6f5529fcc26412fc796b85770aa3a26" args="(T ***root, unsigned size1, F &amp;f)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class F &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void bm::for_each_nzblock2 </td>
          <td>(</td>
          <td class="paramtype">T ***&nbsp;</td>
          <td class="paramname"> <em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>size1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F &amp;&nbsp;</td>
          <td class="paramname"> <em>f</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>For each non-zero block executes supplied function. </p>

<p>Definition at line <a class="el" href="a00093_source.html#l00564">564</a> of file <a class="el" href="a00093_source.html">bmfunc.h</a>.</p>

<p>References <a class="el" href="a00091_source.html#l00081">set_array_size</a>.</p>

<p>Referenced by <a class="el" href="a00087_source.html#l01647">bm::bvector&lt; Alloc &gt;::count()</a>.</p>

</div>
</div>
<a class="anchor" id="a5b4e99c8ed7b929be87bd5a1ad76fd37"></a><!-- doxytag: member="bm::for_each_nzblock_if" ref="a5b4e99c8ed7b929be87bd5a1ad76fd37" args="(T ***root, unsigned size1, F &amp;f)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class F &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bm::for_each_nzblock_if </td>
          <td>(</td>
          <td class="paramtype">T ***&nbsp;</td>
          <td class="paramname"> <em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>size1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F &amp;&nbsp;</td>
          <td class="paramname"> <em>f</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>For each non-zero block executes supplied function-predicate. Function returns if function-predicate returns true </p>

<p>Definition at line <a class="el" href="a00093_source.html#l00593">593</a> of file <a class="el" href="a00093_source.html">bmfunc.h</a>.</p>

<p>References <a class="el" href="a00091_source.html#l00081">set_array_size</a>.</p>

<p>Referenced by <a class="el" href="a00087_source.html#l01174">bm::bvector&lt; Alloc &gt;::any()</a>.</p>

</div>
</div>
<a class="anchor" id="a6d89da7149cc4444d699f4bfa442ab87"></a><!-- doxytag: member="bm::gap_2_bitblock" ref="a6d89da7149cc4444d699f4bfa442ab87" args="(const GT *BMRESTRICT gap_buf, GT *BMRESTRICT block, unsigned block_size)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void bm::gap_2_bitblock </td>
          <td>(</td>
          <td class="paramtype">const GT *BMRESTRICT&nbsp;</td>
          <td class="paramname"> <em>gap_buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GT *BMRESTRICT&nbsp;</td>
          <td class="paramname"> <em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>block_size</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copy GAP block body to bit block with DGap transformation. </p>

<p>Definition at line <a class="el" href="a00100_source.html#l00660">660</a> of file <a class="el" href="a00100_source.html">bmtrans.h</a>.</p>

<p>Referenced by <a class="el" href="a00100_source.html#l00791">bm::gap_transpose_engine&lt; GT, BT, BLOCK_SIZE &gt;::transpose()</a>.</p>

</div>
</div>
<a class="anchor" id="afa6ea0cce0cdd88738a01fad393376b3"></a><!-- doxytag: member="bm::gap_2_dgap" ref="afa6ea0cce0cdd88738a01fad393376b3" args="(const T *gap_buf, T *dgap_buf, bool copy_head=true)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T* bm::gap_2_dgap </td>
          <td>(</td>
          <td class="paramtype">const T *&nbsp;</td>
          <td class="paramname"> <em>gap_buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&nbsp;</td>
          <td class="paramname"> <em>dgap_buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>copy_head</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convert GAP buffer into D-GAP buffer. </p>
<p>Delta GAP representation is DGAP[N] = GAP[N] - GAP[N-1]</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>gap_buf</em>&nbsp;</td><td>- GAP buffer </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dgap_buf</em>&nbsp;</td><td>- Delta-GAP buffer </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>copy_head</em>&nbsp;</td><td>- flag to copy GAP header </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="a00093_source.html#l00802">802</a> of file <a class="el" href="a00093_source.html">bmfunc.h</a>.</p>

<p>References <a class="el" href="a00093_source.html#l00785">bm::d_copy_func&lt; T &gt;::dgap_buf_</a>.</p>

</div>
</div>
<a class="anchor" id="acebed8b533c2c9e17167617501477693"></a><!-- doxytag: member="bm::gap_bfind" ref="acebed8b533c2c9e17167617501477693" args="(const T *buf, unsigned pos, unsigned *is_set)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned bm::gap_bfind </td>
          <td>(</td>
          <td class="paramtype">const T *&nbsp;</td>
          <td class="paramname"> <em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned *&nbsp;</td>
          <td class="paramname"> <em>is_set</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="a00093_source.html#l00461">461</a> of file <a class="el" href="a00093_source.html">bmfunc.h</a>.</p>

<p>References <a class="el" href="a00092_source.html#l00050">BM_ASSERT</a>, and <a class="el" href="a00091_source.html#l00072">gap_max_bits</a>.</p>

<p>Referenced by <a class="el" href="a00093_source.html#l00714">gap_bit_count_range()</a>, <a class="el" href="a00093_source.html#l01436">gap_find_in_block()</a>, and <a class="el" href="a00093_source.html#l01168">gap_set_value()</a>.</p>

</div>
</div>
<a class="anchor" id="a7324ebded429e15361f62117a2ff18d1"></a><!-- doxytag: member="bm::gap_bit_count_range" ref="a7324ebded429e15361f62117a2ff18d1" args="(const T *buf, T left, T right)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned bm::gap_bit_count_range </td>
          <td>(</td>
          <td class="paramtype">const T *&nbsp;</td>
          <td class="paramname"> <em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&nbsp;</td>
          <td class="paramname"> <em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&nbsp;</td>
          <td class="paramname"> <em>right</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Counts 1 bits in GAP buffer in the closed [left, right] diapason. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buf</em>&nbsp;</td><td>- GAP buffer pointer. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>left</em>&nbsp;</td><td>- leftmost bit index to start from </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>right-</em>&nbsp;</td><td>rightmost bit index </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Number of non-zero bits. </dd></dl>

<p>Definition at line <a class="el" href="a00093_source.html#l00714">714</a> of file <a class="el" href="a00093_source.html">bmfunc.h</a>.</p>

<p>References <a class="el" href="a00092_source.html#l00050">BM_ASSERT</a>, and <a class="el" href="a00093_source.html#l00461">gap_bfind()</a>.</p>

<p>Referenced by <a class="el" href="a00087_source.html#l01687">bm::bvector&lt; Alloc &gt;::count_range()</a>.</p>

</div>
</div>
<a class="anchor" id="aac0daaac2b5a7c88e6be726c77f52c68"></a><!-- doxytag: member="bm::gap_buff_op" ref="aac0daaac2b5a7c88e6be726c77f52c68" args="(T *BMRESTRICT dest, const T *BMRESTRICT vect1, unsigned vect1_mask, const T *BMRESTRICT vect2, unsigned vect2_mask, F &amp;f, unsigned &amp;dlen)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , class F &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void bm::gap_buff_op </td>
          <td>(</td>
          <td class="paramtype">T *BMRESTRICT&nbsp;</td>
          <td class="paramname"> <em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *BMRESTRICT&nbsp;</td>
          <td class="paramname"> <em>vect1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>vect1_mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *BMRESTRICT&nbsp;</td>
          <td class="paramname"> <em>vect2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>vect2_mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F &amp;&nbsp;</td>
          <td class="paramname"> <em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned &amp;&nbsp;</td>
          <td class="paramname"> <em>dlen</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Abstract operation for GAP buffers. Receives functor F as a template argument. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dest</em>&nbsp;</td><td>- destination memory buffer. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>vect1</em>&nbsp;</td><td>- operand 1 GAP encoded buffer. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>vect1_mask</em>&nbsp;</td><td>- XOR mask for starting bitflag for vector1 can be 0 or 1 (1 inverts the vector) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>vect2</em>&nbsp;</td><td>- operand 2 GAP encoded buffer. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>vect2_mask</em>&nbsp;</td><td>- same as vect1_mask </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>f</em>&nbsp;</td><td>- operation functor. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dlen</em>&nbsp;</td><td>- destination length after the operation</td></tr>
  </table>
  </dd>
</dl>
<dl class="note"><dt><b>Note:</b></dt><dd>Internal function. </dd></dl>

<p>Definition at line <a class="el" href="a00093_source.html#l00933">933</a> of file <a class="el" href="a00093_source.html">bmfunc.h</a>.</p>

<p>References <a class="el" href="a00091_source.html#l00072">gap_max_bits</a>.</p>

<p>Referenced by <a class="el" href="a00093_source.html#l03186">gap_operation_and()</a>, <a class="el" href="a00093_source.html#l03318">gap_operation_or()</a>, <a class="el" href="a00093_source.html#l03363">gap_operation_sub()</a>, and <a class="el" href="a00093_source.html#l03252">gap_operation_xor()</a>.</p>

</div>
</div>
<a class="anchor" id="a5f818ac575622da8a9a75511e649ea90"></a><!-- doxytag: member="bm::ilog2" ref="a5f818ac575622da8a9a75511e649ea90" args="(gap_word_t x)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00115.html#ac654d6319039a86546d235a236fc7cf6">bm::gap_word_t</a> bm::ilog2 </td>
          <td>(</td>
          <td class="paramtype">gap_word_t&nbsp;</td>
          <td class="paramname"> <em>x</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="a00102_source.html#l00090">90</a> of file <a class="el" href="a00102_source.html">bmutil.h</a>.</p>

</div>
</div>
<a class="anchor" id="a46f258f92ab40e2a0c76aa775338faaa"></a><!-- doxytag: member="bm::ilog2" ref="a46f258f92ab40e2a0c76aa775338faaa" args="(T x)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T bm::ilog2 </td>
          <td>(</td>
          <td class="paramtype">T&nbsp;</td>
          <td class="paramname"> <em>x</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Fast loop-less function to find LOG2. </p>

<p>Definition at line <a class="el" href="a00102_source.html#l00078">78</a> of file <a class="el" href="a00102_source.html">bmutil.h</a>.</p>

</div>
</div>
<a class="anchor" id="a3ab126a6fd7ffd872a4001638819a330"></a><!-- doxytag: member="bm::ilog2_LUT" ref="a3ab126a6fd7ffd872a4001638819a330" args="(T x)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T bm::ilog2_LUT </td>
          <td>(</td>
          <td class="paramtype">T&nbsp;</td>
          <td class="paramname"> <em>x</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Lookup table based integer LOG2. </p>

<p>Definition at line <a class="el" href="a00102_source.html#l00121">121</a> of file <a class="el" href="a00102_source.html">bmutil.h</a>.</p>

<p>Referenced by <a class="el" href="a00104_source.html#l00229">bm::bit_out&lt; TEncoder &gt;::gamma()</a>.</p>

</div>
</div>
<a class="anchor" id="a7074ee06dc4ee023170c2f85c78b50fe"></a><!-- doxytag: member="bm::ilog2_LUT&lt; bm::gap_word_t &gt;" ref="a7074ee06dc4ee023170c2f85c78b50fe" args="(bm::gap_word_t x)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00115.html#ac654d6319039a86546d235a236fc7cf6">bm::gap_word_t</a> bm::ilog2_LUT&lt; <a class="el" href="a00115.html#ac654d6319039a86546d235a236fc7cf6">bm::gap_word_t</a> &gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00115.html#ac654d6319039a86546d235a236fc7cf6">bm::gap_word_t</a>&nbsp;</td>
          <td class="paramname"> <em>x</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Lookup table based short integer LOG2. </p>

</div>
</div>
<a class="anchor" id="a3deb310cdf11bca948817f94adfec160"></a><!-- doxytag: member="bm::is_const_set_operation" ref="a3deb310cdf11bca948817f94adfec160" args="(set_operation op)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bm::is_const_set_operation </td>
          <td>(</td>
          <td class="paramtype">set_operation&nbsp;</td>
          <td class="paramname"> <em>op</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns true if set operation is constant (bitcount). </p>

<p>Definition at line <a class="el" href="a00093_source.html#l00266">266</a> of file <a class="el" href="a00093_source.html">bmfunc.h</a>.</p>

<p>References <a class="el" href="a00093_source.html#l00252">set_COUNT</a>.</p>

<p>Referenced by <a class="el" href="a00096_source.html#l03319">bm::iterator_deserializer&lt; BV, SerialIterator &gt;::deserialize()</a>, and <a class="el" href="a00089_source.html#l00071">operation2metric()</a>.</p>

</div>
</div>
<a class="anchor" id="a35c6dfc6504cd79f788121f361b01bf9"></a><!-- doxytag: member="bm::min_value" ref="a35c6dfc6504cd79f788121f361b01bf9" args="(T v1, T v2)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T bm::min_value </td>
          <td>(</td>
          <td class="paramtype">T&nbsp;</td>
          <td class="paramname"> <em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&nbsp;</td>
          <td class="paramname"> <em>v2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get minimum of 2 values. </p>

<p>Definition at line <a class="el" href="a00102_source.html#l00068">68</a> of file <a class="el" href="a00102_source.html">bmutil.h</a>.</p>

<p>Referenced by <a class="el" href="a00089_source.html#l00783">distance_and_operation()</a>.</p>

</div>
</div>
<a class="anchor" id="a515b2862b33efd4e36d72e4ba7729199"></a><!-- doxytag: member="bm::op_and" ref="a515b2862b33efd4e36d72e4ba7729199" args="(unsigned a, unsigned b)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BMFORCEINLINE unsigned bm::op_and </td>
          <td>(</td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>b</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="a00098_source.html#l00108">108</a> of file <a class="el" href="a00098_source.html">bmsse4.h</a>.</p>

</div>
</div>
<a class="anchor" id="a0ed9a1bcd143f7763b4b59ef442f6994"></a><!-- doxytag: member="bm::op_or" ref="a0ed9a1bcd143f7763b4b59ef442f6994" args="(unsigned a, unsigned b)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BMFORCEINLINE unsigned bm::op_or </td>
          <td>(</td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>b</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="a00098_source.html#l00099">99</a> of file <a class="el" href="a00098_source.html">bmsse4.h</a>.</p>

</div>
</div>
<a class="anchor" id="a6d8f327a7d19c11125ac77383a34e986"></a><!-- doxytag: member="bm::op_xor" ref="a6d8f327a7d19c11125ac77383a34e986" args="(unsigned a, unsigned b)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BMFORCEINLINE unsigned bm::op_xor </td>
          <td>(</td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>b</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="a00098_source.html#l00089">89</a> of file <a class="el" href="a00098_source.html">bmsse4.h</a>.</p>

</div>
</div>
<a class="anchor" id="a9642fa6fb00fb9de2406e1eaea44b88d"></a><!-- doxytag: member="bm::operator&amp;" ref="a9642fa6fb00fb9de2406e1eaea44b88d" args="(const bvector&lt; Alloc &gt; &amp;v1, const bvector&lt; Alloc &gt; &amp;v2)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00043.html">bvector</a>&lt;Alloc&gt; bm::operator&amp; </td>
          <td>(</td>
          <td class="paramtype">const bvector&lt; Alloc &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bvector&lt; Alloc &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>v2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="a00087_source.html#l01561">1561</a> of file <a class="el" href="a00087_source.html">bm.h</a>.</p>

<p>References <a class="el" href="a00087_source.html#l01293">bm::bvector&lt; Alloc &gt;::bit_and()</a>.</p>

</div>
</div>
<a class="anchor" id="ac7b828f11454f40bcd07e6abc60990f2"></a><!-- doxytag: member="bm::operator&#45;" ref="ac7b828f11454f40bcd07e6abc60990f2" args="(const bvector&lt; Alloc &gt; &amp;v1, const bvector&lt; Alloc &gt; &amp;v2)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00043.html">bvector</a>&lt;Alloc&gt; bm::operator- </td>
          <td>(</td>
          <td class="paramtype">const bvector&lt; Alloc &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bvector&lt; Alloc &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>v2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="a00087_source.html#l01606">1606</a> of file <a class="el" href="a00087_source.html">bm.h</a>.</p>

<p>References <a class="el" href="a00087_source.html#l01315">bm::bvector&lt; Alloc &gt;::bit_sub()</a>.</p>

</div>
</div>
<a class="anchor" id="aeaf93e15a099b98ae8e314142c70f63a"></a><!-- doxytag: member="bm::operator^" ref="aeaf93e15a099b98ae8e314142c70f63a" args="(const bvector&lt; Alloc &gt; &amp;v1, const bvector&lt; Alloc &gt; &amp;v2)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00043.html">bvector</a>&lt;Alloc&gt; bm::operator^ </td>
          <td>(</td>
          <td class="paramtype">const bvector&lt; Alloc &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bvector&lt; Alloc &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>v2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="a00087_source.html#l01591">1591</a> of file <a class="el" href="a00087_source.html">bm.h</a>.</p>

<p>References <a class="el" href="a00087_source.html#l01304">bm::bvector&lt; Alloc &gt;::bit_xor()</a>.</p>

</div>
</div>
<a class="anchor" id="acc5d3d9d78d8edbc6dba501c479c789e"></a><!-- doxytag: member="bm::operator|" ref="acc5d3d9d78d8edbc6dba501c479c789e" args="(const bvector&lt; Alloc &gt; &amp;v1, const bvector&lt; Alloc &gt; &amp;v2)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00043.html">bvector</a>&lt;Alloc&gt; bm::operator| </td>
          <td>(</td>
          <td class="paramtype">const bvector&lt; Alloc &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bvector&lt; Alloc &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>v2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="a00087_source.html#l01576">1576</a> of file <a class="el" href="a00087_source.html">bm.h</a>.</p>

<p>References <a class="el" href="a00087_source.html#l01282">bm::bvector&lt; Alloc &gt;::bit_or()</a>.</p>

</div>
</div>
<a class="anchor" id="ac330d13a0846ca89ff6fc6927e675a93"></a><!-- doxytag: member="bm::or_op" ref="ac330d13a0846ca89ff6fc6927e675a93" args="(unsigned v1, unsigned v2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BMFORCEINLINE unsigned bm::or_op </td>
          <td>(</td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>v2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>GAP or functor. </p>

<p>Definition at line <a class="el" href="a00093_source.html#l03157">3157</a> of file <a class="el" href="a00093_source.html">bmfunc.h</a>.</p>

<p>Referenced by <a class="el" href="a00093_source.html#l03338">gap_count_or()</a>.</p>

</div>
</div>
<a class="anchor" id="a30cec2c137813460f4b4c65c5879a4c3"></a><!-- doxytag: member="bm::parallel_popcnt_32" ref="a30cec2c137813460f4b4c65c5879a4c3" args="(unsigned int n)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int bm::parallel_popcnt_32 </td>
          <td>(</td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>n</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="a00093_source.html#l00179">179</a> of file <a class="el" href="a00093_source.html">bmfunc.h</a>.</p>

</div>
</div>
<a class="anchor" id="a7c192b64adb0590a09b5c2dad77c4b76"></a><!-- doxytag: member="bm::setop2op" ref="a7c192b64adb0590a09b5c2dad77c4b76" args="(bm::set_operation op)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00115.html#a42405343976ec931388381cea4092bf1">bm::operation</a> bm::setop2op </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00115.html#a76b70d2b9182a6dcac151d1bd9ec6109">bm::set_operation</a>&nbsp;</td>
          <td class="paramname"> <em>op</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convert set operation to operation. </p>

<p>Definition at line <a class="el" href="a00093_source.html#l00286">286</a> of file <a class="el" href="a00093_source.html">bmfunc.h</a>.</p>

<p>References <a class="el" href="a00092_source.html#l00050">BM_ASSERT</a>, <a class="el" href="a00093_source.html#l00247">set_AND</a>, <a class="el" href="a00093_source.html#l00248">set_OR</a>, <a class="el" href="a00093_source.html#l00249">set_SUB</a>, and <a class="el" href="a00093_source.html#l00250">set_XOR</a>.</p>

<p>Referenced by <a class="el" href="a00096_source.html#l03101">bm::iterator_deserializer&lt; BV, SerialIterator &gt;::deserialize()</a>.</p>

</div>
</div>
<a class="anchor" id="ac0c75fb7b3dc61602843ac4e1b9b7ef5"></a><!-- doxytag: member="bm::sse2_and" ref="ac0c75fb7b3dc61602843ac4e1b9b7ef5" args="(__m128i a, __m128i b)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BMFORCEINLINE __m128i bm::sse2_and </td>
          <td>(</td>
          <td class="paramtype">__m128i&nbsp;</td>
          <td class="paramname"> <em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__m128i&nbsp;</td>
          <td class="paramname"> <em>b</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="a00099_source.html#l00384">384</a> of file <a class="el" href="a00099_source.html">bmsse_util.h</a>.</p>

</div>
</div>
<a class="anchor" id="a0479b7b6704c6ab64396e2365b8b5fa7"></a><!-- doxytag: member="bm::sse2_bit_block_calc_count_change" ref="a0479b7b6704c6ab64396e2365b8b5fa7" args="(const __m128i *BMRESTRICT block, const __m128i *BMRESTRICT block_end, unsigned *BMRESTRICT bit_count)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00115.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a> bm::sse2_bit_block_calc_count_change </td>
          <td>(</td>
          <td class="paramtype">const __m128i *BMRESTRICT&nbsp;</td>
          <td class="paramname"> <em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const __m128i *BMRESTRICT&nbsp;</td>
          <td class="paramname"> <em>block_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned *BMRESTRICT&nbsp;</td>
          <td class="paramname"> <em>bit_count</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="a00097_source.html#l00237">237</a> of file <a class="el" href="a00097_source.html">bmsse2.h</a>.</p>

<p>References <a class="el" href="a00092_source.html#l00144">BM_ALIGN16ATTR</a>, and <a class="el" href="a00092_source.html#l00159">BM_INCWORD_BITCOUNT</a>.</p>

<p>Referenced by <a class="el" href="a00093_source.html#l02864">bit_block_calc_count_change()</a>.</p>

</div>
</div>
<a class="anchor" id="a8831a88ef538b3997d04d2ebf513160d"></a><!-- doxytag: member="bm::sse2_bit_count_op" ref="a8831a88ef538b3997d04d2ebf513160d" args="(const __m128i *BMRESTRICT block, const __m128i *BMRESTRICT block_end, const __m128i *BMRESTRICT mask_block, Func sse2_func)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Func &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00115.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a> bm::sse2_bit_count_op </td>
          <td>(</td>
          <td class="paramtype">const __m128i *BMRESTRICT&nbsp;</td>
          <td class="paramname"> <em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const __m128i *BMRESTRICT&nbsp;</td>
          <td class="paramname"> <em>block_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const __m128i *BMRESTRICT&nbsp;</td>
          <td class="paramname"> <em>mask_block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&nbsp;</td>
          <td class="paramname"> <em>sse2_func</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="a00097_source.html#l00125">125</a> of file <a class="el" href="a00097_source.html">bmsse2.h</a>.</p>

<p>References <a class="el" href="a00092_source.html#l00144">BM_ALIGN16ATTR</a>.</p>

</div>
</div>
<a class="anchor" id="adea798a9a95a04845c33876087a2f46b"></a><!-- doxytag: member="bm::sse2_or" ref="adea798a9a95a04845c33876087a2f46b" args="(__m128i a, __m128i b)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BMFORCEINLINE __m128i bm::sse2_or </td>
          <td>(</td>
          <td class="paramtype">__m128i&nbsp;</td>
          <td class="paramname"> <em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__m128i&nbsp;</td>
          <td class="paramname"> <em>b</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="a00099_source.html#l00390">390</a> of file <a class="el" href="a00099_source.html">bmsse_util.h</a>.</p>

</div>
</div>
<a class="anchor" id="ab3e6d46fcba1bc2a1a5390c10f571382"></a><!-- doxytag: member="bm::sse2_sub" ref="ab3e6d46fcba1bc2a1a5390c10f571382" args="(__m128i a, __m128i b)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BMFORCEINLINE __m128i bm::sse2_sub </td>
          <td>(</td>
          <td class="paramtype">__m128i&nbsp;</td>
          <td class="paramname"> <em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__m128i&nbsp;</td>
          <td class="paramname"> <em>b</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="a00099_source.html#l00403">403</a> of file <a class="el" href="a00099_source.html">bmsse_util.h</a>.</p>

</div>
</div>
<a class="anchor" id="a6f5de19ee3e1be05037908b4777c4da8"></a><!-- doxytag: member="bm::sse2_xor" ref="a6f5de19ee3e1be05037908b4777c4da8" args="(__m128i a, __m128i b)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BMFORCEINLINE __m128i bm::sse2_xor </td>
          <td>(</td>
          <td class="paramtype">__m128i&nbsp;</td>
          <td class="paramname"> <em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__m128i&nbsp;</td>
          <td class="paramname"> <em>b</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="a00099_source.html#l00397">397</a> of file <a class="el" href="a00099_source.html">bmsse_util.h</a>.</p>

</div>
</div>
<a class="anchor" id="a295c6323a972a90e28c36e6012427a26"></a><!-- doxytag: member="bm::sse4_bit_count_op" ref="a295c6323a972a90e28c36e6012427a26" args="(const __m128i *BMRESTRICT block, const __m128i *BMRESTRICT block_end, const __m128i *BMRESTRICT mask_block, Func sse2_func)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Func &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00115.html#aa3824d882a037396370b16f2f0a8bf37">bm::id_t</a> bm::sse4_bit_count_op </td>
          <td>(</td>
          <td class="paramtype">const __m128i *BMRESTRICT&nbsp;</td>
          <td class="paramname"> <em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const __m128i *BMRESTRICT&nbsp;</td>
          <td class="paramname"> <em>block_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const __m128i *BMRESTRICT&nbsp;</td>
          <td class="paramname"> <em>mask_block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&nbsp;</td>
          <td class="paramname"> <em>sse2_func</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="a00098_source.html#l00115">115</a> of file <a class="el" href="a00098_source.html">bmsse4.h</a>.</p>

</div>
</div>
<a class="anchor" id="a35c5866395bfb88b68913b32539a2b96"></a><!-- doxytag: member="bm::sub_op" ref="a35c5866395bfb88b68913b32539a2b96" args="(unsigned v1, unsigned v2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BMFORCEINLINE unsigned bm::sub_op </td>
          <td>(</td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>v2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>GAP or functor. </p>

<p>Definition at line <a class="el" href="a00093_source.html#l03163">3163</a> of file <a class="el" href="a00093_source.html">bmfunc.h</a>.</p>

<p>Referenced by <a class="el" href="a00093_source.html#l03405">gap_count_sub()</a>.</p>

</div>
</div>
<a class="anchor" id="ac8f3443ba8fcd1b28face4b09dfd21bf"></a><!-- doxytag: member="bm::sum_arr" ref="ac8f3443ba8fcd1b28face4b09dfd21bf" args="(T *first, T *last)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T bm::sum_arr </td>
          <td>(</td>
          <td class="paramtype">T *&nbsp;</td>
          <td class="paramname"> <em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&nbsp;</td>
          <td class="paramname"> <em>last</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Computes SUM of all elements of the sequence </p>

<p>Definition at line <a class="el" href="a00093_source.html#l00658">658</a> of file <a class="el" href="a00093_source.html">bmfunc.h</a>.</p>

</div>
</div>
<a class="anchor" id="a336ed7eb10da60438793f0ecff0fb7b1"></a><!-- doxytag: member="bm::tmatrix_reduce" ref="a336ed7eb10da60438793f0ecff0fb7b1" args="(TMatrix &amp;tmatrix, const unsigned char *pc_vector, const unsigned effective_cols)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TMatrix &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void bm::tmatrix_reduce </td>
          <td>(</td>
          <td class="paramtype">TMatrix &amp;&nbsp;</td>
          <td class="paramname"> <em>tmatrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned char *&nbsp;</td>
          <td class="paramname"> <em>pc_vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned&nbsp;</td>
          <td class="paramname"> <em>effective_cols</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Transposed Matrix reduction based on transformation pc vector. </p>

<p>Definition at line <a class="el" href="a00100_source.html#l00554">554</a> of file <a class="el" href="a00100_source.html">bmtrans.h</a>.</p>

<p>References <a class="el" href="a00092_source.html#l00050">BM_ASSERT</a>, <a class="el" href="a00100_source.html#l00390">ibpc_all_one</a>, <a class="el" href="a00100_source.html#l00389">ibpc_all_zero</a>, <a class="el" href="a00100_source.html#l00392">ibpc_close</a>, <a class="el" href="a00100_source.html#l00391">ibpc_equiv</a>, and <a class="el" href="a00100_source.html#l00388">ibpc_uncompr</a>.</p>

<p>Referenced by <a class="el" href="a00100_source.html#l00846">bm::gap_transpose_engine&lt; GT, BT, BLOCK_SIZE &gt;::reduce()</a>.</p>

</div>
</div>
<a class="anchor" id="ab7544e494744b2c0b265ab7d81f766b8"></a><!-- doxytag: member="bm::tmatrix_restore" ref="ab7544e494744b2c0b265ab7d81f766b8" args="(TMatrix &amp;tmatrix, const unsigned char *pc_vector, const unsigned effective_cols)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TMatrix &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void bm::tmatrix_restore </td>
          <td>(</td>
          <td class="paramtype">TMatrix &amp;&nbsp;</td>
          <td class="paramname"> <em>tmatrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned char *&nbsp;</td>
          <td class="paramname"> <em>pc_vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned&nbsp;</td>
          <td class="paramname"> <em>effective_cols</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Transposed Matrix restore based on transformation pc vector. </p>

<p>Definition at line <a class="el" href="a00100_source.html#l00601">601</a> of file <a class="el" href="a00100_source.html">bmtrans.h</a>.</p>

<p>References <a class="el" href="a00092_source.html#l00050">BM_ASSERT</a>, <a class="el" href="a00100_source.html#l00390">ibpc_all_one</a>, <a class="el" href="a00100_source.html#l00389">ibpc_all_zero</a>, <a class="el" href="a00100_source.html#l00392">ibpc_close</a>, <a class="el" href="a00100_source.html#l00391">ibpc_equiv</a>, and <a class="el" href="a00100_source.html#l00388">ibpc_uncompr</a>.</p>

<p>Referenced by <a class="el" href="a00100_source.html#l00852">bm::gap_transpose_engine&lt; GT, BT, BLOCK_SIZE &gt;::restore()</a>.</p>

</div>
</div>
<a class="anchor" id="a2e3af9c9f2eb481130d240ba4cd6fd68"></a><!-- doxytag: member="bm::vect_bit_transpose" ref="a2e3af9c9f2eb481130d240ba4cd6fd68" args="(const T *arr, unsigned arr_size, T tmatrix[BPC][BPS])" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , unsigned BPC, unsigned BPS&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void bm::vect_bit_transpose </td>
          <td>(</td>
          <td class="paramtype">const T *&nbsp;</td>
          <td class="paramname"> <em>arr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>arr_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&nbsp;</td>
          <td class="paramname"> <em>tmatrix</em>[BPC][BPS]</td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Generic bit-array transposition function T - array type (any int) BPC - bit plain count BPS - bit plain size. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>arr</em>&nbsp;</td><td>- source array start </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>arr_size</em>&nbsp;</td><td>- source array size </td></tr>
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="a00086.html" title="Mini-matrix for bit transposition purposes.">tmatrix</a></em>&nbsp;</td><td>- destination bit matrix </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="a00100_source.html#l00294">294</a> of file <a class="el" href="a00100_source.html">bmtrans.h</a>.</p>

<p>References <a class="el" href="a00092_source.html#l00050">BM_ASSERT</a>.</p>

</div>
</div>
<a class="anchor" id="a089ac7cd17ddca4bf3c661c96f749f3f"></a><!-- doxytag: member="bm::vect_bit_trestore" ref="a089ac7cd17ddca4bf3c661c96f749f3f" args="(const T tmatrix[BPC][BPS], T *arr)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , unsigned BPC, unsigned BPS&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void bm::vect_bit_trestore </td>
          <td>(</td>
          <td class="paramtype">const T&nbsp;</td>
          <td class="paramname"> <em>tmatrix</em>[BPC][BPS], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&nbsp;</td>
          <td class="paramname"> <em>arr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Restore bit array from the transposition matrix T - array type (any int) BPC - bit plain count BPS - bit plain size. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>arr</em>&nbsp;</td><td>- dest array </td></tr>
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="a00086.html" title="Mini-matrix for bit transposition purposes.">tmatrix</a></em>&nbsp;</td><td>- source bit-slice matrix </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="a00100_source.html#l00327">327</a> of file <a class="el" href="a00100_source.html">bmtrans.h</a>.</p>

</div>
</div>
<a class="anchor" id="a6e7085de3103a42f81c0d3d82903cd5f"></a><!-- doxytag: member="bm::xor_op" ref="a6e7085de3103a42f81c0d3d82903cd5f" args="(unsigned v1, unsigned v2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BMFORCEINLINE unsigned bm::xor_op </td>
          <td>(</td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>v2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>GAP xor functor. </p>

<p>Definition at line <a class="el" href="a00093_source.html#l03150">3150</a> of file <a class="el" href="a00093_source.html">bmfunc.h</a>.</p>

<p>Referenced by <a class="el" href="a00093_source.html#l03293">gap_count_xor()</a>, <a class="el" href="a00093_source.html#l03277">gap_operation_any_xor()</a>, and <a class="el" href="a00093_source.html#l03252">gap_operation_xor()</a>.</p>

</div>
</div>
<a class="anchor" id="afb2c1acc56270abb381741a709a2b17c"></a><!-- doxytag: member="bm::xor_swap" ref="afb2c1acc56270abb381741a709a2b17c" args="(W &amp;x, W &amp;y)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename W &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void bm::xor_swap </td>
          <td>(</td>
          <td class="paramtype">W &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">W &amp;&nbsp;</td>
          <td class="paramname"> <em>y</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>XOR swap two scalar variables. </p>

<p>Definition at line <a class="el" href="a00093_source.html#l00321">321</a> of file <a class="el" href="a00093_source.html">bmfunc.h</a>.</p>

<p>References <a class="el" href="a00092_source.html#l00050">BM_ASSERT</a>.</p>

<p>Referenced by <a class="el" href="a00087_source.html#l01218">bm::bvector&lt; Alloc &gt;::swap()</a>.</p>

</div>
</div>
<hr/><h2>Variable Documentation</h2>
<a class="anchor" id="ad81dea46a256b93b2af3568ce409d40b"></a><!-- doxytag: member="bm::all_bits_mask" ref="ad81dea46a256b93b2af3568ce409d40b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">word_t</a> <a class="el" href="a00115.html#ad81dea46a256b93b2af3568ce409d40b">bm::all_bits_mask</a> = 0xffffffff</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="a00091_source.html#l00102">102</a> of file <a class="el" href="a00091_source.html">bmconst.h</a>.</p>

<p>Referenced by <a class="el" href="a00093_source.html#l03102">is_bits_one()</a>.</p>

</div>
</div>
<a class="anchor" id="a4dedd13a7b8a27c5067b20118002f025"></a><!-- doxytag: member="bm::bits_in_array" ref="a4dedd13a7b8a27c5067b20118002f025" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned <a class="el" href="a00115.html#a4dedd13a7b8a27c5067b20118002f025">bm::bits_in_array</a> = <a class="el" href="a00115.html#ae9916f69ced0347d94472d7944ea0e45">bm::bits_in_block</a> * <a class="el" href="a00115.html#a40ad34d6c46a2fb20ba2baa7f95d80b4">bm::set_array_size</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="a00091_source.html#l00087">87</a> of file <a class="el" href="a00091_source.html">bmconst.h</a>.</p>

<p>Referenced by <a class="el" href="a00087_source.html#l00435">bm::bvector&lt; Alloc &gt;::enumerator::go_first()</a>, and <a class="el" href="a00087_source.html#l00500">bm::bvector&lt; Alloc &gt;::enumerator::go_up()</a>.</p>

</div>
</div>
<a class="anchor" id="ae9916f69ced0347d94472d7944ea0e45"></a><!-- doxytag: member="bm::bits_in_block" ref="ae9916f69ced0347d94472d7944ea0e45" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned <a class="el" href="a00115.html#ae9916f69ced0347d94472d7944ea0e45">bm::bits_in_block</a> = <a class="el" href="a00115.html#a91319dbc0d0e1bf3a3efc4d92bac7972">bm::set_block_size</a> * sizeof(<a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a>) * 8</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="a00091_source.html#l00086">86</a> of file <a class="el" href="a00091_source.html">bmconst.h</a>.</p>

<p>Referenced by <a class="el" href="a00087_source.html#l01687">bm::bvector&lt; Alloc &gt;::count_range()</a>, <a class="el" href="a00096_source.html#l03319">bm::iterator_deserializer&lt; BV, SerialIterator &gt;::deserialize()</a>, <a class="el" href="a00096_source.html#l01424">bm::deserializer&lt; BV, DEC &gt;::deserialize()</a>, <a class="el" href="a00087_source.html#l00435">bm::bvector&lt; Alloc &gt;::enumerator::go_first()</a>, and <a class="el" href="a00087_source.html#l00500">bm::bvector&lt; Alloc &gt;::enumerator::go_up()</a>.</p>

</div>
</div>
<a class="anchor" id="a9b1715d6d9164d56172e75bbbd0e3000"></a><!-- doxytag: member="bm::gap_equiv_len" ref="a9b1715d6d9164d56172e75bbbd0e3000" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned <a class="el" href="a00115.html#a9b1715d6d9164d56172e75bbbd0e3000">bm::gap_equiv_len</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Initial value:</b><div class="fragment"><pre class="fragment"> 
   (<span class="keyword">sizeof</span>(<a class="code" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a>) * <a class="code" href="a00115.html#a91319dbc0d0e1bf3a3efc4d92bac7972">bm::set_block_size</a>) / <span class="keyword">sizeof</span>(<a class="code" href="a00115.html#ac654d6319039a86546d235a236fc7cf6">gap_word_t</a>)
</pre></div>
<p>Definition at line <a class="el" href="a00091_source.html#l00073">73</a> of file <a class="el" href="a00091_source.html">bmconst.h</a>.</p>

<p>Referenced by <a class="el" href="a00096_source.html#l03101">bm::iterator_deserializer&lt; BV, SerialIterator &gt;::deserialize()</a>, <a class="el" href="a00096_source.html#l00709">bm::serializer&lt; BV &gt;::encode_gap_block()</a>, and <a class="el" href="a00096_source.html#l00814">bm::serializer&lt; BV &gt;::serialize()</a>.</p>

</div>
</div>
<a class="anchor" id="aa5b9ff05b8f4c8a9e6b17bb04988b48f"></a><!-- doxytag: member="bm::gap_length_threashold" ref="aa5b9ff05b8f4c8a9e6b17bb04988b48f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned <a class="el" href="a00115.html#aa5b9ff05b8f4c8a9e6b17bb04988b48f">bm::gap_length_threashold</a> = <a class="el" href="a00115.html#a91319dbc0d0e1bf3a3efc4d92bac7972">set_block_size</a> * 3</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="a00091_source.html#l00071">71</a> of file <a class="el" href="a00091_source.html">bmconst.h</a>.</p>

<p>Referenced by <a class="el" href="a00096_source.html#l01316">bm::deserializer&lt; BV, DEC &gt;::deserialize_gap()</a>.</p>

</div>
</div>
<a class="anchor" id="a773e9f5341919d58000bd54d50038733"></a><!-- doxytag: member="bm::gap_levels" ref="a773e9f5341919d58000bd54d50038733" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned <a class="el" href="a00115.html#a773e9f5341919d58000bd54d50038733">bm::gap_levels</a> = 4</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="a00091_source.html#l00075">75</a> of file <a class="el" href="a00091_source.html">bmconst.h</a>.</p>

<p>Referenced by <a class="el" href="a00090_source.html#l00193">bm::mem_alloc&lt; BA, PA &gt;::alloc_gap_block()</a>, <a class="el" href="a00087_source.html#l02044">bm::bvector&lt; Alloc &gt;::calc_stat()</a>, <a class="el" href="a00096_source.html#l01424">bm::deserializer&lt; BV, DEC &gt;::deserialize()</a>, <a class="el" href="a00096_source.html#l00586">bm::serializer&lt; BV &gt;::encode_header()</a>, <a class="el" href="a00093_source.html#l02450">gap_calc_level()</a>, <a class="el" href="a00093_source.html#l04847">gap_overhead()</a>, <a class="el" href="a00093_source.html#l04874">improve_gap_levels()</a>, <a class="el" href="a00087_source.html#l01838">bm::bvector&lt; Alloc &gt;::optimize()</a>, <a class="el" href="a00087_source.html#l01880">bm::bvector&lt; Alloc &gt;::optimize_gap_size()</a>, <a class="el" href="a00096_source.html#l01681">bm::serial_stream_iterator&lt; DEC &gt;::serial_stream_iterator()</a>, and <a class="el" href="a00093_source.html#l02434">set_gap_level()</a>.</p>

</div>
</div>
<a class="anchor" id="ad0b8714080144ac70197840ff96752b7"></a><!-- doxytag: member="bm::gap_max_bits" ref="ad0b8714080144ac70197840ff96752b7" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned <a class="el" href="a00115.html#ad0b8714080144ac70197840ff96752b7">bm::gap_max_bits</a> = 65536</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="a00091_source.html#l00072">72</a> of file <a class="el" href="a00091_source.html">bmconst.h</a>.</p>

<p>Referenced by <a class="el" href="a00089_source.html#l00366">combine_any_operation_with_block()</a>, <a class="el" href="a00087_source.html#l01914">bm::bvector&lt; Alloc &gt;::compare()</a>, <a class="el" href="a00096_source.html#l01316">bm::deserializer&lt; BV, DEC &gt;::deserialize_gap()</a>, <a class="el" href="a00096_source.html#l00709">bm::serializer&lt; BV &gt;::encode_gap_block()</a>, <a class="el" href="a00093_source.html#l01261">gap_add_value()</a>, <a class="el" href="a00093_source.html#l00461">gap_bfind()</a>, <a class="el" href="a00093_source.html#l01015">gap_buff_any_op()</a>, <a class="el" href="a00093_source.html#l01084">gap_buff_count_op()</a>, <a class="el" href="a00093_source.html#l00933">gap_buff_op()</a>, <a class="el" href="a00093_source.html#l01436">gap_find_in_block()</a>, <a class="el" href="a00093_source.html#l01346">gap_set_array()</a>, <a class="el" href="a00093_source.html#l01168">gap_set_value()</a>, <a class="el" href="a00093_source.html#l00489">gap_test()</a>, <a class="el" href="a00087_source.html#l00500">bm::bvector&lt; Alloc &gt;::enumerator::go_up()</a>, <a class="el" href="a00096_source.html#l01227">bm::deseriaizer_base&lt; DEC &gt;::read_gap_block()</a>, and <a class="el" href="a00096_source.html#l00814">bm::serializer&lt; BV &gt;::serialize()</a>.</p>

</div>
</div>
<a class="anchor" id="aa5e01dfb650d168f9be0525e042af647"></a><!-- doxytag: member="bm::gap_max_buff_len" ref="aa5e01dfb650d168f9be0525e042af647" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned <a class="el" href="a00115.html#aa5e01dfb650d168f9be0525e042af647">bm::gap_max_buff_len</a> = 1280</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="a00091_source.html#l00070">70</a> of file <a class="el" href="a00091_source.html">bmconst.h</a>.</p>

<p>Referenced by <a class="el" href="a00089_source.html#l00366">combine_any_operation_with_block()</a>, and <a class="el" href="a00093_source.html#l04874">improve_gap_levels()</a>.</p>

</div>
</div>
<a class="anchor" id="a13793ad631e2b2fcbaaae9000ea1a924"></a><!-- doxytag: member="bm::gap_max_level" ref="a13793ad631e2b2fcbaaae9000ea1a924" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned <a class="el" href="a00115.html#a13793ad631e2b2fcbaaae9000ea1a924">bm::gap_max_level</a> = <a class="el" href="a00115.html#a773e9f5341919d58000bd54d50038733">bm::gap_levels</a> - 1</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="a00091_source.html#l00076">76</a> of file <a class="el" href="a00091_source.html">bmconst.h</a>.</p>

</div>
</div>
<a class="anchor" id="aa6f59be0b838db693e0f081bcaf750f0"></a><!-- doxytag: member="bm::ibpc_all_one" ref="aa6f59be0b838db693e0f081bcaf750f0" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned char <a class="el" href="a00115.html#aa6f59be0b838db693e0f081bcaf750f0">bm::ibpc_all_one</a> = 2</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>!&lt; plain ALL ZERO </p>

<p>Definition at line <a class="el" href="a00100_source.html#l00390">390</a> of file <a class="el" href="a00100_source.html">bmtrans.h</a>.</p>

<p>Referenced by <a class="el" href="a00100_source.html#l00418">bit_iblock_make_pcv()</a>, <a class="el" href="a00100_source.html#l00498">bit_iblock_reduce()</a>, <a class="el" href="a00100_source.html#l00687">compute_tmatrix_rstat()</a>, <a class="el" href="a00100_source.html#l00554">tmatrix_reduce()</a>, and <a class="el" href="a00100_source.html#l00601">tmatrix_restore()</a>.</p>

</div>
</div>
<a class="anchor" id="aaca6d3c887b5b7b66a78e95471f9a326"></a><!-- doxytag: member="bm::ibpc_all_zero" ref="aaca6d3c887b5b7b66a78e95471f9a326" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned char <a class="el" href="a00115.html#aaca6d3c887b5b7b66a78e95471f9a326">bm::ibpc_all_zero</a> = 1</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>!&lt; plain uncompressed </p>

<p>Definition at line <a class="el" href="a00100_source.html#l00389">389</a> of file <a class="el" href="a00100_source.html">bmtrans.h</a>.</p>

<p>Referenced by <a class="el" href="a00100_source.html#l00418">bit_iblock_make_pcv()</a>, <a class="el" href="a00100_source.html#l00498">bit_iblock_reduce()</a>, <a class="el" href="a00100_source.html#l00687">compute_tmatrix_rstat()</a>, <a class="el" href="a00100_source.html#l00554">tmatrix_reduce()</a>, and <a class="el" href="a00100_source.html#l00601">tmatrix_restore()</a>.</p>

</div>
</div>
<a class="anchor" id="aa61bf7691d32a9bc7c65c05bb62657e5"></a><!-- doxytag: member="bm::ibpc_close" ref="aa61bf7691d32a9bc7c65c05bb62657e5" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned char <a class="el" href="a00115.html#aa61bf7691d32a9bc7c65c05bb62657e5">bm::ibpc_close</a> = 4</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>!&lt; plain is equal to plain M </p>

<p>Definition at line <a class="el" href="a00100_source.html#l00392">392</a> of file <a class="el" href="a00100_source.html">bmtrans.h</a>.</p>

<p>Referenced by <a class="el" href="a00100_source.html#l00418">bit_iblock_make_pcv()</a>, <a class="el" href="a00100_source.html#l00498">bit_iblock_reduce()</a>, <a class="el" href="a00100_source.html#l00687">compute_tmatrix_rstat()</a>, <a class="el" href="a00100_source.html#l00554">tmatrix_reduce()</a>, and <a class="el" href="a00100_source.html#l00601">tmatrix_restore()</a>.</p>

</div>
</div>
<a class="anchor" id="ae4f14f0c2c5a9ee277808d36fd94693f"></a><!-- doxytag: member="bm::ibpc_end" ref="ae4f14f0c2c5a9ee277808d36fd94693f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned char <a class="el" href="a00115.html#ae4f14f0c2c5a9ee277808d36fd94693f">bm::ibpc_end</a> = 8</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>!&lt; plain is close to plain M </p>

<p>Definition at line <a class="el" href="a00100_source.html#l00394">394</a> of file <a class="el" href="a00100_source.html">bmtrans.h</a>.</p>

</div>
</div>
<a class="anchor" id="a748d4095c39c9372a590b431e0ec17fe"></a><!-- doxytag: member="bm::ibpc_equiv" ref="a748d4095c39c9372a590b431e0ec17fe" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned char <a class="el" href="a00115.html#a748d4095c39c9372a590b431e0ec17fe">bm::ibpc_equiv</a> = 3</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>!&lt; plain ALL ONE </p>

<p>Definition at line <a class="el" href="a00100_source.html#l00391">391</a> of file <a class="el" href="a00100_source.html">bmtrans.h</a>.</p>

<p>Referenced by <a class="el" href="a00100_source.html#l00418">bit_iblock_make_pcv()</a>, <a class="el" href="a00100_source.html#l00498">bit_iblock_reduce()</a>, <a class="el" href="a00100_source.html#l00687">compute_tmatrix_rstat()</a>, <a class="el" href="a00100_source.html#l00554">tmatrix_reduce()</a>, and <a class="el" href="a00100_source.html#l00601">tmatrix_restore()</a>.</p>

</div>
</div>
<a class="anchor" id="ae34de9206be7a8aa05db9d5dc38bfc90"></a><!-- doxytag: member="bm::ibpc_uncompr" ref="ae34de9206be7a8aa05db9d5dc38bfc90" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned char <a class="el" href="a00115.html#ae34de9206be7a8aa05db9d5dc38bfc90">bm::ibpc_uncompr</a> = 0</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="a00100_source.html#l00388">388</a> of file <a class="el" href="a00100_source.html">bmtrans.h</a>.</p>

<p>Referenced by <a class="el" href="a00100_source.html#l00418">bit_iblock_make_pcv()</a>, <a class="el" href="a00100_source.html#l00498">bit_iblock_reduce()</a>, <a class="el" href="a00100_source.html#l00687">compute_tmatrix_rstat()</a>, <a class="el" href="a00100_source.html#l00554">tmatrix_reduce()</a>, and <a class="el" href="a00100_source.html#l00601">tmatrix_restore()</a>.</p>

</div>
</div>
<a class="anchor" id="a104b924a1df81542db2a6296fbf26a65"></a><!-- doxytag: member="bm::id_max" ref="a104b924a1df81542db2a6296fbf26a65" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned <a class="el" href="a00115.html#a104b924a1df81542db2a6296fbf26a65">bm::id_max</a> = 0xFFFFFFFF</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="a00091_source.html#l00048">48</a> of file <a class="el" href="a00091_source.html">bmconst.h</a>.</p>

<p>Referenced by <a class="el" href="a00089_source.html#l01111">block_range_scan()</a>, <a class="el" href="a00089_source.html#l01141">combine_or()</a>, <a class="el" href="a00089_source.html#l01304">combine_sub()</a>, <a class="el" href="a00089_source.html#l01220">combine_xor()</a>, <a class="el" href="a00096_source.html#l00586">bm::serializer&lt; BV &gt;::encode_header()</a>, <a class="el" href="a00087_source.html#l01259">bm::bvector&lt; Alloc &gt;::extract_next()</a>, <a class="el" href="a00087_source.html#l01247">bm::bvector&lt; Alloc &gt;::get_next()</a>, <a class="el" href="a00087_source.html#l00281">bm::bvector&lt; Alloc &gt;::iterator_base::invalidate()</a>, <a class="el" href="a00087_source.html#l01781">bm::bvector&lt; Alloc &gt;::invert()</a>, <a class="el" href="a00087_source.html#l00352">bm::bvector&lt; Alloc &gt;::insert_iterator::operator=()</a>, and <a class="el" href="a00087_source.html#l00272">bm::bvector&lt; Alloc &gt;::iterator_base::valid()</a>.</p>

</div>
</div>
<a class="anchor" id="a00ffa7b38d7fcc7e522d864991a6de68"></a><!-- doxytag: member="bm::set_array_mask" ref="a00ffa7b38d7fcc7e522d864991a6de68" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned <a class="el" href="a00115.html#a00ffa7b38d7fcc7e522d864991a6de68">bm::set_array_mask</a> = 0xFFu</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="a00091_source.html#l00083">83</a> of file <a class="el" href="a00091_source.html">bmconst.h</a>.</p>

<p>Referenced by <a class="el" href="a00087_source.html#l00500">bm::bvector&lt; Alloc &gt;::enumerator::go_up()</a>.</p>

</div>
</div>
<a class="anchor" id="ac1ff8647a089c751ec330cecee01907e"></a><!-- doxytag: member="bm::set_array_shift" ref="ac1ff8647a089c751ec330cecee01907e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned <a class="el" href="a00115.html#ac1ff8647a089c751ec330cecee01907e">bm::set_array_shift</a> = 8u</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="a00091_source.html#l00082">82</a> of file <a class="el" href="a00091_source.html">bmconst.h</a>.</p>

<p>Referenced by <a class="el" href="a00096_source.html#l03101">bm::iterator_deserializer&lt; BV, SerialIterator &gt;::deserialize()</a>, and <a class="el" href="a00087_source.html#l00500">bm::bvector&lt; Alloc &gt;::enumerator::go_up()</a>.</p>

</div>
</div>
<a class="anchor" id="a40ad34d6c46a2fb20ba2baa7f95d80b4"></a><!-- doxytag: member="bm::set_array_size" ref="a40ad34d6c46a2fb20ba2baa7f95d80b4" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned <a class="el" href="a00115.html#a40ad34d6c46a2fb20ba2baa7f95d80b4">bm::set_array_size</a> = 256u</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="a00091_source.html#l00081">81</a> of file <a class="el" href="a00091_source.html">bmconst.h</a>.</p>

<p>Referenced by <a class="el" href="a00087_source.html#l02044">bm::bvector&lt; Alloc &gt;::calc_stat()</a>, <a class="el" href="a00087_source.html#l02511">bm::bvector&lt; Alloc &gt;::combine_operation()</a>, <a class="el" href="a00087_source.html#l01914">bm::bvector&lt; Alloc &gt;::compare()</a>, <a class="el" href="a00089_source.html#l00783">distance_and_operation()</a>, <a class="el" href="a00089_source.html#l00693">distance_operation()</a>, <a class="el" href="a00089_source.html#l00853">distance_operation_any()</a>, <a class="el" href="a00093_source.html#l00617">for_each_block()</a>, <a class="el" href="a00093_source.html#l00528">for_each_nzblock()</a>, <a class="el" href="a00093_source.html#l00564">for_each_nzblock2()</a>, <a class="el" href="a00093_source.html#l00593">for_each_nzblock_if()</a>, <a class="el" href="a00087_source.html#l00435">bm::bvector&lt; Alloc &gt;::enumerator::go_first()</a>, and <a class="el" href="a00087_source.html#l00500">bm::bvector&lt; Alloc &gt;::enumerator::go_up()</a>.</p>

</div>
</div>
<a class="anchor" id="a2d1bf97ae342a7759943e62090fcf5d3"></a><!-- doxytag: member="bm::set_blkblk_mask" ref="a2d1bf97ae342a7759943e62090fcf5d3" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned <a class="el" href="a00115.html#a2d1bf97ae342a7759943e62090fcf5d3">bm::set_blkblk_mask</a> = 0xFFFFFFu</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="a00091_source.html#l00055">55</a> of file <a class="el" href="a00091_source.html">bmconst.h</a>.</p>

</div>
</div>
<a class="anchor" id="a3fad4a939708df59b1201910c7d37e30"></a><!-- doxytag: member="bm::set_block_16one" ref="a3fad4a939708df59b1201910c7d37e30" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned char <a class="el" href="a00115.html#a3fad4a939708df59b1201910c7d37e30">bm::set_block_16one</a> = 6</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>UP to 65536 all-set blocks. </p>

<p>Definition at line <a class="el" href="a00096_source.html#l00073">73</a> of file <a class="el" href="a00096_source.html">bmserial.h</a>.</p>

<p>Referenced by <a class="el" href="a00096_source.html#l01424">bm::deserializer&lt; BV, DEC &gt;::deserialize()</a>, <a class="el" href="a00096_source.html#l01762">bm::serial_stream_iterator&lt; DEC &gt;::next()</a>, and <a class="el" href="a00096_source.html#l00814">bm::serializer&lt; BV &gt;::serialize()</a>.</p>

</div>
</div>
<a class="anchor" id="aef47eda6538ebf2624c1612d35694c01"></a><!-- doxytag: member="bm::set_block_16zero" ref="aef47eda6538ebf2624c1612d35694c01" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned char <a class="el" href="a00115.html#aef47eda6538ebf2624c1612d35694c01">bm::set_block_16zero</a> = 5</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Up to 65536 zero blocks. </p>

<p>Definition at line <a class="el" href="a00096_source.html#l00072">72</a> of file <a class="el" href="a00096_source.html">bmserial.h</a>.</p>

<p>Referenced by <a class="el" href="a00096_source.html#l01424">bm::deserializer&lt; BV, DEC &gt;::deserialize()</a>, <a class="el" href="a00096_source.html#l01762">bm::serial_stream_iterator&lt; DEC &gt;::next()</a>, and <a class="el" href="a00096_source.html#l00814">bm::serializer&lt; BV &gt;::serialize()</a>.</p>

</div>
</div>
<a class="anchor" id="a715131318a361bcccf59fc0b1e41d444"></a><!-- doxytag: member="bm::set_block_1one" ref="a715131318a361bcccf59fc0b1e41d444" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned char <a class="el" href="a00115.html#a715131318a361bcccf59fc0b1e41d444">bm::set_block_1one</a> = 2</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>One block all-set (1111...). </p>

<p>Definition at line <a class="el" href="a00096_source.html#l00069">69</a> of file <a class="el" href="a00096_source.html">bmserial.h</a>.</p>

<p>Referenced by <a class="el" href="a00096_source.html#l01424">bm::deserializer&lt; BV, DEC &gt;::deserialize()</a>, <a class="el" href="a00096_source.html#l01762">bm::serial_stream_iterator&lt; DEC &gt;::next()</a>, and <a class="el" href="a00096_source.html#l00814">bm::serializer&lt; BV &gt;::serialize()</a>.</p>

</div>
</div>
<a class="anchor" id="a9e9cf918ca2ebec84eaf844d0e4c8bdb"></a><!-- doxytag: member="bm::set_block_1zero" ref="a9e9cf918ca2ebec84eaf844d0e4c8bdb" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned char <a class="el" href="a00115.html#a9e9cf918ca2ebec84eaf844d0e4c8bdb">bm::set_block_1zero</a> = 1</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>One all-zero block. </p>

<p>Definition at line <a class="el" href="a00096_source.html#l00068">68</a> of file <a class="el" href="a00096_source.html">bmserial.h</a>.</p>

<p>Referenced by <a class="el" href="a00096_source.html#l01424">bm::deserializer&lt; BV, DEC &gt;::deserialize()</a>, <a class="el" href="a00096_source.html#l01762">bm::serial_stream_iterator&lt; DEC &gt;::next()</a>, and <a class="el" href="a00096_source.html#l00814">bm::serializer&lt; BV &gt;::serialize()</a>.</p>

</div>
</div>
<a class="anchor" id="a5b87c58ae617ad1f104b4c6bc3ed6447"></a><!-- doxytag: member="bm::set_block_32one" ref="a5b87c58ae617ad1f104b4c6bc3ed6447" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned char <a class="el" href="a00115.html#a5b87c58ae617ad1f104b4c6bc3ed6447">bm::set_block_32one</a> = 8</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>UP to 4G all-set blocks. </p>

<p>Definition at line <a class="el" href="a00096_source.html#l00075">75</a> of file <a class="el" href="a00096_source.html">bmserial.h</a>.</p>

<p>Referenced by <a class="el" href="a00096_source.html#l01424">bm::deserializer&lt; BV, DEC &gt;::deserialize()</a>, <a class="el" href="a00096_source.html#l01762">bm::serial_stream_iterator&lt; DEC &gt;::next()</a>, and <a class="el" href="a00096_source.html#l00814">bm::serializer&lt; BV &gt;::serialize()</a>.</p>

</div>
</div>
<a class="anchor" id="ac7dfbd94a0534df88849bbce9e6c419a"></a><!-- doxytag: member="bm::set_block_32zero" ref="ac7dfbd94a0534df88849bbce9e6c419a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned char <a class="el" href="a00115.html#ac7dfbd94a0534df88849bbce9e6c419a">bm::set_block_32zero</a> = 7</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Up to 4G zero blocks. </p>

<p>Definition at line <a class="el" href="a00096_source.html#l00074">74</a> of file <a class="el" href="a00096_source.html">bmserial.h</a>.</p>

<p>Referenced by <a class="el" href="a00096_source.html#l01424">bm::deserializer&lt; BV, DEC &gt;::deserialize()</a>, <a class="el" href="a00096_source.html#l01762">bm::serial_stream_iterator&lt; DEC &gt;::next()</a>, and <a class="el" href="a00096_source.html#l00814">bm::serializer&lt; BV &gt;::serialize()</a>.</p>

</div>
</div>
<a class="anchor" id="a57ad1090d6f380cf5de5f98c699b5a75"></a><!-- doxytag: member="bm::set_block_8one" ref="a57ad1090d6f380cf5de5f98c699b5a75" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned char <a class="el" href="a00115.html#a57ad1090d6f380cf5de5f98c699b5a75">bm::set_block_8one</a> = 4</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Up to 256 all-set blocks. </p>

<p>Definition at line <a class="el" href="a00096_source.html#l00071">71</a> of file <a class="el" href="a00096_source.html">bmserial.h</a>.</p>

<p>Referenced by <a class="el" href="a00096_source.html#l01424">bm::deserializer&lt; BV, DEC &gt;::deserialize()</a>, <a class="el" href="a00096_source.html#l01762">bm::serial_stream_iterator&lt; DEC &gt;::next()</a>, and <a class="el" href="a00096_source.html#l00814">bm::serializer&lt; BV &gt;::serialize()</a>.</p>

</div>
</div>
<a class="anchor" id="ac9b85b261ab49b37d5e15b84ed2d8b99"></a><!-- doxytag: member="bm::set_block_8zero" ref="ac9b85b261ab49b37d5e15b84ed2d8b99" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned char <a class="el" href="a00115.html#ac9b85b261ab49b37d5e15b84ed2d8b99">bm::set_block_8zero</a> = 3</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Up to 256 zero blocks. </p>

<p>Definition at line <a class="el" href="a00096_source.html#l00070">70</a> of file <a class="el" href="a00096_source.html">bmserial.h</a>.</p>

<p>Referenced by <a class="el" href="a00096_source.html#l01424">bm::deserializer&lt; BV, DEC &gt;::deserialize()</a>, <a class="el" href="a00096_source.html#l01762">bm::serial_stream_iterator&lt; DEC &gt;::next()</a>, and <a class="el" href="a00096_source.html#l00814">bm::serializer&lt; BV &gt;::serialize()</a>.</p>

</div>
</div>
<a class="anchor" id="ad506b63262c52870758432a95e71907e"></a><!-- doxytag: member="bm::set_block_aone" ref="ad506b63262c52870758432a95e71907e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned char <a class="el" href="a00115.html#ad506b63262c52870758432a95e71907e">bm::set_block_aone</a> = 10</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>All other blocks one. </p>

<p>Definition at line <a class="el" href="a00096_source.html#l00077">77</a> of file <a class="el" href="a00096_source.html">bmserial.h</a>.</p>

<p>Referenced by <a class="el" href="a00096_source.html#l01424">bm::deserializer&lt; BV, DEC &gt;::deserialize()</a>, <a class="el" href="a00096_source.html#l01762">bm::serial_stream_iterator&lt; DEC &gt;::next()</a>, and <a class="el" href="a00096_source.html#l00814">bm::serializer&lt; BV &gt;::serialize()</a>.</p>

</div>
</div>
<a class="anchor" id="a6ec6acb175ce77a229003f088ecd3923"></a><!-- doxytag: member="bm::set_block_arrbit" ref="a6ec6acb175ce77a229003f088ecd3923" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned char <a class="el" href="a00115.html#a6ec6acb175ce77a229003f088ecd3923">bm::set_block_arrbit</a> = 16</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>List of bits ON. </p>

<p>Definition at line <a class="el" href="a00096_source.html#l00083">83</a> of file <a class="el" href="a00096_source.html">bmserial.h</a>.</p>

<p>Referenced by <a class="el" href="a00096_source.html#l01424">bm::deserializer&lt; BV, DEC &gt;::deserialize()</a>, <a class="el" href="a00096_source.html#l02711">bm::serial_stream_iterator&lt; DEC &gt;::get_arr_bit()</a>, <a class="el" href="a00096_source.html#l02034">bm::serial_stream_iterator&lt; DEC &gt;::get_bit_block_AND()</a>, <a class="el" href="a00096_source.html#l01910">bm::serial_stream_iterator&lt; DEC &gt;::get_bit_block_ASSIGN()</a>, <a class="el" href="a00096_source.html#l02224">bm::serial_stream_iterator&lt; DEC &gt;::get_bit_block_COUNT()</a>, <a class="el" href="a00096_source.html#l02281">bm::serial_stream_iterator&lt; DEC &gt;::get_bit_block_COUNT_A()</a>, <a class="el" href="a00096_source.html#l02344">bm::serial_stream_iterator&lt; DEC &gt;::get_bit_block_COUNT_AND()</a>, <a class="el" href="a00096_source.html#l02403">bm::serial_stream_iterator&lt; DEC &gt;::get_bit_block_COUNT_OR()</a>, <a class="el" href="a00096_source.html#l02559">bm::serial_stream_iterator&lt; DEC &gt;::get_bit_block_COUNT_SUB_AB()</a>, <a class="el" href="a00096_source.html#l02638">bm::serial_stream_iterator&lt; DEC &gt;::get_bit_block_COUNT_SUB_BA()</a>, <a class="el" href="a00096_source.html#l02481">bm::serial_stream_iterator&lt; DEC &gt;::get_bit_block_COUNT_XOR()</a>, <a class="el" href="a00096_source.html#l01972">bm::serial_stream_iterator&lt; DEC &gt;::get_bit_block_OR()</a>, <a class="el" href="a00096_source.html#l02165">bm::serial_stream_iterator&lt; DEC &gt;::get_bit_block_SUB()</a>, <a class="el" href="a00096_source.html#l02105">bm::serial_stream_iterator&lt; DEC &gt;::get_bit_block_XOR()</a>, and <a class="el" href="a00096_source.html#l01762">bm::serial_stream_iterator&lt; DEC &gt;::next()</a>.</p>

</div>
</div>
<a class="anchor" id="aae33ceefae804cdd94412beee8c52720"></a><!-- doxytag: member="bm::set_block_arrgap" ref="aae33ceefae804cdd94412beee8c52720" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned char <a class="el" href="a00115.html#aae33ceefae804cdd94412beee8c52720">bm::set_block_arrgap</a> = 18</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>List of bits ON (GAP block). </p>

<p>Definition at line <a class="el" href="a00096_source.html#l00085">85</a> of file <a class="el" href="a00096_source.html">bmserial.h</a>.</p>

<p>Referenced by <a class="el" href="a00096_source.html#l01424">bm::deserializer&lt; BV, DEC &gt;::deserialize()</a>, <a class="el" href="a00096_source.html#l01316">bm::deserializer&lt; BV, DEC &gt;::deserialize_gap()</a>, <a class="el" href="a00096_source.html#l00662">bm::serializer&lt; BV &gt;::gamma_gap_array()</a>, <a class="el" href="a00096_source.html#l01762">bm::serial_stream_iterator&lt; DEC &gt;::next()</a>, <a class="el" href="a00096_source.html#l01227">bm::deseriaizer_base&lt; DEC &gt;::read_gap_block()</a>, and <a class="el" href="a00096_source.html#l01184">bm::deseriaizer_base&lt; DEC &gt;::read_id_list()</a>.</p>

</div>
</div>
<a class="anchor" id="a9674ddb1b9ee66948465249688708188"></a><!-- doxytag: member="bm::set_block_arrgap_egamma" ref="a9674ddb1b9ee66948465249688708188" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned char <a class="el" href="a00115.html#a9674ddb1b9ee66948465249688708188">bm::set_block_arrgap_egamma</a> = 21</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gamma compressed delta GAP array. </p>

<p>Definition at line <a class="el" href="a00096_source.html#l00088">88</a> of file <a class="el" href="a00096_source.html">bmserial.h</a>.</p>

<p>Referenced by <a class="el" href="a00096_source.html#l01424">bm::deserializer&lt; BV, DEC &gt;::deserialize()</a>, <a class="el" href="a00096_source.html#l01316">bm::deserializer&lt; BV, DEC &gt;::deserialize_gap()</a>, <a class="el" href="a00096_source.html#l00662">bm::serializer&lt; BV &gt;::gamma_gap_array()</a>, <a class="el" href="a00096_source.html#l01762">bm::serial_stream_iterator&lt; DEC &gt;::next()</a>, <a class="el" href="a00096_source.html#l01227">bm::deseriaizer_base&lt; DEC &gt;::read_gap_block()</a>, and <a class="el" href="a00096_source.html#l01184">bm::deseriaizer_base&lt; DEC &gt;::read_id_list()</a>.</p>

</div>
</div>
<a class="anchor" id="a1caddb62b332a568ba590794800610f6"></a><!-- doxytag: member="bm::set_block_arrgap_egamma_inv" ref="a1caddb62b332a568ba590794800610f6" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned char <a class="el" href="a00115.html#a1caddb62b332a568ba590794800610f6">bm::set_block_arrgap_egamma_inv</a> = 23</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gamma compressed inverted delta GAP array. </p>

<p>Definition at line <a class="el" href="a00096_source.html#l00090">90</a> of file <a class="el" href="a00096_source.html">bmserial.h</a>.</p>

<p>Referenced by <a class="el" href="a00096_source.html#l01424">bm::deserializer&lt; BV, DEC &gt;::deserialize()</a>, <a class="el" href="a00096_source.html#l01316">bm::deserializer&lt; BV, DEC &gt;::deserialize_gap()</a>, <a class="el" href="a00096_source.html#l00662">bm::serializer&lt; BV &gt;::gamma_gap_array()</a>, <a class="el" href="a00096_source.html#l01762">bm::serial_stream_iterator&lt; DEC &gt;::next()</a>, <a class="el" href="a00096_source.html#l01227">bm::deseriaizer_base&lt; DEC &gt;::read_gap_block()</a>, and <a class="el" href="a00096_source.html#l01184">bm::deseriaizer_base&lt; DEC &gt;::read_id_list()</a>.</p>

</div>
</div>
<a class="anchor" id="a746a03f6f5563cc8c75db93bba40095d"></a><!-- doxytag: member="bm::set_block_arrgap_inv" ref="a746a03f6f5563cc8c75db93bba40095d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned char <a class="el" href="a00115.html#a746a03f6f5563cc8c75db93bba40095d">bm::set_block_arrgap_inv</a> = 24</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>List of bits OFF (GAP block). </p>

<p>Definition at line <a class="el" href="a00096_source.html#l00091">91</a> of file <a class="el" href="a00096_source.html">bmserial.h</a>.</p>

<p>Referenced by <a class="el" href="a00096_source.html#l01424">bm::deserializer&lt; BV, DEC &gt;::deserialize()</a>, <a class="el" href="a00096_source.html#l01316">bm::deserializer&lt; BV, DEC &gt;::deserialize_gap()</a>, <a class="el" href="a00096_source.html#l00662">bm::serializer&lt; BV &gt;::gamma_gap_array()</a>, <a class="el" href="a00096_source.html#l01762">bm::serial_stream_iterator&lt; DEC &gt;::next()</a>, <a class="el" href="a00096_source.html#l01227">bm::deseriaizer_base&lt; DEC &gt;::read_gap_block()</a>, and <a class="el" href="a00096_source.html#l01184">bm::deseriaizer_base&lt; DEC &gt;::read_id_list()</a>.</p>

</div>
</div>
<a class="anchor" id="ae87b5c61d7ba6e2e592a279db0b21cc0"></a><!-- doxytag: member="bm::set_block_azero" ref="ae87b5c61d7ba6e2e592a279db0b21cc0" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned char <a class="el" href="a00115.html#ae87b5c61d7ba6e2e592a279db0b21cc0">bm::set_block_azero</a> = 9</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>All other blocks zero. </p>

<p>Definition at line <a class="el" href="a00096_source.html#l00076">76</a> of file <a class="el" href="a00096_source.html">bmserial.h</a>.</p>

<p>Referenced by <a class="el" href="a00096_source.html#l01424">bm::deserializer&lt; BV, DEC &gt;::deserialize()</a>, <a class="el" href="a00096_source.html#l01762">bm::serial_stream_iterator&lt; DEC &gt;::next()</a>, and <a class="el" href="a00096_source.html#l00814">bm::serializer&lt; BV &gt;::serialize()</a>.</p>

</div>
</div>
<a class="anchor" id="aef86ab2eb42c198272eea7cdfe42951b"></a><!-- doxytag: member="bm::set_block_bit" ref="aef86ab2eb42c198272eea7cdfe42951b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned char <a class="el" href="a00115.html#aef86ab2eb42c198272eea7cdfe42951b">bm::set_block_bit</a> = 11</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Plain bit block. </p>

<p>Definition at line <a class="el" href="a00096_source.html#l00078">78</a> of file <a class="el" href="a00096_source.html">bmserial.h</a>.</p>

<p>Referenced by <a class="el" href="a00096_source.html#l01424">bm::deserializer&lt; BV, DEC &gt;::deserialize()</a>, <a class="el" href="a00096_source.html#l02034">bm::serial_stream_iterator&lt; DEC &gt;::get_bit_block_AND()</a>, <a class="el" href="a00096_source.html#l01910">bm::serial_stream_iterator&lt; DEC &gt;::get_bit_block_ASSIGN()</a>, <a class="el" href="a00096_source.html#l02224">bm::serial_stream_iterator&lt; DEC &gt;::get_bit_block_COUNT()</a>, <a class="el" href="a00096_source.html#l02281">bm::serial_stream_iterator&lt; DEC &gt;::get_bit_block_COUNT_A()</a>, <a class="el" href="a00096_source.html#l02344">bm::serial_stream_iterator&lt; DEC &gt;::get_bit_block_COUNT_AND()</a>, <a class="el" href="a00096_source.html#l02403">bm::serial_stream_iterator&lt; DEC &gt;::get_bit_block_COUNT_OR()</a>, <a class="el" href="a00096_source.html#l02559">bm::serial_stream_iterator&lt; DEC &gt;::get_bit_block_COUNT_SUB_AB()</a>, <a class="el" href="a00096_source.html#l02638">bm::serial_stream_iterator&lt; DEC &gt;::get_bit_block_COUNT_SUB_BA()</a>, <a class="el" href="a00096_source.html#l02481">bm::serial_stream_iterator&lt; DEC &gt;::get_bit_block_COUNT_XOR()</a>, <a class="el" href="a00096_source.html#l01972">bm::serial_stream_iterator&lt; DEC &gt;::get_bit_block_OR()</a>, <a class="el" href="a00096_source.html#l02165">bm::serial_stream_iterator&lt; DEC &gt;::get_bit_block_SUB()</a>, <a class="el" href="a00096_source.html#l02105">bm::serial_stream_iterator&lt; DEC &gt;::get_bit_block_XOR()</a>, <a class="el" href="a00096_source.html#l01762">bm::serial_stream_iterator&lt; DEC &gt;::next()</a>, and <a class="el" href="a00096_source.html#l00814">bm::serializer&lt; BV &gt;::serialize()</a>.</p>

</div>
</div>
<a class="anchor" id="a5e21adca3bc6902f33e43e5cfd824f0e"></a><!-- doxytag: member="bm::set_block_bit_0runs" ref="a5e21adca3bc6902f33e43e5cfd824f0e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned char <a class="el" href="a00115.html#a5e21adca3bc6902f33e43e5cfd824f0e">bm::set_block_bit_0runs</a> = 22</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Bit block with encoded zero intervals. </p>

<p>Definition at line <a class="el" href="a00096_source.html#l00089">89</a> of file <a class="el" href="a00096_source.html">bmserial.h</a>.</p>

<p>Referenced by <a class="el" href="a00096_source.html#l01424">bm::deserializer&lt; BV, DEC &gt;::deserialize()</a>, <a class="el" href="a00096_source.html#l00762">bm::serializer&lt; BV &gt;::encode_bit_interval()</a>, <a class="el" href="a00096_source.html#l02034">bm::serial_stream_iterator&lt; DEC &gt;::get_bit_block_AND()</a>, <a class="el" href="a00096_source.html#l01910">bm::serial_stream_iterator&lt; DEC &gt;::get_bit_block_ASSIGN()</a>, <a class="el" href="a00096_source.html#l02224">bm::serial_stream_iterator&lt; DEC &gt;::get_bit_block_COUNT()</a>, <a class="el" href="a00096_source.html#l02281">bm::serial_stream_iterator&lt; DEC &gt;::get_bit_block_COUNT_A()</a>, <a class="el" href="a00096_source.html#l02344">bm::serial_stream_iterator&lt; DEC &gt;::get_bit_block_COUNT_AND()</a>, <a class="el" href="a00096_source.html#l02403">bm::serial_stream_iterator&lt; DEC &gt;::get_bit_block_COUNT_OR()</a>, <a class="el" href="a00096_source.html#l02559">bm::serial_stream_iterator&lt; DEC &gt;::get_bit_block_COUNT_SUB_AB()</a>, <a class="el" href="a00096_source.html#l02638">bm::serial_stream_iterator&lt; DEC &gt;::get_bit_block_COUNT_SUB_BA()</a>, <a class="el" href="a00096_source.html#l02481">bm::serial_stream_iterator&lt; DEC &gt;::get_bit_block_COUNT_XOR()</a>, <a class="el" href="a00096_source.html#l01972">bm::serial_stream_iterator&lt; DEC &gt;::get_bit_block_OR()</a>, <a class="el" href="a00096_source.html#l02165">bm::serial_stream_iterator&lt; DEC &gt;::get_bit_block_SUB()</a>, <a class="el" href="a00096_source.html#l02105">bm::serial_stream_iterator&lt; DEC &gt;::get_bit_block_XOR()</a>, and <a class="el" href="a00096_source.html#l01762">bm::serial_stream_iterator&lt; DEC &gt;::next()</a>.</p>

</div>
</div>
<a class="anchor" id="ad0e6607a9771fa49a658c3078208c2dc"></a><!-- doxytag: member="bm::set_block_bit_1bit" ref="ad0e6607a9771fa49a658c3078208c2dc" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned char <a class="el" href="a00115.html#ad0e6607a9771fa49a658c3078208c2dc">bm::set_block_bit_1bit</a> = 19</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Bit block with 1 bit ON. </p>

<p>Definition at line <a class="el" href="a00096_source.html#l00086">86</a> of file <a class="el" href="a00096_source.html">bmserial.h</a>.</p>

<p>Referenced by <a class="el" href="a00096_source.html#l03101">bm::iterator_deserializer&lt; BV, SerialIterator &gt;::deserialize()</a>, <a class="el" href="a00096_source.html#l01424">bm::deserializer&lt; BV, DEC &gt;::deserialize()</a>, <a class="el" href="a00096_source.html#l00709">bm::serializer&lt; BV &gt;::encode_gap_block()</a>, <a class="el" href="a00096_source.html#l02711">bm::serial_stream_iterator&lt; DEC &gt;::get_arr_bit()</a>, <a class="el" href="a00096_source.html#l02749">bm::serial_stream_iterator&lt; DEC &gt;::get_bit()</a>, <a class="el" href="a00096_source.html#l02034">bm::serial_stream_iterator&lt; DEC &gt;::get_bit_block_AND()</a>, <a class="el" href="a00096_source.html#l01910">bm::serial_stream_iterator&lt; DEC &gt;::get_bit_block_ASSIGN()</a>, <a class="el" href="a00096_source.html#l02224">bm::serial_stream_iterator&lt; DEC &gt;::get_bit_block_COUNT()</a>, <a class="el" href="a00096_source.html#l02281">bm::serial_stream_iterator&lt; DEC &gt;::get_bit_block_COUNT_A()</a>, <a class="el" href="a00096_source.html#l02344">bm::serial_stream_iterator&lt; DEC &gt;::get_bit_block_COUNT_AND()</a>, <a class="el" href="a00096_source.html#l02403">bm::serial_stream_iterator&lt; DEC &gt;::get_bit_block_COUNT_OR()</a>, <a class="el" href="a00096_source.html#l02559">bm::serial_stream_iterator&lt; DEC &gt;::get_bit_block_COUNT_SUB_AB()</a>, <a class="el" href="a00096_source.html#l02638">bm::serial_stream_iterator&lt; DEC &gt;::get_bit_block_COUNT_SUB_BA()</a>, <a class="el" href="a00096_source.html#l02481">bm::serial_stream_iterator&lt; DEC &gt;::get_bit_block_COUNT_XOR()</a>, <a class="el" href="a00096_source.html#l01972">bm::serial_stream_iterator&lt; DEC &gt;::get_bit_block_OR()</a>, <a class="el" href="a00096_source.html#l02165">bm::serial_stream_iterator&lt; DEC &gt;::get_bit_block_SUB()</a>, <a class="el" href="a00096_source.html#l02105">bm::serial_stream_iterator&lt; DEC &gt;::get_bit_block_XOR()</a>, <a class="el" href="a00096_source.html#l02760">bm::serial_stream_iterator&lt; DEC &gt;::get_gap_block()</a>, <a class="el" href="a00096_source.html#l01762">bm::serial_stream_iterator&lt; DEC &gt;::next()</a>, <a class="el" href="a00096_source.html#l01227">bm::deseriaizer_base&lt; DEC &gt;::read_gap_block()</a>, <a class="el" href="a00096_source.html#l01184">bm::deseriaizer_base&lt; DEC &gt;::read_id_list()</a>, and <a class="el" href="a00096_source.html#l00814">bm::serializer&lt; BV &gt;::serialize()</a>.</p>

</div>
</div>
<a class="anchor" id="a0f2d3289a95dc3bd224a6a73c3d3afce"></a><!-- doxytag: member="bm::set_block_bit_interval" ref="a0f2d3289a95dc3bd224a6a73c3d3afce" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned char <a class="el" href="a00115.html#a0f2d3289a95dc3bd224a6a73c3d3afce">bm::set_block_bit_interval</a> = 17</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Interval block. </p>

<p>Definition at line <a class="el" href="a00096_source.html#l00084">84</a> of file <a class="el" href="a00096_source.html">bmserial.h</a>.</p>

<p>Referenced by <a class="el" href="a00096_source.html#l01424">bm::deserializer&lt; BV, DEC &gt;::deserialize()</a>, <a class="el" href="a00096_source.html#l02034">bm::serial_stream_iterator&lt; DEC &gt;::get_bit_block_AND()</a>, <a class="el" href="a00096_source.html#l01910">bm::serial_stream_iterator&lt; DEC &gt;::get_bit_block_ASSIGN()</a>, <a class="el" href="a00096_source.html#l02224">bm::serial_stream_iterator&lt; DEC &gt;::get_bit_block_COUNT()</a>, <a class="el" href="a00096_source.html#l02281">bm::serial_stream_iterator&lt; DEC &gt;::get_bit_block_COUNT_A()</a>, <a class="el" href="a00096_source.html#l02344">bm::serial_stream_iterator&lt; DEC &gt;::get_bit_block_COUNT_AND()</a>, <a class="el" href="a00096_source.html#l02403">bm::serial_stream_iterator&lt; DEC &gt;::get_bit_block_COUNT_OR()</a>, <a class="el" href="a00096_source.html#l02559">bm::serial_stream_iterator&lt; DEC &gt;::get_bit_block_COUNT_SUB_AB()</a>, <a class="el" href="a00096_source.html#l02638">bm::serial_stream_iterator&lt; DEC &gt;::get_bit_block_COUNT_SUB_BA()</a>, <a class="el" href="a00096_source.html#l02481">bm::serial_stream_iterator&lt; DEC &gt;::get_bit_block_COUNT_XOR()</a>, <a class="el" href="a00096_source.html#l01972">bm::serial_stream_iterator&lt; DEC &gt;::get_bit_block_OR()</a>, <a class="el" href="a00096_source.html#l02165">bm::serial_stream_iterator&lt; DEC &gt;::get_bit_block_SUB()</a>, <a class="el" href="a00096_source.html#l02105">bm::serial_stream_iterator&lt; DEC &gt;::get_bit_block_XOR()</a>, and <a class="el" href="a00096_source.html#l01762">bm::serial_stream_iterator&lt; DEC &gt;::next()</a>.</p>

</div>
</div>
<a class="anchor" id="aa24e7c08930cf959d383c6b930fb0508"></a><!-- doxytag: member="bm::set_block_end" ref="aa24e7c08930cf959d383c6b930fb0508" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned char <a class="el" href="a00115.html#aa24e7c08930cf959d383c6b930fb0508">bm::set_block_end</a> = 0</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>End of serialization. </p>

<p>Definition at line <a class="el" href="a00096_source.html#l00067">67</a> of file <a class="el" href="a00096_source.html">bmserial.h</a>.</p>

<p>Referenced by <a class="el" href="a00096_source.html#l01424">bm::deserializer&lt; BV, DEC &gt;::deserialize()</a>, <a class="el" href="a00096_source.html#l01762">bm::serial_stream_iterator&lt; DEC &gt;::next()</a>, and <a class="el" href="a00096_source.html#l00814">bm::serializer&lt; BV &gt;::serialize()</a>.</p>

</div>
</div>
<a class="anchor" id="a09b8c4b17b7d6f613c237c46d04a9cd6"></a><!-- doxytag: member="bm::set_block_gap" ref="a09b8c4b17b7d6f613c237c46d04a9cd6" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned char <a class="el" href="a00115.html#a09b8c4b17b7d6f613c237c46d04a9cd6">bm::set_block_gap</a> = 14</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Plain GAP block. </p>

<p>Definition at line <a class="el" href="a00096_source.html#l00081">81</a> of file <a class="el" href="a00096_source.html">bmserial.h</a>.</p>

<p>Referenced by <a class="el" href="a00096_source.html#l01424">bm::deserializer&lt; BV, DEC &gt;::deserialize()</a>, <a class="el" href="a00096_source.html#l01316">bm::deserializer&lt; BV, DEC &gt;::deserialize_gap()</a>, <a class="el" href="a00096_source.html#l00625">bm::serializer&lt; BV &gt;::gamma_gap_block()</a>, <a class="el" href="a00096_source.html#l01762">bm::serial_stream_iterator&lt; DEC &gt;::next()</a>, and <a class="el" href="a00096_source.html#l01227">bm::deseriaizer_base&lt; DEC &gt;::read_gap_block()</a>.</p>

</div>
</div>
<a class="anchor" id="ac47dea3917e15264ed3ba0cf4055adbe"></a><!-- doxytag: member="bm::set_block_gap_egamma" ref="ac47dea3917e15264ed3ba0cf4055adbe" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned char <a class="el" href="a00115.html#ac47dea3917e15264ed3ba0cf4055adbe">bm::set_block_gap_egamma</a> = 20</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gamma compressed GAP block. </p>

<p>Definition at line <a class="el" href="a00096_source.html#l00087">87</a> of file <a class="el" href="a00096_source.html">bmserial.h</a>.</p>

<p>Referenced by <a class="el" href="a00096_source.html#l01424">bm::deserializer&lt; BV, DEC &gt;::deserialize()</a>, <a class="el" href="a00096_source.html#l01316">bm::deserializer&lt; BV, DEC &gt;::deserialize_gap()</a>, <a class="el" href="a00096_source.html#l00625">bm::serializer&lt; BV &gt;::gamma_gap_block()</a>, <a class="el" href="a00096_source.html#l01762">bm::serial_stream_iterator&lt; DEC &gt;::next()</a>, and <a class="el" href="a00096_source.html#l01227">bm::deseriaizer_base&lt; DEC &gt;::read_gap_block()</a>.</p>

</div>
</div>
<a class="anchor" id="a77dc965397e31a1d39c3d8e628792779"></a><!-- doxytag: member="bm::set_block_gapbit" ref="a77dc965397e31a1d39c3d8e628792779" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned char <a class="el" href="a00115.html#a77dc965397e31a1d39c3d8e628792779">bm::set_block_gapbit</a> = 15</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>GAP compressed bitblock. </p>

<p>Definition at line <a class="el" href="a00096_source.html#l00082">82</a> of file <a class="el" href="a00096_source.html">bmserial.h</a>.</p>

<p>Referenced by <a class="el" href="a00096_source.html#l01424">bm::deserializer&lt; BV, DEC &gt;::deserialize()</a>, <a class="el" href="a00096_source.html#l01316">bm::deserializer&lt; BV, DEC &gt;::deserialize_gap()</a>, <a class="el" href="a00096_source.html#l01910">bm::serial_stream_iterator&lt; DEC &gt;::get_bit_block_ASSIGN()</a>, and <a class="el" href="a00096_source.html#l01762">bm::serial_stream_iterator&lt; DEC &gt;::next()</a>.</p>

</div>
</div>
<a class="anchor" id="a201fb8b1f81b7487f1c1c129fc3d6557"></a><!-- doxytag: member="bm::set_block_mask" ref="a201fb8b1f81b7487f1c1c129fc3d6557" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned <a class="el" href="a00115.html#a201fb8b1f81b7487f1c1c129fc3d6557">bm::set_block_mask</a> = 0xFFFFu</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="a00091_source.html#l00054">54</a> of file <a class="el" href="a00091_source.html">bmconst.h</a>.</p>

<p>Referenced by <a class="el" href="a00089_source.html#l01141">combine_or()</a>, <a class="el" href="a00089_source.html#l01304">combine_sub()</a>, <a class="el" href="a00089_source.html#l01220">combine_xor()</a>, <a class="el" href="a00087_source.html#l01687">bm::bvector&lt; Alloc &gt;::count_range()</a>, <a class="el" href="a00087_source.html#l01804">bm::bvector&lt; Alloc &gt;::get_bit()</a>, <a class="el" href="a00093_source.html#l01491">or_bit_block()</a>, <a class="el" href="a00093_source.html#l01461">set_bit()</a>, <a class="el" href="a00093_source.html#l01553">sub_bit_block()</a>, <a class="el" href="a00093_source.html#l01474">test_bit()</a>, and <a class="el" href="a00093_source.html#l01615">xor_bit_block()</a>.</p>

</div>
</div>
<a class="anchor" id="a3428cf384446982017ba9ee68152d238"></a><!-- doxytag: member="bm::set_block_plain_cnt" ref="a3428cf384446982017ba9ee68152d238" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned <a class="el" href="a00115.html#a3428cf384446982017ba9ee68152d238">bm::set_block_plain_cnt</a> = sizeof(<a class="el" href="a00115.html#a17fd5ba52db3ddda05e6f8dd5000a1a4">bm::word_t</a>) * 8u</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="a00091_source.html#l00058">58</a> of file <a class="el" href="a00091_source.html">bmconst.h</a>.</p>

</div>
</div>
<a class="anchor" id="a35780565f6d8f2831ebff8877d3ba662"></a><!-- doxytag: member="bm::set_block_plain_size" ref="a35780565f6d8f2831ebff8877d3ba662" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned <a class="el" href="a00115.html#a35780565f6d8f2831ebff8877d3ba662">bm::set_block_plain_size</a> = <a class="el" href="a00115.html#a91319dbc0d0e1bf3a3efc4d92bac7972">set_block_size</a> / 32u</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="a00091_source.html#l00057">57</a> of file <a class="el" href="a00091_source.html">bmconst.h</a>.</p>

</div>
</div>
<a class="anchor" id="afe4b1011b09271c5f3882b926e250d39"></a><!-- doxytag: member="bm::set_block_sgapbit" ref="afe4b1011b09271c5f3882b926e250d39" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned char <a class="el" href="a00115.html#afe4b1011b09271c5f3882b926e250d39">bm::set_block_sgapbit</a> = 12</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>SGAP compressed bitblock. </p>

<p>Definition at line <a class="el" href="a00096_source.html#l00079">79</a> of file <a class="el" href="a00096_source.html">bmserial.h</a>.</p>

</div>
</div>
<a class="anchor" id="ab3a8d57c0b898c3c5a23cd27a8f856ad"></a><!-- doxytag: member="bm::set_block_sgapgap" ref="ab3a8d57c0b898c3c5a23cd27a8f856ad" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned char <a class="el" href="a00115.html#ab3a8d57c0b898c3c5a23cd27a8f856ad">bm::set_block_sgapgap</a> = 13</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>SGAP compressed GAP block. </p>

<p>Definition at line <a class="el" href="a00096_source.html#l00080">80</a> of file <a class="el" href="a00096_source.html">bmserial.h</a>.</p>

</div>
</div>
<a class="anchor" id="ad8723fbeea6290d3daa8917ea7ce9bb2"></a><!-- doxytag: member="bm::set_block_shift" ref="ad8723fbeea6290d3daa8917ea7ce9bb2" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned <a class="el" href="a00115.html#ad8723fbeea6290d3daa8917ea7ce9bb2">bm::set_block_shift</a> = 16u</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="a00091_source.html#l00053">53</a> of file <a class="el" href="a00091_source.html">bmconst.h</a>.</p>

<p>Referenced by <a class="el" href="a00089_source.html#l01111">block_range_scan()</a>, <a class="el" href="a00089_source.html#l01141">combine_or()</a>, <a class="el" href="a00089_source.html#l01304">combine_sub()</a>, <a class="el" href="a00089_source.html#l01220">combine_xor()</a>, <a class="el" href="a00087_source.html#l01687">bm::bvector&lt; Alloc &gt;::count_range()</a>, <a class="el" href="a00096_source.html#l03101">bm::iterator_deserializer&lt; BV, SerialIterator &gt;::deserialize()</a>, and <a class="el" href="a00087_source.html#l01804">bm::bvector&lt; Alloc &gt;::get_bit()</a>.</p>

</div>
</div>
<a class="anchor" id="a91319dbc0d0e1bf3a3efc4d92bac7972"></a><!-- doxytag: member="bm::set_block_size" ref="a91319dbc0d0e1bf3a3efc4d92bac7972" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned <a class="el" href="a00115.html#a91319dbc0d0e1bf3a3efc4d92bac7972">bm::set_block_size</a> = 2048u</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="a00091_source.html#l00052">52</a> of file <a class="el" href="a00091_source.html">bmconst.h</a>.</p>

<p>Referenced by <a class="el" href="a00093_source.html#l00066">bm::bv_statistics::add_bit_block()</a>, <a class="el" href="a00090_source.html#l00173">bm::mem_alloc&lt; BA, PA &gt;::alloc_bit_block()</a>, <a class="el" href="a00093_source.html#l03446">bit_block_and()</a>, <a class="el" href="a00093_source.html#l03426">bit_block_copy()</a>, <a class="el" href="a00093_source.html#l04060">bit_block_or()</a>, <a class="el" href="a00093_source.html#l02126">bit_block_set()</a>, <a class="el" href="a00093_source.html#l04156">bit_block_sub()</a>, <a class="el" href="a00093_source.html#l04252">bit_block_xor()</a>, <a class="el" href="a00093_source.html#l04445">bit_find_in_block()</a>, <a class="el" href="a00093_source.html#l04098">bit_operation_or()</a>, <a class="el" href="a00089_source.html#l00366">combine_any_operation_with_block()</a>, <a class="el" href="a00089_source.html#l00329">combine_count_and_operation_with_block()</a>, <a class="el" href="a00089_source.html#l00116">combine_count_operation_with_block()</a>, <a class="el" href="a00096_source.html#l01424">bm::deserializer&lt; BV, DEC &gt;::deserialize()</a>, <a class="el" href="a00096_source.html#l00762">bm::serializer&lt; BV &gt;::encode_bit_interval()</a>, <a class="el" href="a00089_source.html#l01467">export_array()</a>, <a class="el" href="a00090_source.html#l00180">bm::mem_alloc&lt; BA, PA &gt;::free_bit_block()</a>, <a class="el" href="a00096_source.html#l02034">bm::serial_stream_iterator&lt; DEC &gt;::get_bit_block_AND()</a>, <a class="el" href="a00096_source.html#l01910">bm::serial_stream_iterator&lt; DEC &gt;::get_bit_block_ASSIGN()</a>, <a class="el" href="a00096_source.html#l02224">bm::serial_stream_iterator&lt; DEC &gt;::get_bit_block_COUNT()</a>, <a class="el" href="a00096_source.html#l02281">bm::serial_stream_iterator&lt; DEC &gt;::get_bit_block_COUNT_A()</a>, <a class="el" href="a00096_source.html#l02344">bm::serial_stream_iterator&lt; DEC &gt;::get_bit_block_COUNT_AND()</a>, <a class="el" href="a00096_source.html#l02403">bm::serial_stream_iterator&lt; DEC &gt;::get_bit_block_COUNT_OR()</a>, <a class="el" href="a00096_source.html#l02559">bm::serial_stream_iterator&lt; DEC &gt;::get_bit_block_COUNT_SUB_AB()</a>, <a class="el" href="a00096_source.html#l02638">bm::serial_stream_iterator&lt; DEC &gt;::get_bit_block_COUNT_SUB_BA()</a>, <a class="el" href="a00096_source.html#l02481">bm::serial_stream_iterator&lt; DEC &gt;::get_bit_block_COUNT_XOR()</a>, <a class="el" href="a00096_source.html#l01972">bm::serial_stream_iterator&lt; DEC &gt;::get_bit_block_OR()</a>, <a class="el" href="a00096_source.html#l02165">bm::serial_stream_iterator&lt; DEC &gt;::get_bit_block_SUB()</a>, <a class="el" href="a00096_source.html#l02105">bm::serial_stream_iterator&lt; DEC &gt;::get_bit_block_XOR()</a>, <a class="el" href="a00087_source.html#l00500">bm::bvector&lt; Alloc &gt;::enumerator::go_up()</a>, and <a class="el" href="a00096_source.html#l00814">bm::serializer&lt; BV &gt;::serialize()</a>.</p>

</div>
</div>
<a class="anchor" id="a7049fd70220fc3a3072e9f82abf4ad66"></a><!-- doxytag: member="bm::set_block_size_op" ref="a7049fd70220fc3a3072e9f82abf4ad66" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned <a class="el" href="a00115.html#a7049fd70220fc3a3072e9f82abf4ad66">bm::set_block_size_op</a> = <a class="el" href="a00115.html#a91319dbc0d0e1bf3a3efc4d92bac7972">bm::set_block_size</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="a00091_source.html#l00105">105</a> of file <a class="el" href="a00091_source.html">bmconst.h</a>.</p>

<p>Referenced by <a class="el" href="a00087_source.html#l01914">bm::bvector&lt; Alloc &gt;::compare()</a>.</p>

</div>
</div>
<a class="anchor" id="a505011007f54598794e0b9477c0b0b11"></a><!-- doxytag: member="bm::set_total_blocks" ref="a505011007f54598794e0b9477c0b0b11" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned <a class="el" href="a00115.html#a505011007f54598794e0b9477c0b0b11">bm::set_total_blocks</a> = (<a class="el" href="a00115.html#a40ad34d6c46a2fb20ba2baa7f95d80b4">bm::set_array_size</a> * <a class="el" href="a00115.html#a40ad34d6c46a2fb20ba2baa7f95d80b4">bm::set_array_size</a>)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="a00091_source.html#l00084">84</a> of file <a class="el" href="a00091_source.html">bmconst.h</a>.</p>

<p>Referenced by <a class="el" href="a00096_source.html#l01424">bm::deserializer&lt; BV, DEC &gt;::deserialize()</a>, <a class="el" href="a00089_source.html#l01467">export_array()</a>, <a class="el" href="a00096_source.html#l01762">bm::serial_stream_iterator&lt; DEC &gt;::next()</a>, and <a class="el" href="a00096_source.html#l00814">bm::serializer&lt; BV &gt;::serialize()</a>.</p>

</div>
</div>
<a class="anchor" id="addbf345be3733d5e4575d71733ed1da8"></a><!-- doxytag: member="bm::set_word_mask" ref="addbf345be3733d5e4575d71733ed1da8" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned <a class="el" href="a00115.html#addbf345be3733d5e4575d71733ed1da8">bm::set_word_mask</a> = 0x1Fu</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="a00091_source.html#l00063">63</a> of file <a class="el" href="a00091_source.html">bmconst.h</a>.</p>

<p>Referenced by <a class="el" href="a00093_source.html#l03016">bit_block_any_range()</a>, <a class="el" href="a00093_source.html#l02950">bit_block_calc_count_range()</a>, <a class="el" href="a00093_source.html#l04445">bit_find_in_block()</a>, <a class="el" href="a00089_source.html#l01141">combine_or()</a>, <a class="el" href="a00089_source.html#l01304">combine_sub()</a>, <a class="el" href="a00089_source.html#l01220">combine_xor()</a>, <a class="el" href="a00087_source.html#l01804">bm::bvector&lt; Alloc &gt;::get_bit()</a>, <a class="el" href="a00093_source.html#l01491">or_bit_block()</a>, <a class="el" href="a00103_source.html#l00242">bm::bvmini&lt; N &gt;::set()</a>, <a class="el" href="a00103_source.html#l00106">bm::miniset&lt; A, N &gt;::set()</a>, <a class="el" href="a00093_source.html#l01461">set_bit()</a>, <a class="el" href="a00093_source.html#l01553">sub_bit_block()</a>, <a class="el" href="a00103_source.html#l00237">bm::bvmini&lt; N &gt;::test()</a>, <a class="el" href="a00103_source.html#l00095">bm::miniset&lt; A, N &gt;::test()</a>, <a class="el" href="a00093_source.html#l01474">test_bit()</a>, and <a class="el" href="a00093_source.html#l01615">xor_bit_block()</a>.</p>

</div>
</div>
<a class="anchor" id="a83d76bccf6fe3770f32d5ba11d2a37ad"></a><!-- doxytag: member="bm::set_word_shift" ref="a83d76bccf6fe3770f32d5ba11d2a37ad" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned <a class="el" href="a00115.html#a83d76bccf6fe3770f32d5ba11d2a37ad">bm::set_word_shift</a> = 5u</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="a00091_source.html#l00062">62</a> of file <a class="el" href="a00091_source.html">bmconst.h</a>.</p>

<p>Referenced by <a class="el" href="a00093_source.html#l03016">bit_block_any_range()</a>, <a class="el" href="a00093_source.html#l02950">bit_block_calc_count_range()</a>, <a class="el" href="a00093_source.html#l04445">bit_find_in_block()</a>, <a class="el" href="a00089_source.html#l01141">combine_or()</a>, <a class="el" href="a00089_source.html#l01304">combine_sub()</a>, <a class="el" href="a00089_source.html#l01220">combine_xor()</a>, <a class="el" href="a00087_source.html#l01804">bm::bvector&lt; Alloc &gt;::get_bit()</a>, <a class="el" href="a00093_source.html#l01491">or_bit_block()</a>, <a class="el" href="a00103_source.html#l00242">bm::bvmini&lt; N &gt;::set()</a>, <a class="el" href="a00103_source.html#l00106">bm::miniset&lt; A, N &gt;::set()</a>, <a class="el" href="a00093_source.html#l01461">set_bit()</a>, <a class="el" href="a00093_source.html#l01553">sub_bit_block()</a>, <a class="el" href="a00103_source.html#l00237">bm::bvmini&lt; N &gt;::test()</a>, <a class="el" href="a00103_source.html#l00095">bm::miniset&lt; A, N &gt;::test()</a>, <a class="el" href="a00093_source.html#l01474">test_bit()</a>, and <a class="el" href="a00093_source.html#l01615">xor_bit_block()</a>.</p>

</div>
</div>
</div>
<hr size="1"/><address style="text-align: right;"><small>Generated on Sun Apr 25 09:37:44 2010 for BitMagic by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
